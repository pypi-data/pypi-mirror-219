!
! Wrapper for mod_{{ module.short_name }}_manager
! Exposes the {{ calculator.name }} calculator
!
module {{ module.wrapper_module_name }}
    use {{ calculator_module }}, only: &
        manager_get_free_instance => get_free_instance_number, &
        manager_instance_finalize => instance_finalize, &
        ! manager_get_instance => get_instance, &
        manager_instance_array => instance_array, &
        check_index_claimed

    use {{ module.name }}, only: &
        {{ calculator.name }}

    implicit none
    private

    ! TODO: handle cases where more complicated wrappers are needed
    public :: get_free_instance, &
              instance_build, &
              instance_finalize

    ! Getters
    {% for attribute in calculator.exposed_attributes().keys() %}
    public :: ig_{{ attribute }}
    {% endfor %}
    ! Calculator methods
    {% for method in calculator.methods.keys() %}
    public :: i_{{ method }}
    {% endfor %}
contains

    function get_free_instance() result(model_index)

        integer :: model_index

        model_index = manager_get_free_instance()

    end function get_free_instance

    subroutine instance_finalize(model_index)

        integer, intent(in) :: model_index

        call manager_instance_finalize(model_index)

    end subroutine instance_finalize

    !
    ! Build a new instance
    !
    subroutine instance_build( &
        model_index, &
        {% for attribute in calculator.attributes.keys() %}
        {{ attribute }}{{ "," if not loop.last else "" }} &
        {% endfor %}
        )

        integer, intent(in) :: model_index
        {% for attribute_name, attribute in calculator.attributes.items() %}
        {{ attribute.type }}, intent(in) :: {{ attribute_name }}
        {% endfor %}

        ! TODO: update when get_instance is fixed
        call check_index_claimed(model_index)
        !call manager_get_instance(model_index, instance)

        call manager_instance_array(model_index) % build( &
            {% for attribute in calculator.attributes.keys() %}
            {{ attribute }}{{ "," if not loop.last else "" }} &
            {% endfor %}
            )

    end subroutine instance_build

    !
    ! Calculator accessors
    !

    {% for name, attribute in calculator.exposed_attributes().items() %}
    function ig_{{ name }}(model_index) result({{ name }})

        integer, intent(in) :: model_index
        {{ attribute.type }} :: {{ name }}

        ! TODO: update when get_instance is fixed
        call check_index_claimed(model_index)
        !call manager_get_instance(model_index, instance)

        {{ name }} = manager_instance_array(model_index) % {{ name }}

    end function ig_{{ name }}

    {% endfor %}
    !
    ! Calculator methods
    !
    {% for name, method in calculator.methods.items() %}

    function i_{{ name }}( &
        model_index{{ "," if method.parameters | length > 0 else "" }} &
        {% for param_name in method.parameters.keys() %}
        {{ param_name }}{{ "," if not loop.last else "" }} &
        {% endfor %}
        ) result({{ method.returns.name }})

        ! Should work out consistent approach to whether we use intent or not...
        integer :: model_index
        {% for param_name, param in method.parameters.items() %}
        {{ param.type }} :: {{ param_name }}
        {% endfor %}

        {{ method.returns.type }} :: {{ method.returns.name }}

        ! TODO: update when get_instance is fixed
        call check_index_claimed(model_index)
        !call manager_get_instance(model_index, instance)

        !&<
        {{ method.returns.name }} = manager_instance_array(model_index) % {{ name }}( &
            {% for param_name in method.parameters.keys() %}
            {{ param_name }}{{ "," if not loop.last else "" }} &
            {% endfor %}
            )
        !&>
    end function i_{{ name }}
    {% endfor %}

end module {{ module.wrapper_module_name }}
