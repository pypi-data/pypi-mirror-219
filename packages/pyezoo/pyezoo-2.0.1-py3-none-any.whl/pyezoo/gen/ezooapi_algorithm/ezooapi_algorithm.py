#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def query_pagerank(self, db_name, damping_factor, epoch_limit, max_convergence_error, vertex_init_value, edge_type, edge_props_name, bidirection):
        """
        Parameters:
         - db_name
         - damping_factor
         - epoch_limit
         - max_convergence_error
         - vertex_init_value
         - edge_type
         - edge_props_name
         - bidirection

        """
        pass

    def query_pagerank_top_k(self, db_name, damping_factor, epoch_limit, max_convergence_error, vertex_init_value, edge_type, edge_props_name, bidirection, top_k):
        """
        Parameters:
         - db_name
         - damping_factor
         - epoch_limit
         - max_convergence_error
         - vertex_init_value
         - edge_type
         - edge_props_name
         - bidirection
         - top_k

        """
        pass

    def query_betcentrality(self, db_name, search_direction, hop):
        """
        Parameters:
         - db_name
         - search_direction
         - hop

        """
        pass

    def query_clocentrality(self, db_name, if_WF, hop):
        """
        Parameters:
         - db_name
         - if_WF
         - hop

        """
        pass

    def query_louvain(self, db_name, edge_type, edge_props_name):
        """
        Parameters:
         - db_name
         - edge_type
         - edge_props_name

        """
        pass

    def query_k_core(self, db_name, k_max):
        """
        Parameters:
         - db_name
         - k_max

        """
        pass

    def query_wcc(self, db_name):
        """
        Parameters:
         - db_name

        """
        pass

    def query_scc(self, db_name):
        """
        Parameters:
         - db_name

        """
        pass

    def query_lpa(self, db_name, epoch_limit):
        """
        Parameters:
         - db_name
         - epoch_limit

        """
        pass

    def query_lpa_sync(self, db_name, epoch_limit):
        """
        Parameters:
         - db_name
         - epoch_limit

        """
        pass

    def query_dijkstra(self, db_name, src_node_id, dest_node_id, search_direction, edge_type, edge_props_name):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id
         - search_direction
         - edge_type
         - edge_props_name

        """
        pass

    def query_random_walk_sub(self, db_name, node_id, length, num_walks, p, q, search_direction):
        """
        Parameters:
         - db_name
         - node_id
         - length
         - num_walks
         - p
         - q
         - search_direction

        """
        pass

    def query_euclidean_distance(self, db_name, A, B):
        """
        Parameters:
         - db_name
         - A
         - B

        """
        pass

    def query_pearson_similarity(self, db_name, A, B):
        """
        Parameters:
         - db_name
         - A
         - B

        """
        pass

    def query_overlap_similarity(self, db_name, A, B):
        """
        Parameters:
         - db_name
         - A
         - B

        """
        pass

    def query_jaccard_similarity(self, db_name, A, B):
        """
        Parameters:
         - db_name
         - A
         - B

        """
        pass

    def query_jaccard_similarity_between_two_node(self, db_name, A, B):
        """
        Parameters:
         - db_name
         - A
         - B

        """
        pass

    def query_cosine_similarity_neighborhoods_single_source(self, db_name, node_id, e_type, weight, top_k):
        """
        Parameters:
         - db_name
         - node_id
         - e_type
         - weight
         - top_k

        """
        pass

    def query_knn_cosine_single_source(self, db_name, node_id, e_type, weight, top_k):
        """
        Parameters:
         - db_name
         - node_id
         - e_type
         - weight
         - top_k

        """
        pass

    def query_greedy_graph_coloring(self, db_name, node_type_set, edge_type_set):
        """
        Parameters:
         - db_name
         - node_type_set
         - edge_type_set

        """
        pass

    def query_slpa(self, db_name, node_type_set, edge_type_set, threshold, max_iter, output_limit):
        """
        Parameters:
         - db_name
         - node_type_set
         - edge_type_set
         - threshold
         - max_iter
         - output_limit

        """
        pass

    def query_triangle_count(self, db_name, node_type_set, edge_type_set):
        """
        Parameters:
         - db_name
         - node_type_set
         - edge_type_set

        """
        pass

    def query_local_clustering_coefficient(self, db_name, node_type_set, edge_type_set, top_k):
        """
        Parameters:
         - db_name
         - node_type_set
         - edge_type_set
         - top_k

        """
        pass

    def query_single_source_shortest_path_unweighted(self, db_name, node_id, node_type_set, edge_type_set, k_min, k_max, search_direction, max_size):
        """
        Parameters:
         - db_name
         - node_id
         - node_type_set
         - edge_type_set
         - k_min
         - k_max
         - search_direction
         - max_size

        """
        pass

    def query_money_flow(self, db_name, start_node, start_time, end_time, money_percent, time_window, edge_type, time_props, money_props, mode):
        """
        Parameters:
         - db_name
         - start_node
         - start_time
         - end_time
         - money_percent
         - time_window
         - edge_type
         - time_props
         - money_props
         - mode

        """
        pass

    def query_cluster_for_studio(self, db_name, node_list, edge_list):
        """
        Parameters:
         - db_name
         - node_list
         - edge_list

        """
        pass

    def query_prop_cluster(self, db_name, node_list, edge_list, type_prop):
        """
        Parameters:
         - db_name
         - node_list
         - edge_list
         - type_prop

        """
        pass

    def query_one_neighbour(self, db_name, node_id, search_direction):
        """
        Parameters:
         - db_name
         - node_id
         - search_direction

        """
        pass

    def query_simple_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_simple_neighbour_limit(self, db_name, node_id, k_min, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size

        """
        pass

    def query_common_simple_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_neighbour_count(self, db_name, node_id, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_simple_path(self, db_name, src_node_id, dest_node_id, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id
         - k_max
         - search_direction
         - condition
         - max_size

        """
        pass

    def query_full_path(self, db_name, src_node_id, dest_node_id, k_max, search_direction, condition, max_size, distinct):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id
         - k_max
         - search_direction
         - condition
         - max_size
         - distinct

        """
        pass

    def query_full_path_with_set(self, db_name, src_node_id_set, dest_node_id_set, k_max, search_direction, condition, max_size, distinct):
        """
        Parameters:
         - db_name
         - src_node_id_set
         - dest_node_id_set
         - k_max
         - search_direction
         - condition
         - max_size
         - distinct

        """
        pass

    def query_shortest_path(self, db_name, a_node_id, b_node_id, condition, k_max, search_direction):
        """
        Parameters:
         - db_name
         - a_node_id
         - b_node_id
         - condition
         - k_max
         - search_direction

        """
        pass

    def query_shortest_path_limit(self, db_name, a_node_id, b_node_id, condition, k_max, search_direction, limit):
        """
        Parameters:
         - db_name
         - a_node_id
         - b_node_id
         - condition
         - k_max
         - search_direction
         - limit

        """
        pass

    def query_shortest_path_limit_v2(self, db_name, a_node_id, b_node_id, condition, k_max, search_direction, limit):
        """
        Parameters:
         - db_name
         - a_node_id
         - b_node_id
         - condition
         - k_max
         - search_direction
         - limit

        """
        pass

    def query_subgraph_with_node(self, db_name, ids):
        """
        Parameters:
         - db_name
         - ids

        """
        pass

    def query_subgraph_with_node_neighbour(self, db_name, ids, search_direction, k):
        """
        Parameters:
         - db_name
         - ids
         - search_direction
         - k

        """
        pass

    def query_subgraph_with_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_subgraph_with_neighbour_limit(self, db_name, node_id, k_min, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size

        """
        pass

    def query_subgraph_with_type(self, db_name, node_type_list, edge_type_list):
        """
        Parameters:
         - db_name
         - node_type_list
         - edge_type_list

        """
        pass

    def create_subgraph_with_node(self, db_name, ids, new_db_name, readonly):
        """
        Parameters:
         - db_name
         - ids
         - new_db_name
         - readonly

        """
        pass

    def create_subgraph_with_node_neighbour(self, db_name, ids, search_direction, k, new_db_name, readonly):
        """
        Parameters:
         - db_name
         - ids
         - search_direction
         - k
         - new_db_name
         - readonly

        """
        pass

    def create_subgraph_with_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition, new_db_name, readonly):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - new_db_name
         - readonly

        """
        pass

    def create_subgraph_with_type(self, db_name, node_type_list, edge_type_list, new_db_name, readonly):
        """
        Parameters:
         - db_name
         - node_type_list
         - edge_type_list
         - new_db_name
         - readonly

        """
        pass

    def query_common_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_common_neighbour_with_limit(self, db_name, ids, k_min, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size

        """
        pass

    def query_common_neighbour_with_few_relations(self, db_name, ids, k_min, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size

        """
        pass

    def query_common_neighbour_without_relations(self, db_name, ids, k_min, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size

        """
        pass

    def query_union_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_difference_neighbour(self, db_name, A, B, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - A
         - B
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_standard_difference_neighbour(self, db_name, A, B, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - A
         - B
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_total_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_path(self, db_name, src_node_id, dest_node_id, k_min, k_max, search_direction, condition, max_size, query_type):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size
         - query_type

        """
        pass

    def query_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition, return_relations):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - return_relations

        """
        pass

    def query_neighbour_with_limit(self, db_name, node_id, k_min, k_max, search_direction, condition, return_relations, max_size):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - return_relations
         - max_size

        """
        pass

    def check_connectivity(self, db_name, src_node_id, dest_node_id):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id

        """
        pass

    def query_neighbour_for_studio(self, db_name, node_id, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_common_neighbour_for_studio(self, db_name, ids, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_neighbour_path_for_studio(self, db_name, search_direction, condition, nodes):
        """
        Parameters:
         - db_name
         - search_direction
         - condition
         - nodes

        """
        pass

    def query_subgraph_by_neighbour_for_studio(self, db_name, node_id, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition

        """
        pass

    def query_subgraph_by_node_for_studio(self, db_name, ids):
        """
        Parameters:
         - db_name
         - ids

        """
        pass

    def query_path_for_studio(self, db_name, src_node_id, dest_node_id, k_min, k_max, search_direction, condition, max_size, query_type):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size
         - query_type

        """
        pass

    def query_neighbour_with_prop_filter(self, db_name, start_node, edge, end_node, search_direction, k_min, k_max):
        """
        Parameters:
         - db_name
         - start_node
         - edge
         - end_node
         - search_direction
         - k_min
         - k_max

        """
        pass

    def query_path_with_prop_filter(self, db_name, start_node, edge, end_node, search_direction, k_min, k_max, distinct, max_size):
        """
        Parameters:
         - db_name
         - start_node
         - edge
         - end_node
         - search_direction
         - k_min
         - k_max
         - distinct
         - max_size

        """
        pass

    def query_neighbour_with_edge_filter(self, db_name, start_node, edge_type, is_valid_edge, end_node, search_direction):
        """
        Parameters:
         - db_name
         - start_node
         - edge_type
         - is_valid_edge
         - end_node
         - search_direction

        """
        pass

    def count_neighbour_with_prop_filter(self, db_name, start_node, edge, end_node_type, end_node_order_prop_name, search_direction, k_min, k_max):
        """
        Parameters:
         - db_name
         - start_node
         - edge
         - end_node_type
         - end_node_order_prop_name
         - search_direction
         - k_min
         - k_max

        """
        pass

    def query_neighbour_with_multi_edge_filter(self, db_name, start_node, edge_type_list, end_node, search_direction):
        """
        Parameters:
         - db_name
         - start_node
         - edge_type_list
         - end_node
         - search_direction

        """
        pass

    def query_common_relation(self, db_name, node_list, k_max, search_direction, distinct, max_size):
        """
        Parameters:
         - db_name
         - node_list
         - k_max
         - search_direction
         - distinct
         - max_size

        """
        pass

    def count_one_neighbour_relations_top_k(self, db_name, start_node_type, edge_type_set, end_node_type_set, search_direction, output_prop, top_k, is_desc):
        """
        Parameters:
         - db_name
         - start_node_type
         - edge_type_set
         - end_node_type_set
         - search_direction
         - output_prop
         - top_k
         - is_desc

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def query_pagerank(self, db_name, damping_factor, epoch_limit, max_convergence_error, vertex_init_value, edge_type, edge_props_name, bidirection):
        """
        Parameters:
         - db_name
         - damping_factor
         - epoch_limit
         - max_convergence_error
         - vertex_init_value
         - edge_type
         - edge_props_name
         - bidirection

        """
        self.send_query_pagerank(db_name, damping_factor, epoch_limit, max_convergence_error, vertex_init_value, edge_type, edge_props_name, bidirection)
        return self.recv_query_pagerank()

    def send_query_pagerank(self, db_name, damping_factor, epoch_limit, max_convergence_error, vertex_init_value, edge_type, edge_props_name, bidirection):
        self._oprot.writeMessageBegin('query_pagerank', TMessageType.CALL, self._seqid)
        args = query_pagerank_args()
        args.db_name = db_name
        args.damping_factor = damping_factor
        args.epoch_limit = epoch_limit
        args.max_convergence_error = max_convergence_error
        args.vertex_init_value = vertex_init_value
        args.edge_type = edge_type
        args.edge_props_name = edge_props_name
        args.bidirection = bidirection
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_pagerank(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_pagerank_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_pagerank failed: unknown result")

    def query_pagerank_top_k(self, db_name, damping_factor, epoch_limit, max_convergence_error, vertex_init_value, edge_type, edge_props_name, bidirection, top_k):
        """
        Parameters:
         - db_name
         - damping_factor
         - epoch_limit
         - max_convergence_error
         - vertex_init_value
         - edge_type
         - edge_props_name
         - bidirection
         - top_k

        """
        self.send_query_pagerank_top_k(db_name, damping_factor, epoch_limit, max_convergence_error, vertex_init_value, edge_type, edge_props_name, bidirection, top_k)
        return self.recv_query_pagerank_top_k()

    def send_query_pagerank_top_k(self, db_name, damping_factor, epoch_limit, max_convergence_error, vertex_init_value, edge_type, edge_props_name, bidirection, top_k):
        self._oprot.writeMessageBegin('query_pagerank_top_k', TMessageType.CALL, self._seqid)
        args = query_pagerank_top_k_args()
        args.db_name = db_name
        args.damping_factor = damping_factor
        args.epoch_limit = epoch_limit
        args.max_convergence_error = max_convergence_error
        args.vertex_init_value = vertex_init_value
        args.edge_type = edge_type
        args.edge_props_name = edge_props_name
        args.bidirection = bidirection
        args.top_k = top_k
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_pagerank_top_k(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_pagerank_top_k_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_pagerank_top_k failed: unknown result")

    def query_betcentrality(self, db_name, search_direction, hop):
        """
        Parameters:
         - db_name
         - search_direction
         - hop

        """
        self.send_query_betcentrality(db_name, search_direction, hop)
        return self.recv_query_betcentrality()

    def send_query_betcentrality(self, db_name, search_direction, hop):
        self._oprot.writeMessageBegin('query_betcentrality', TMessageType.CALL, self._seqid)
        args = query_betcentrality_args()
        args.db_name = db_name
        args.search_direction = search_direction
        args.hop = hop
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_betcentrality(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_betcentrality_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_betcentrality failed: unknown result")

    def query_clocentrality(self, db_name, if_WF, hop):
        """
        Parameters:
         - db_name
         - if_WF
         - hop

        """
        self.send_query_clocentrality(db_name, if_WF, hop)
        return self.recv_query_clocentrality()

    def send_query_clocentrality(self, db_name, if_WF, hop):
        self._oprot.writeMessageBegin('query_clocentrality', TMessageType.CALL, self._seqid)
        args = query_clocentrality_args()
        args.db_name = db_name
        args.if_WF = if_WF
        args.hop = hop
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_clocentrality(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_clocentrality_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_clocentrality failed: unknown result")

    def query_louvain(self, db_name, edge_type, edge_props_name):
        """
        Parameters:
         - db_name
         - edge_type
         - edge_props_name

        """
        self.send_query_louvain(db_name, edge_type, edge_props_name)
        return self.recv_query_louvain()

    def send_query_louvain(self, db_name, edge_type, edge_props_name):
        self._oprot.writeMessageBegin('query_louvain', TMessageType.CALL, self._seqid)
        args = query_louvain_args()
        args.db_name = db_name
        args.edge_type = edge_type
        args.edge_props_name = edge_props_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_louvain(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_louvain_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_louvain failed: unknown result")

    def query_k_core(self, db_name, k_max):
        """
        Parameters:
         - db_name
         - k_max

        """
        self.send_query_k_core(db_name, k_max)
        return self.recv_query_k_core()

    def send_query_k_core(self, db_name, k_max):
        self._oprot.writeMessageBegin('query_k_core', TMessageType.CALL, self._seqid)
        args = query_k_core_args()
        args.db_name = db_name
        args.k_max = k_max
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_k_core(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_k_core_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_k_core failed: unknown result")

    def query_wcc(self, db_name):
        """
        Parameters:
         - db_name

        """
        self.send_query_wcc(db_name)
        return self.recv_query_wcc()

    def send_query_wcc(self, db_name):
        self._oprot.writeMessageBegin('query_wcc', TMessageType.CALL, self._seqid)
        args = query_wcc_args()
        args.db_name = db_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_wcc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_wcc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_wcc failed: unknown result")

    def query_scc(self, db_name):
        """
        Parameters:
         - db_name

        """
        self.send_query_scc(db_name)
        return self.recv_query_scc()

    def send_query_scc(self, db_name):
        self._oprot.writeMessageBegin('query_scc', TMessageType.CALL, self._seqid)
        args = query_scc_args()
        args.db_name = db_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_scc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_scc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_scc failed: unknown result")

    def query_lpa(self, db_name, epoch_limit):
        """
        Parameters:
         - db_name
         - epoch_limit

        """
        self.send_query_lpa(db_name, epoch_limit)
        return self.recv_query_lpa()

    def send_query_lpa(self, db_name, epoch_limit):
        self._oprot.writeMessageBegin('query_lpa', TMessageType.CALL, self._seqid)
        args = query_lpa_args()
        args.db_name = db_name
        args.epoch_limit = epoch_limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_lpa(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_lpa_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_lpa failed: unknown result")

    def query_lpa_sync(self, db_name, epoch_limit):
        """
        Parameters:
         - db_name
         - epoch_limit

        """
        self.send_query_lpa_sync(db_name, epoch_limit)
        return self.recv_query_lpa_sync()

    def send_query_lpa_sync(self, db_name, epoch_limit):
        self._oprot.writeMessageBegin('query_lpa_sync', TMessageType.CALL, self._seqid)
        args = query_lpa_sync_args()
        args.db_name = db_name
        args.epoch_limit = epoch_limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_lpa_sync(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_lpa_sync_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_lpa_sync failed: unknown result")

    def query_dijkstra(self, db_name, src_node_id, dest_node_id, search_direction, edge_type, edge_props_name):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id
         - search_direction
         - edge_type
         - edge_props_name

        """
        self.send_query_dijkstra(db_name, src_node_id, dest_node_id, search_direction, edge_type, edge_props_name)
        return self.recv_query_dijkstra()

    def send_query_dijkstra(self, db_name, src_node_id, dest_node_id, search_direction, edge_type, edge_props_name):
        self._oprot.writeMessageBegin('query_dijkstra', TMessageType.CALL, self._seqid)
        args = query_dijkstra_args()
        args.db_name = db_name
        args.src_node_id = src_node_id
        args.dest_node_id = dest_node_id
        args.search_direction = search_direction
        args.edge_type = edge_type
        args.edge_props_name = edge_props_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_dijkstra(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_dijkstra_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_dijkstra failed: unknown result")

    def query_random_walk_sub(self, db_name, node_id, length, num_walks, p, q, search_direction):
        """
        Parameters:
         - db_name
         - node_id
         - length
         - num_walks
         - p
         - q
         - search_direction

        """
        self.send_query_random_walk_sub(db_name, node_id, length, num_walks, p, q, search_direction)
        return self.recv_query_random_walk_sub()

    def send_query_random_walk_sub(self, db_name, node_id, length, num_walks, p, q, search_direction):
        self._oprot.writeMessageBegin('query_random_walk_sub', TMessageType.CALL, self._seqid)
        args = query_random_walk_sub_args()
        args.db_name = db_name
        args.node_id = node_id
        args.length = length
        args.num_walks = num_walks
        args.p = p
        args.q = q
        args.search_direction = search_direction
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_random_walk_sub(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_random_walk_sub_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_random_walk_sub failed: unknown result")

    def query_euclidean_distance(self, db_name, A, B):
        """
        Parameters:
         - db_name
         - A
         - B

        """
        self.send_query_euclidean_distance(db_name, A, B)
        return self.recv_query_euclidean_distance()

    def send_query_euclidean_distance(self, db_name, A, B):
        self._oprot.writeMessageBegin('query_euclidean_distance', TMessageType.CALL, self._seqid)
        args = query_euclidean_distance_args()
        args.db_name = db_name
        args.A = A
        args.B = B
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_euclidean_distance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_euclidean_distance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_euclidean_distance failed: unknown result")

    def query_pearson_similarity(self, db_name, A, B):
        """
        Parameters:
         - db_name
         - A
         - B

        """
        self.send_query_pearson_similarity(db_name, A, B)
        return self.recv_query_pearson_similarity()

    def send_query_pearson_similarity(self, db_name, A, B):
        self._oprot.writeMessageBegin('query_pearson_similarity', TMessageType.CALL, self._seqid)
        args = query_pearson_similarity_args()
        args.db_name = db_name
        args.A = A
        args.B = B
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_pearson_similarity(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_pearson_similarity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_pearson_similarity failed: unknown result")

    def query_overlap_similarity(self, db_name, A, B):
        """
        Parameters:
         - db_name
         - A
         - B

        """
        self.send_query_overlap_similarity(db_name, A, B)
        return self.recv_query_overlap_similarity()

    def send_query_overlap_similarity(self, db_name, A, B):
        self._oprot.writeMessageBegin('query_overlap_similarity', TMessageType.CALL, self._seqid)
        args = query_overlap_similarity_args()
        args.db_name = db_name
        args.A = A
        args.B = B
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_overlap_similarity(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_overlap_similarity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_overlap_similarity failed: unknown result")

    def query_jaccard_similarity(self, db_name, A, B):
        """
        Parameters:
         - db_name
         - A
         - B

        """
        self.send_query_jaccard_similarity(db_name, A, B)
        return self.recv_query_jaccard_similarity()

    def send_query_jaccard_similarity(self, db_name, A, B):
        self._oprot.writeMessageBegin('query_jaccard_similarity', TMessageType.CALL, self._seqid)
        args = query_jaccard_similarity_args()
        args.db_name = db_name
        args.A = A
        args.B = B
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_jaccard_similarity(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_jaccard_similarity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_jaccard_similarity failed: unknown result")

    def query_jaccard_similarity_between_two_node(self, db_name, A, B):
        """
        Parameters:
         - db_name
         - A
         - B

        """
        self.send_query_jaccard_similarity_between_two_node(db_name, A, B)
        return self.recv_query_jaccard_similarity_between_two_node()

    def send_query_jaccard_similarity_between_two_node(self, db_name, A, B):
        self._oprot.writeMessageBegin('query_jaccard_similarity_between_two_node', TMessageType.CALL, self._seqid)
        args = query_jaccard_similarity_between_two_node_args()
        args.db_name = db_name
        args.A = A
        args.B = B
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_jaccard_similarity_between_two_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_jaccard_similarity_between_two_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_jaccard_similarity_between_two_node failed: unknown result")

    def query_cosine_similarity_neighborhoods_single_source(self, db_name, node_id, e_type, weight, top_k):
        """
        Parameters:
         - db_name
         - node_id
         - e_type
         - weight
         - top_k

        """
        self.send_query_cosine_similarity_neighborhoods_single_source(db_name, node_id, e_type, weight, top_k)
        return self.recv_query_cosine_similarity_neighborhoods_single_source()

    def send_query_cosine_similarity_neighborhoods_single_source(self, db_name, node_id, e_type, weight, top_k):
        self._oprot.writeMessageBegin('query_cosine_similarity_neighborhoods_single_source', TMessageType.CALL, self._seqid)
        args = query_cosine_similarity_neighborhoods_single_source_args()
        args.db_name = db_name
        args.node_id = node_id
        args.e_type = e_type
        args.weight = weight
        args.top_k = top_k
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_cosine_similarity_neighborhoods_single_source(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_cosine_similarity_neighborhoods_single_source_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_cosine_similarity_neighborhoods_single_source failed: unknown result")

    def query_knn_cosine_single_source(self, db_name, node_id, e_type, weight, top_k):
        """
        Parameters:
         - db_name
         - node_id
         - e_type
         - weight
         - top_k

        """
        self.send_query_knn_cosine_single_source(db_name, node_id, e_type, weight, top_k)
        return self.recv_query_knn_cosine_single_source()

    def send_query_knn_cosine_single_source(self, db_name, node_id, e_type, weight, top_k):
        self._oprot.writeMessageBegin('query_knn_cosine_single_source', TMessageType.CALL, self._seqid)
        args = query_knn_cosine_single_source_args()
        args.db_name = db_name
        args.node_id = node_id
        args.e_type = e_type
        args.weight = weight
        args.top_k = top_k
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_knn_cosine_single_source(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_knn_cosine_single_source_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_knn_cosine_single_source failed: unknown result")

    def query_greedy_graph_coloring(self, db_name, node_type_set, edge_type_set):
        """
        Parameters:
         - db_name
         - node_type_set
         - edge_type_set

        """
        self.send_query_greedy_graph_coloring(db_name, node_type_set, edge_type_set)
        return self.recv_query_greedy_graph_coloring()

    def send_query_greedy_graph_coloring(self, db_name, node_type_set, edge_type_set):
        self._oprot.writeMessageBegin('query_greedy_graph_coloring', TMessageType.CALL, self._seqid)
        args = query_greedy_graph_coloring_args()
        args.db_name = db_name
        args.node_type_set = node_type_set
        args.edge_type_set = edge_type_set
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_greedy_graph_coloring(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_greedy_graph_coloring_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_greedy_graph_coloring failed: unknown result")

    def query_slpa(self, db_name, node_type_set, edge_type_set, threshold, max_iter, output_limit):
        """
        Parameters:
         - db_name
         - node_type_set
         - edge_type_set
         - threshold
         - max_iter
         - output_limit

        """
        self.send_query_slpa(db_name, node_type_set, edge_type_set, threshold, max_iter, output_limit)
        return self.recv_query_slpa()

    def send_query_slpa(self, db_name, node_type_set, edge_type_set, threshold, max_iter, output_limit):
        self._oprot.writeMessageBegin('query_slpa', TMessageType.CALL, self._seqid)
        args = query_slpa_args()
        args.db_name = db_name
        args.node_type_set = node_type_set
        args.edge_type_set = edge_type_set
        args.threshold = threshold
        args.max_iter = max_iter
        args.output_limit = output_limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_slpa(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_slpa_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_slpa failed: unknown result")

    def query_triangle_count(self, db_name, node_type_set, edge_type_set):
        """
        Parameters:
         - db_name
         - node_type_set
         - edge_type_set

        """
        self.send_query_triangle_count(db_name, node_type_set, edge_type_set)
        return self.recv_query_triangle_count()

    def send_query_triangle_count(self, db_name, node_type_set, edge_type_set):
        self._oprot.writeMessageBegin('query_triangle_count', TMessageType.CALL, self._seqid)
        args = query_triangle_count_args()
        args.db_name = db_name
        args.node_type_set = node_type_set
        args.edge_type_set = edge_type_set
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_triangle_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_triangle_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_triangle_count failed: unknown result")

    def query_local_clustering_coefficient(self, db_name, node_type_set, edge_type_set, top_k):
        """
        Parameters:
         - db_name
         - node_type_set
         - edge_type_set
         - top_k

        """
        self.send_query_local_clustering_coefficient(db_name, node_type_set, edge_type_set, top_k)
        return self.recv_query_local_clustering_coefficient()

    def send_query_local_clustering_coefficient(self, db_name, node_type_set, edge_type_set, top_k):
        self._oprot.writeMessageBegin('query_local_clustering_coefficient', TMessageType.CALL, self._seqid)
        args = query_local_clustering_coefficient_args()
        args.db_name = db_name
        args.node_type_set = node_type_set
        args.edge_type_set = edge_type_set
        args.top_k = top_k
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_local_clustering_coefficient(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_local_clustering_coefficient_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_local_clustering_coefficient failed: unknown result")

    def query_single_source_shortest_path_unweighted(self, db_name, node_id, node_type_set, edge_type_set, k_min, k_max, search_direction, max_size):
        """
        Parameters:
         - db_name
         - node_id
         - node_type_set
         - edge_type_set
         - k_min
         - k_max
         - search_direction
         - max_size

        """
        self.send_query_single_source_shortest_path_unweighted(db_name, node_id, node_type_set, edge_type_set, k_min, k_max, search_direction, max_size)
        return self.recv_query_single_source_shortest_path_unweighted()

    def send_query_single_source_shortest_path_unweighted(self, db_name, node_id, node_type_set, edge_type_set, k_min, k_max, search_direction, max_size):
        self._oprot.writeMessageBegin('query_single_source_shortest_path_unweighted', TMessageType.CALL, self._seqid)
        args = query_single_source_shortest_path_unweighted_args()
        args.db_name = db_name
        args.node_id = node_id
        args.node_type_set = node_type_set
        args.edge_type_set = edge_type_set
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.max_size = max_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_single_source_shortest_path_unweighted(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_single_source_shortest_path_unweighted_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_single_source_shortest_path_unweighted failed: unknown result")

    def query_money_flow(self, db_name, start_node, start_time, end_time, money_percent, time_window, edge_type, time_props, money_props, mode):
        """
        Parameters:
         - db_name
         - start_node
         - start_time
         - end_time
         - money_percent
         - time_window
         - edge_type
         - time_props
         - money_props
         - mode

        """
        self.send_query_money_flow(db_name, start_node, start_time, end_time, money_percent, time_window, edge_type, time_props, money_props, mode)
        return self.recv_query_money_flow()

    def send_query_money_flow(self, db_name, start_node, start_time, end_time, money_percent, time_window, edge_type, time_props, money_props, mode):
        self._oprot.writeMessageBegin('query_money_flow', TMessageType.CALL, self._seqid)
        args = query_money_flow_args()
        args.db_name = db_name
        args.start_node = start_node
        args.start_time = start_time
        args.end_time = end_time
        args.money_percent = money_percent
        args.time_window = time_window
        args.edge_type = edge_type
        args.time_props = time_props
        args.money_props = money_props
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_money_flow(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_money_flow_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_money_flow failed: unknown result")

    def query_cluster_for_studio(self, db_name, node_list, edge_list):
        """
        Parameters:
         - db_name
         - node_list
         - edge_list

        """
        self.send_query_cluster_for_studio(db_name, node_list, edge_list)
        return self.recv_query_cluster_for_studio()

    def send_query_cluster_for_studio(self, db_name, node_list, edge_list):
        self._oprot.writeMessageBegin('query_cluster_for_studio', TMessageType.CALL, self._seqid)
        args = query_cluster_for_studio_args()
        args.db_name = db_name
        args.node_list = node_list
        args.edge_list = edge_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_cluster_for_studio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_cluster_for_studio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_cluster_for_studio failed: unknown result")

    def query_prop_cluster(self, db_name, node_list, edge_list, type_prop):
        """
        Parameters:
         - db_name
         - node_list
         - edge_list
         - type_prop

        """
        self.send_query_prop_cluster(db_name, node_list, edge_list, type_prop)
        return self.recv_query_prop_cluster()

    def send_query_prop_cluster(self, db_name, node_list, edge_list, type_prop):
        self._oprot.writeMessageBegin('query_prop_cluster', TMessageType.CALL, self._seqid)
        args = query_prop_cluster_args()
        args.db_name = db_name
        args.node_list = node_list
        args.edge_list = edge_list
        args.type_prop = type_prop
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_prop_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_prop_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_prop_cluster failed: unknown result")

    def query_one_neighbour(self, db_name, node_id, search_direction):
        """
        Parameters:
         - db_name
         - node_id
         - search_direction

        """
        self.send_query_one_neighbour(db_name, node_id, search_direction)
        return self.recv_query_one_neighbour()

    def send_query_one_neighbour(self, db_name, node_id, search_direction):
        self._oprot.writeMessageBegin('query_one_neighbour', TMessageType.CALL, self._seqid)
        args = query_one_neighbour_args()
        args.db_name = db_name
        args.node_id = node_id
        args.search_direction = search_direction
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_one_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_one_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_one_neighbour failed: unknown result")

    def query_simple_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_simple_neighbour(db_name, node_id, k_min, k_max, search_direction, condition)
        return self.recv_query_simple_neighbour()

    def send_query_simple_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_simple_neighbour', TMessageType.CALL, self._seqid)
        args = query_simple_neighbour_args()
        args.db_name = db_name
        args.node_id = node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_simple_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_simple_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_simple_neighbour failed: unknown result")

    def query_simple_neighbour_limit(self, db_name, node_id, k_min, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size

        """
        self.send_query_simple_neighbour_limit(db_name, node_id, k_min, k_max, search_direction, condition, max_size)
        return self.recv_query_simple_neighbour_limit()

    def send_query_simple_neighbour_limit(self, db_name, node_id, k_min, k_max, search_direction, condition, max_size):
        self._oprot.writeMessageBegin('query_simple_neighbour_limit', TMessageType.CALL, self._seqid)
        args = query_simple_neighbour_limit_args()
        args.db_name = db_name
        args.node_id = node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.max_size = max_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_simple_neighbour_limit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_simple_neighbour_limit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_simple_neighbour_limit failed: unknown result")

    def query_common_simple_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_common_simple_neighbour(db_name, ids, k_min, k_max, search_direction, condition)
        return self.recv_query_common_simple_neighbour()

    def send_query_common_simple_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_common_simple_neighbour', TMessageType.CALL, self._seqid)
        args = query_common_simple_neighbour_args()
        args.db_name = db_name
        args.ids = ids
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_common_simple_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_common_simple_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_common_simple_neighbour failed: unknown result")

    def query_neighbour_count(self, db_name, node_id, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_neighbour_count(db_name, node_id, k_min, k_max, search_direction, condition)
        return self.recv_query_neighbour_count()

    def send_query_neighbour_count(self, db_name, node_id, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_neighbour_count', TMessageType.CALL, self._seqid)
        args = query_neighbour_count_args()
        args.db_name = db_name
        args.node_id = node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_neighbour_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_neighbour_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_neighbour_count failed: unknown result")

    def query_simple_path(self, db_name, src_node_id, dest_node_id, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id
         - k_max
         - search_direction
         - condition
         - max_size

        """
        self.send_query_simple_path(db_name, src_node_id, dest_node_id, k_max, search_direction, condition, max_size)
        return self.recv_query_simple_path()

    def send_query_simple_path(self, db_name, src_node_id, dest_node_id, k_max, search_direction, condition, max_size):
        self._oprot.writeMessageBegin('query_simple_path', TMessageType.CALL, self._seqid)
        args = query_simple_path_args()
        args.db_name = db_name
        args.src_node_id = src_node_id
        args.dest_node_id = dest_node_id
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.max_size = max_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_simple_path(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_simple_path_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_simple_path failed: unknown result")

    def query_full_path(self, db_name, src_node_id, dest_node_id, k_max, search_direction, condition, max_size, distinct):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id
         - k_max
         - search_direction
         - condition
         - max_size
         - distinct

        """
        self.send_query_full_path(db_name, src_node_id, dest_node_id, k_max, search_direction, condition, max_size, distinct)
        return self.recv_query_full_path()

    def send_query_full_path(self, db_name, src_node_id, dest_node_id, k_max, search_direction, condition, max_size, distinct):
        self._oprot.writeMessageBegin('query_full_path', TMessageType.CALL, self._seqid)
        args = query_full_path_args()
        args.db_name = db_name
        args.src_node_id = src_node_id
        args.dest_node_id = dest_node_id
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.max_size = max_size
        args.distinct = distinct
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_full_path(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_full_path_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_full_path failed: unknown result")

    def query_full_path_with_set(self, db_name, src_node_id_set, dest_node_id_set, k_max, search_direction, condition, max_size, distinct):
        """
        Parameters:
         - db_name
         - src_node_id_set
         - dest_node_id_set
         - k_max
         - search_direction
         - condition
         - max_size
         - distinct

        """
        self.send_query_full_path_with_set(db_name, src_node_id_set, dest_node_id_set, k_max, search_direction, condition, max_size, distinct)
        return self.recv_query_full_path_with_set()

    def send_query_full_path_with_set(self, db_name, src_node_id_set, dest_node_id_set, k_max, search_direction, condition, max_size, distinct):
        self._oprot.writeMessageBegin('query_full_path_with_set', TMessageType.CALL, self._seqid)
        args = query_full_path_with_set_args()
        args.db_name = db_name
        args.src_node_id_set = src_node_id_set
        args.dest_node_id_set = dest_node_id_set
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.max_size = max_size
        args.distinct = distinct
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_full_path_with_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_full_path_with_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_full_path_with_set failed: unknown result")

    def query_shortest_path(self, db_name, a_node_id, b_node_id, condition, k_max, search_direction):
        """
        Parameters:
         - db_name
         - a_node_id
         - b_node_id
         - condition
         - k_max
         - search_direction

        """
        self.send_query_shortest_path(db_name, a_node_id, b_node_id, condition, k_max, search_direction)
        return self.recv_query_shortest_path()

    def send_query_shortest_path(self, db_name, a_node_id, b_node_id, condition, k_max, search_direction):
        self._oprot.writeMessageBegin('query_shortest_path', TMessageType.CALL, self._seqid)
        args = query_shortest_path_args()
        args.db_name = db_name
        args.a_node_id = a_node_id
        args.b_node_id = b_node_id
        args.condition = condition
        args.k_max = k_max
        args.search_direction = search_direction
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_shortest_path(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_shortest_path_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_shortest_path failed: unknown result")

    def query_shortest_path_limit(self, db_name, a_node_id, b_node_id, condition, k_max, search_direction, limit):
        """
        Parameters:
         - db_name
         - a_node_id
         - b_node_id
         - condition
         - k_max
         - search_direction
         - limit

        """
        self.send_query_shortest_path_limit(db_name, a_node_id, b_node_id, condition, k_max, search_direction, limit)
        return self.recv_query_shortest_path_limit()

    def send_query_shortest_path_limit(self, db_name, a_node_id, b_node_id, condition, k_max, search_direction, limit):
        self._oprot.writeMessageBegin('query_shortest_path_limit', TMessageType.CALL, self._seqid)
        args = query_shortest_path_limit_args()
        args.db_name = db_name
        args.a_node_id = a_node_id
        args.b_node_id = b_node_id
        args.condition = condition
        args.k_max = k_max
        args.search_direction = search_direction
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_shortest_path_limit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_shortest_path_limit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_shortest_path_limit failed: unknown result")

    def query_shortest_path_limit_v2(self, db_name, a_node_id, b_node_id, condition, k_max, search_direction, limit):
        """
        Parameters:
         - db_name
         - a_node_id
         - b_node_id
         - condition
         - k_max
         - search_direction
         - limit

        """
        self.send_query_shortest_path_limit_v2(db_name, a_node_id, b_node_id, condition, k_max, search_direction, limit)
        return self.recv_query_shortest_path_limit_v2()

    def send_query_shortest_path_limit_v2(self, db_name, a_node_id, b_node_id, condition, k_max, search_direction, limit):
        self._oprot.writeMessageBegin('query_shortest_path_limit_v2', TMessageType.CALL, self._seqid)
        args = query_shortest_path_limit_v2_args()
        args.db_name = db_name
        args.a_node_id = a_node_id
        args.b_node_id = b_node_id
        args.condition = condition
        args.k_max = k_max
        args.search_direction = search_direction
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_shortest_path_limit_v2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_shortest_path_limit_v2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_shortest_path_limit_v2 failed: unknown result")

    def query_subgraph_with_node(self, db_name, ids):
        """
        Parameters:
         - db_name
         - ids

        """
        self.send_query_subgraph_with_node(db_name, ids)
        return self.recv_query_subgraph_with_node()

    def send_query_subgraph_with_node(self, db_name, ids):
        self._oprot.writeMessageBegin('query_subgraph_with_node', TMessageType.CALL, self._seqid)
        args = query_subgraph_with_node_args()
        args.db_name = db_name
        args.ids = ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_subgraph_with_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_subgraph_with_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_subgraph_with_node failed: unknown result")

    def query_subgraph_with_node_neighbour(self, db_name, ids, search_direction, k):
        """
        Parameters:
         - db_name
         - ids
         - search_direction
         - k

        """
        self.send_query_subgraph_with_node_neighbour(db_name, ids, search_direction, k)
        return self.recv_query_subgraph_with_node_neighbour()

    def send_query_subgraph_with_node_neighbour(self, db_name, ids, search_direction, k):
        self._oprot.writeMessageBegin('query_subgraph_with_node_neighbour', TMessageType.CALL, self._seqid)
        args = query_subgraph_with_node_neighbour_args()
        args.db_name = db_name
        args.ids = ids
        args.search_direction = search_direction
        args.k = k
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_subgraph_with_node_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_subgraph_with_node_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_subgraph_with_node_neighbour failed: unknown result")

    def query_subgraph_with_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_subgraph_with_neighbour(db_name, node_id, k_min, k_max, search_direction, condition)
        return self.recv_query_subgraph_with_neighbour()

    def send_query_subgraph_with_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_subgraph_with_neighbour', TMessageType.CALL, self._seqid)
        args = query_subgraph_with_neighbour_args()
        args.db_name = db_name
        args.node_id = node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_subgraph_with_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_subgraph_with_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_subgraph_with_neighbour failed: unknown result")

    def query_subgraph_with_neighbour_limit(self, db_name, node_id, k_min, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size

        """
        self.send_query_subgraph_with_neighbour_limit(db_name, node_id, k_min, k_max, search_direction, condition, max_size)
        return self.recv_query_subgraph_with_neighbour_limit()

    def send_query_subgraph_with_neighbour_limit(self, db_name, node_id, k_min, k_max, search_direction, condition, max_size):
        self._oprot.writeMessageBegin('query_subgraph_with_neighbour_limit', TMessageType.CALL, self._seqid)
        args = query_subgraph_with_neighbour_limit_args()
        args.db_name = db_name
        args.node_id = node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.max_size = max_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_subgraph_with_neighbour_limit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_subgraph_with_neighbour_limit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_subgraph_with_neighbour_limit failed: unknown result")

    def query_subgraph_with_type(self, db_name, node_type_list, edge_type_list):
        """
        Parameters:
         - db_name
         - node_type_list
         - edge_type_list

        """
        self.send_query_subgraph_with_type(db_name, node_type_list, edge_type_list)
        return self.recv_query_subgraph_with_type()

    def send_query_subgraph_with_type(self, db_name, node_type_list, edge_type_list):
        self._oprot.writeMessageBegin('query_subgraph_with_type', TMessageType.CALL, self._seqid)
        args = query_subgraph_with_type_args()
        args.db_name = db_name
        args.node_type_list = node_type_list
        args.edge_type_list = edge_type_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_subgraph_with_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_subgraph_with_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_subgraph_with_type failed: unknown result")

    def create_subgraph_with_node(self, db_name, ids, new_db_name, readonly):
        """
        Parameters:
         - db_name
         - ids
         - new_db_name
         - readonly

        """
        self.send_create_subgraph_with_node(db_name, ids, new_db_name, readonly)
        return self.recv_create_subgraph_with_node()

    def send_create_subgraph_with_node(self, db_name, ids, new_db_name, readonly):
        self._oprot.writeMessageBegin('create_subgraph_with_node', TMessageType.CALL, self._seqid)
        args = create_subgraph_with_node_args()
        args.db_name = db_name
        args.ids = ids
        args.new_db_name = new_db_name
        args.readonly = readonly
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_subgraph_with_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_subgraph_with_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_subgraph_with_node failed: unknown result")

    def create_subgraph_with_node_neighbour(self, db_name, ids, search_direction, k, new_db_name, readonly):
        """
        Parameters:
         - db_name
         - ids
         - search_direction
         - k
         - new_db_name
         - readonly

        """
        self.send_create_subgraph_with_node_neighbour(db_name, ids, search_direction, k, new_db_name, readonly)
        return self.recv_create_subgraph_with_node_neighbour()

    def send_create_subgraph_with_node_neighbour(self, db_name, ids, search_direction, k, new_db_name, readonly):
        self._oprot.writeMessageBegin('create_subgraph_with_node_neighbour', TMessageType.CALL, self._seqid)
        args = create_subgraph_with_node_neighbour_args()
        args.db_name = db_name
        args.ids = ids
        args.search_direction = search_direction
        args.k = k
        args.new_db_name = new_db_name
        args.readonly = readonly
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_subgraph_with_node_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_subgraph_with_node_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_subgraph_with_node_neighbour failed: unknown result")

    def create_subgraph_with_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition, new_db_name, readonly):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - new_db_name
         - readonly

        """
        self.send_create_subgraph_with_neighbour(db_name, node_id, k_min, k_max, search_direction, condition, new_db_name, readonly)
        return self.recv_create_subgraph_with_neighbour()

    def send_create_subgraph_with_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition, new_db_name, readonly):
        self._oprot.writeMessageBegin('create_subgraph_with_neighbour', TMessageType.CALL, self._seqid)
        args = create_subgraph_with_neighbour_args()
        args.db_name = db_name
        args.node_id = node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.new_db_name = new_db_name
        args.readonly = readonly
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_subgraph_with_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_subgraph_with_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_subgraph_with_neighbour failed: unknown result")

    def create_subgraph_with_type(self, db_name, node_type_list, edge_type_list, new_db_name, readonly):
        """
        Parameters:
         - db_name
         - node_type_list
         - edge_type_list
         - new_db_name
         - readonly

        """
        self.send_create_subgraph_with_type(db_name, node_type_list, edge_type_list, new_db_name, readonly)
        return self.recv_create_subgraph_with_type()

    def send_create_subgraph_with_type(self, db_name, node_type_list, edge_type_list, new_db_name, readonly):
        self._oprot.writeMessageBegin('create_subgraph_with_type', TMessageType.CALL, self._seqid)
        args = create_subgraph_with_type_args()
        args.db_name = db_name
        args.node_type_list = node_type_list
        args.edge_type_list = edge_type_list
        args.new_db_name = new_db_name
        args.readonly = readonly
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_subgraph_with_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_subgraph_with_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_subgraph_with_type failed: unknown result")

    def query_common_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_common_neighbour(db_name, ids, k_min, k_max, search_direction, condition)
        return self.recv_query_common_neighbour()

    def send_query_common_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_common_neighbour', TMessageType.CALL, self._seqid)
        args = query_common_neighbour_args()
        args.db_name = db_name
        args.ids = ids
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_common_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_common_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_common_neighbour failed: unknown result")

    def query_common_neighbour_with_limit(self, db_name, ids, k_min, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size

        """
        self.send_query_common_neighbour_with_limit(db_name, ids, k_min, k_max, search_direction, condition, max_size)
        return self.recv_query_common_neighbour_with_limit()

    def send_query_common_neighbour_with_limit(self, db_name, ids, k_min, k_max, search_direction, condition, max_size):
        self._oprot.writeMessageBegin('query_common_neighbour_with_limit', TMessageType.CALL, self._seqid)
        args = query_common_neighbour_with_limit_args()
        args.db_name = db_name
        args.ids = ids
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.max_size = max_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_common_neighbour_with_limit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_common_neighbour_with_limit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_common_neighbour_with_limit failed: unknown result")

    def query_common_neighbour_with_few_relations(self, db_name, ids, k_min, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size

        """
        self.send_query_common_neighbour_with_few_relations(db_name, ids, k_min, k_max, search_direction, condition, max_size)
        return self.recv_query_common_neighbour_with_few_relations()

    def send_query_common_neighbour_with_few_relations(self, db_name, ids, k_min, k_max, search_direction, condition, max_size):
        self._oprot.writeMessageBegin('query_common_neighbour_with_few_relations', TMessageType.CALL, self._seqid)
        args = query_common_neighbour_with_few_relations_args()
        args.db_name = db_name
        args.ids = ids
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.max_size = max_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_common_neighbour_with_few_relations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_common_neighbour_with_few_relations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_common_neighbour_with_few_relations failed: unknown result")

    def query_common_neighbour_without_relations(self, db_name, ids, k_min, k_max, search_direction, condition, max_size):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size

        """
        self.send_query_common_neighbour_without_relations(db_name, ids, k_min, k_max, search_direction, condition, max_size)
        return self.recv_query_common_neighbour_without_relations()

    def send_query_common_neighbour_without_relations(self, db_name, ids, k_min, k_max, search_direction, condition, max_size):
        self._oprot.writeMessageBegin('query_common_neighbour_without_relations', TMessageType.CALL, self._seqid)
        args = query_common_neighbour_without_relations_args()
        args.db_name = db_name
        args.ids = ids
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.max_size = max_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_common_neighbour_without_relations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_common_neighbour_without_relations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_common_neighbour_without_relations failed: unknown result")

    def query_union_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_union_neighbour(db_name, ids, k_min, k_max, search_direction, condition)
        return self.recv_query_union_neighbour()

    def send_query_union_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_union_neighbour', TMessageType.CALL, self._seqid)
        args = query_union_neighbour_args()
        args.db_name = db_name
        args.ids = ids
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_union_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_union_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_union_neighbour failed: unknown result")

    def query_difference_neighbour(self, db_name, A, B, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - A
         - B
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_difference_neighbour(db_name, A, B, k_min, k_max, search_direction, condition)
        return self.recv_query_difference_neighbour()

    def send_query_difference_neighbour(self, db_name, A, B, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_difference_neighbour', TMessageType.CALL, self._seqid)
        args = query_difference_neighbour_args()
        args.db_name = db_name
        args.A = A
        args.B = B
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_difference_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_difference_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_difference_neighbour failed: unknown result")

    def query_standard_difference_neighbour(self, db_name, A, B, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - A
         - B
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_standard_difference_neighbour(db_name, A, B, k_min, k_max, search_direction, condition)
        return self.recv_query_standard_difference_neighbour()

    def send_query_standard_difference_neighbour(self, db_name, A, B, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_standard_difference_neighbour', TMessageType.CALL, self._seqid)
        args = query_standard_difference_neighbour_args()
        args.db_name = db_name
        args.A = A
        args.B = B
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_standard_difference_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_standard_difference_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_standard_difference_neighbour failed: unknown result")

    def query_total_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_total_neighbour(db_name, ids, k_min, k_max, search_direction, condition)
        return self.recv_query_total_neighbour()

    def send_query_total_neighbour(self, db_name, ids, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_total_neighbour', TMessageType.CALL, self._seqid)
        args = query_total_neighbour_args()
        args.db_name = db_name
        args.ids = ids
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_total_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_total_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_total_neighbour failed: unknown result")

    def query_path(self, db_name, src_node_id, dest_node_id, k_min, k_max, search_direction, condition, max_size, query_type):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size
         - query_type

        """
        self.send_query_path(db_name, src_node_id, dest_node_id, k_min, k_max, search_direction, condition, max_size, query_type)
        return self.recv_query_path()

    def send_query_path(self, db_name, src_node_id, dest_node_id, k_min, k_max, search_direction, condition, max_size, query_type):
        self._oprot.writeMessageBegin('query_path', TMessageType.CALL, self._seqid)
        args = query_path_args()
        args.db_name = db_name
        args.src_node_id = src_node_id
        args.dest_node_id = dest_node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.max_size = max_size
        args.query_type = query_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_path(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_path_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_path failed: unknown result")

    def query_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition, return_relations):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - return_relations

        """
        self.send_query_neighbour(db_name, node_id, k_min, k_max, search_direction, condition, return_relations)
        return self.recv_query_neighbour()

    def send_query_neighbour(self, db_name, node_id, k_min, k_max, search_direction, condition, return_relations):
        self._oprot.writeMessageBegin('query_neighbour', TMessageType.CALL, self._seqid)
        args = query_neighbour_args()
        args.db_name = db_name
        args.node_id = node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.return_relations = return_relations
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_neighbour(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_neighbour_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_neighbour failed: unknown result")

    def query_neighbour_with_limit(self, db_name, node_id, k_min, k_max, search_direction, condition, return_relations, max_size):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - return_relations
         - max_size

        """
        self.send_query_neighbour_with_limit(db_name, node_id, k_min, k_max, search_direction, condition, return_relations, max_size)
        return self.recv_query_neighbour_with_limit()

    def send_query_neighbour_with_limit(self, db_name, node_id, k_min, k_max, search_direction, condition, return_relations, max_size):
        self._oprot.writeMessageBegin('query_neighbour_with_limit', TMessageType.CALL, self._seqid)
        args = query_neighbour_with_limit_args()
        args.db_name = db_name
        args.node_id = node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.return_relations = return_relations
        args.max_size = max_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_neighbour_with_limit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_neighbour_with_limit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_neighbour_with_limit failed: unknown result")

    def check_connectivity(self, db_name, src_node_id, dest_node_id):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id

        """
        self.send_check_connectivity(db_name, src_node_id, dest_node_id)
        return self.recv_check_connectivity()

    def send_check_connectivity(self, db_name, src_node_id, dest_node_id):
        self._oprot.writeMessageBegin('check_connectivity', TMessageType.CALL, self._seqid)
        args = check_connectivity_args()
        args.db_name = db_name
        args.src_node_id = src_node_id
        args.dest_node_id = dest_node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_connectivity(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_connectivity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_connectivity failed: unknown result")

    def query_neighbour_for_studio(self, db_name, node_id, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_neighbour_for_studio(db_name, node_id, k_min, k_max, search_direction, condition)
        return self.recv_query_neighbour_for_studio()

    def send_query_neighbour_for_studio(self, db_name, node_id, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_neighbour_for_studio', TMessageType.CALL, self._seqid)
        args = query_neighbour_for_studio_args()
        args.db_name = db_name
        args.node_id = node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_neighbour_for_studio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_neighbour_for_studio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_neighbour_for_studio failed: unknown result")

    def query_common_neighbour_for_studio(self, db_name, ids, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - ids
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_common_neighbour_for_studio(db_name, ids, k_min, k_max, search_direction, condition)
        return self.recv_query_common_neighbour_for_studio()

    def send_query_common_neighbour_for_studio(self, db_name, ids, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_common_neighbour_for_studio', TMessageType.CALL, self._seqid)
        args = query_common_neighbour_for_studio_args()
        args.db_name = db_name
        args.ids = ids
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_common_neighbour_for_studio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_common_neighbour_for_studio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_common_neighbour_for_studio failed: unknown result")

    def query_neighbour_path_for_studio(self, db_name, search_direction, condition, nodes):
        """
        Parameters:
         - db_name
         - search_direction
         - condition
         - nodes

        """
        self.send_query_neighbour_path_for_studio(db_name, search_direction, condition, nodes)
        return self.recv_query_neighbour_path_for_studio()

    def send_query_neighbour_path_for_studio(self, db_name, search_direction, condition, nodes):
        self._oprot.writeMessageBegin('query_neighbour_path_for_studio', TMessageType.CALL, self._seqid)
        args = query_neighbour_path_for_studio_args()
        args.db_name = db_name
        args.search_direction = search_direction
        args.condition = condition
        args.nodes = nodes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_neighbour_path_for_studio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_neighbour_path_for_studio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_neighbour_path_for_studio failed: unknown result")

    def query_subgraph_by_neighbour_for_studio(self, db_name, node_id, k_min, k_max, search_direction, condition):
        """
        Parameters:
         - db_name
         - node_id
         - k_min
         - k_max
         - search_direction
         - condition

        """
        self.send_query_subgraph_by_neighbour_for_studio(db_name, node_id, k_min, k_max, search_direction, condition)
        return self.recv_query_subgraph_by_neighbour_for_studio()

    def send_query_subgraph_by_neighbour_for_studio(self, db_name, node_id, k_min, k_max, search_direction, condition):
        self._oprot.writeMessageBegin('query_subgraph_by_neighbour_for_studio', TMessageType.CALL, self._seqid)
        args = query_subgraph_by_neighbour_for_studio_args()
        args.db_name = db_name
        args.node_id = node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_subgraph_by_neighbour_for_studio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_subgraph_by_neighbour_for_studio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_subgraph_by_neighbour_for_studio failed: unknown result")

    def query_subgraph_by_node_for_studio(self, db_name, ids):
        """
        Parameters:
         - db_name
         - ids

        """
        self.send_query_subgraph_by_node_for_studio(db_name, ids)
        return self.recv_query_subgraph_by_node_for_studio()

    def send_query_subgraph_by_node_for_studio(self, db_name, ids):
        self._oprot.writeMessageBegin('query_subgraph_by_node_for_studio', TMessageType.CALL, self._seqid)
        args = query_subgraph_by_node_for_studio_args()
        args.db_name = db_name
        args.ids = ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_subgraph_by_node_for_studio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_subgraph_by_node_for_studio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_subgraph_by_node_for_studio failed: unknown result")

    def query_path_for_studio(self, db_name, src_node_id, dest_node_id, k_min, k_max, search_direction, condition, max_size, query_type):
        """
        Parameters:
         - db_name
         - src_node_id
         - dest_node_id
         - k_min
         - k_max
         - search_direction
         - condition
         - max_size
         - query_type

        """
        self.send_query_path_for_studio(db_name, src_node_id, dest_node_id, k_min, k_max, search_direction, condition, max_size, query_type)
        return self.recv_query_path_for_studio()

    def send_query_path_for_studio(self, db_name, src_node_id, dest_node_id, k_min, k_max, search_direction, condition, max_size, query_type):
        self._oprot.writeMessageBegin('query_path_for_studio', TMessageType.CALL, self._seqid)
        args = query_path_for_studio_args()
        args.db_name = db_name
        args.src_node_id = src_node_id
        args.dest_node_id = dest_node_id
        args.k_min = k_min
        args.k_max = k_max
        args.search_direction = search_direction
        args.condition = condition
        args.max_size = max_size
        args.query_type = query_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_path_for_studio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_path_for_studio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_path_for_studio failed: unknown result")

    def query_neighbour_with_prop_filter(self, db_name, start_node, edge, end_node, search_direction, k_min, k_max):
        """
        Parameters:
         - db_name
         - start_node
         - edge
         - end_node
         - search_direction
         - k_min
         - k_max

        """
        self.send_query_neighbour_with_prop_filter(db_name, start_node, edge, end_node, search_direction, k_min, k_max)
        return self.recv_query_neighbour_with_prop_filter()

    def send_query_neighbour_with_prop_filter(self, db_name, start_node, edge, end_node, search_direction, k_min, k_max):
        self._oprot.writeMessageBegin('query_neighbour_with_prop_filter', TMessageType.CALL, self._seqid)
        args = query_neighbour_with_prop_filter_args()
        args.db_name = db_name
        args.start_node = start_node
        args.edge = edge
        args.end_node = end_node
        args.search_direction = search_direction
        args.k_min = k_min
        args.k_max = k_max
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_neighbour_with_prop_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_neighbour_with_prop_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_neighbour_with_prop_filter failed: unknown result")

    def query_path_with_prop_filter(self, db_name, start_node, edge, end_node, search_direction, k_min, k_max, distinct, max_size):
        """
        Parameters:
         - db_name
         - start_node
         - edge
         - end_node
         - search_direction
         - k_min
         - k_max
         - distinct
         - max_size

        """
        self.send_query_path_with_prop_filter(db_name, start_node, edge, end_node, search_direction, k_min, k_max, distinct, max_size)
        return self.recv_query_path_with_prop_filter()

    def send_query_path_with_prop_filter(self, db_name, start_node, edge, end_node, search_direction, k_min, k_max, distinct, max_size):
        self._oprot.writeMessageBegin('query_path_with_prop_filter', TMessageType.CALL, self._seqid)
        args = query_path_with_prop_filter_args()
        args.db_name = db_name
        args.start_node = start_node
        args.edge = edge
        args.end_node = end_node
        args.search_direction = search_direction
        args.k_min = k_min
        args.k_max = k_max
        args.distinct = distinct
        args.max_size = max_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_path_with_prop_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_path_with_prop_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_path_with_prop_filter failed: unknown result")

    def query_neighbour_with_edge_filter(self, db_name, start_node, edge_type, is_valid_edge, end_node, search_direction):
        """
        Parameters:
         - db_name
         - start_node
         - edge_type
         - is_valid_edge
         - end_node
         - search_direction

        """
        self.send_query_neighbour_with_edge_filter(db_name, start_node, edge_type, is_valid_edge, end_node, search_direction)
        return self.recv_query_neighbour_with_edge_filter()

    def send_query_neighbour_with_edge_filter(self, db_name, start_node, edge_type, is_valid_edge, end_node, search_direction):
        self._oprot.writeMessageBegin('query_neighbour_with_edge_filter', TMessageType.CALL, self._seqid)
        args = query_neighbour_with_edge_filter_args()
        args.db_name = db_name
        args.start_node = start_node
        args.edge_type = edge_type
        args.is_valid_edge = is_valid_edge
        args.end_node = end_node
        args.search_direction = search_direction
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_neighbour_with_edge_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_neighbour_with_edge_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_neighbour_with_edge_filter failed: unknown result")

    def count_neighbour_with_prop_filter(self, db_name, start_node, edge, end_node_type, end_node_order_prop_name, search_direction, k_min, k_max):
        """
        Parameters:
         - db_name
         - start_node
         - edge
         - end_node_type
         - end_node_order_prop_name
         - search_direction
         - k_min
         - k_max

        """
        self.send_count_neighbour_with_prop_filter(db_name, start_node, edge, end_node_type, end_node_order_prop_name, search_direction, k_min, k_max)
        return self.recv_count_neighbour_with_prop_filter()

    def send_count_neighbour_with_prop_filter(self, db_name, start_node, edge, end_node_type, end_node_order_prop_name, search_direction, k_min, k_max):
        self._oprot.writeMessageBegin('count_neighbour_with_prop_filter', TMessageType.CALL, self._seqid)
        args = count_neighbour_with_prop_filter_args()
        args.db_name = db_name
        args.start_node = start_node
        args.edge = edge
        args.end_node_type = end_node_type
        args.end_node_order_prop_name = end_node_order_prop_name
        args.search_direction = search_direction
        args.k_min = k_min
        args.k_max = k_max
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_count_neighbour_with_prop_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = count_neighbour_with_prop_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "count_neighbour_with_prop_filter failed: unknown result")

    def query_neighbour_with_multi_edge_filter(self, db_name, start_node, edge_type_list, end_node, search_direction):
        """
        Parameters:
         - db_name
         - start_node
         - edge_type_list
         - end_node
         - search_direction

        """
        self.send_query_neighbour_with_multi_edge_filter(db_name, start_node, edge_type_list, end_node, search_direction)
        return self.recv_query_neighbour_with_multi_edge_filter()

    def send_query_neighbour_with_multi_edge_filter(self, db_name, start_node, edge_type_list, end_node, search_direction):
        self._oprot.writeMessageBegin('query_neighbour_with_multi_edge_filter', TMessageType.CALL, self._seqid)
        args = query_neighbour_with_multi_edge_filter_args()
        args.db_name = db_name
        args.start_node = start_node
        args.edge_type_list = edge_type_list
        args.end_node = end_node
        args.search_direction = search_direction
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_neighbour_with_multi_edge_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_neighbour_with_multi_edge_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_neighbour_with_multi_edge_filter failed: unknown result")

    def query_common_relation(self, db_name, node_list, k_max, search_direction, distinct, max_size):
        """
        Parameters:
         - db_name
         - node_list
         - k_max
         - search_direction
         - distinct
         - max_size

        """
        self.send_query_common_relation(db_name, node_list, k_max, search_direction, distinct, max_size)
        return self.recv_query_common_relation()

    def send_query_common_relation(self, db_name, node_list, k_max, search_direction, distinct, max_size):
        self._oprot.writeMessageBegin('query_common_relation', TMessageType.CALL, self._seqid)
        args = query_common_relation_args()
        args.db_name = db_name
        args.node_list = node_list
        args.k_max = k_max
        args.search_direction = search_direction
        args.distinct = distinct
        args.max_size = max_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_common_relation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_common_relation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_common_relation failed: unknown result")

    def count_one_neighbour_relations_top_k(self, db_name, start_node_type, edge_type_set, end_node_type_set, search_direction, output_prop, top_k, is_desc):
        """
        Parameters:
         - db_name
         - start_node_type
         - edge_type_set
         - end_node_type_set
         - search_direction
         - output_prop
         - top_k
         - is_desc

        """
        self.send_count_one_neighbour_relations_top_k(db_name, start_node_type, edge_type_set, end_node_type_set, search_direction, output_prop, top_k, is_desc)
        return self.recv_count_one_neighbour_relations_top_k()

    def send_count_one_neighbour_relations_top_k(self, db_name, start_node_type, edge_type_set, end_node_type_set, search_direction, output_prop, top_k, is_desc):
        self._oprot.writeMessageBegin('count_one_neighbour_relations_top_k', TMessageType.CALL, self._seqid)
        args = count_one_neighbour_relations_top_k_args()
        args.db_name = db_name
        args.start_node_type = start_node_type
        args.edge_type_set = edge_type_set
        args.end_node_type_set = end_node_type_set
        args.search_direction = search_direction
        args.output_prop = output_prop
        args.top_k = top_k
        args.is_desc = is_desc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_count_one_neighbour_relations_top_k(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = count_one_neighbour_relations_top_k_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "count_one_neighbour_relations_top_k failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["query_pagerank"] = Processor.process_query_pagerank
        self._processMap["query_pagerank_top_k"] = Processor.process_query_pagerank_top_k
        self._processMap["query_betcentrality"] = Processor.process_query_betcentrality
        self._processMap["query_clocentrality"] = Processor.process_query_clocentrality
        self._processMap["query_louvain"] = Processor.process_query_louvain
        self._processMap["query_k_core"] = Processor.process_query_k_core
        self._processMap["query_wcc"] = Processor.process_query_wcc
        self._processMap["query_scc"] = Processor.process_query_scc
        self._processMap["query_lpa"] = Processor.process_query_lpa
        self._processMap["query_lpa_sync"] = Processor.process_query_lpa_sync
        self._processMap["query_dijkstra"] = Processor.process_query_dijkstra
        self._processMap["query_random_walk_sub"] = Processor.process_query_random_walk_sub
        self._processMap["query_euclidean_distance"] = Processor.process_query_euclidean_distance
        self._processMap["query_pearson_similarity"] = Processor.process_query_pearson_similarity
        self._processMap["query_overlap_similarity"] = Processor.process_query_overlap_similarity
        self._processMap["query_jaccard_similarity"] = Processor.process_query_jaccard_similarity
        self._processMap["query_jaccard_similarity_between_two_node"] = Processor.process_query_jaccard_similarity_between_two_node
        self._processMap["query_cosine_similarity_neighborhoods_single_source"] = Processor.process_query_cosine_similarity_neighborhoods_single_source
        self._processMap["query_knn_cosine_single_source"] = Processor.process_query_knn_cosine_single_source
        self._processMap["query_greedy_graph_coloring"] = Processor.process_query_greedy_graph_coloring
        self._processMap["query_slpa"] = Processor.process_query_slpa
        self._processMap["query_triangle_count"] = Processor.process_query_triangle_count
        self._processMap["query_local_clustering_coefficient"] = Processor.process_query_local_clustering_coefficient
        self._processMap["query_single_source_shortest_path_unweighted"] = Processor.process_query_single_source_shortest_path_unweighted
        self._processMap["query_money_flow"] = Processor.process_query_money_flow
        self._processMap["query_cluster_for_studio"] = Processor.process_query_cluster_for_studio
        self._processMap["query_prop_cluster"] = Processor.process_query_prop_cluster
        self._processMap["query_one_neighbour"] = Processor.process_query_one_neighbour
        self._processMap["query_simple_neighbour"] = Processor.process_query_simple_neighbour
        self._processMap["query_simple_neighbour_limit"] = Processor.process_query_simple_neighbour_limit
        self._processMap["query_common_simple_neighbour"] = Processor.process_query_common_simple_neighbour
        self._processMap["query_neighbour_count"] = Processor.process_query_neighbour_count
        self._processMap["query_simple_path"] = Processor.process_query_simple_path
        self._processMap["query_full_path"] = Processor.process_query_full_path
        self._processMap["query_full_path_with_set"] = Processor.process_query_full_path_with_set
        self._processMap["query_shortest_path"] = Processor.process_query_shortest_path
        self._processMap["query_shortest_path_limit"] = Processor.process_query_shortest_path_limit
        self._processMap["query_shortest_path_limit_v2"] = Processor.process_query_shortest_path_limit_v2
        self._processMap["query_subgraph_with_node"] = Processor.process_query_subgraph_with_node
        self._processMap["query_subgraph_with_node_neighbour"] = Processor.process_query_subgraph_with_node_neighbour
        self._processMap["query_subgraph_with_neighbour"] = Processor.process_query_subgraph_with_neighbour
        self._processMap["query_subgraph_with_neighbour_limit"] = Processor.process_query_subgraph_with_neighbour_limit
        self._processMap["query_subgraph_with_type"] = Processor.process_query_subgraph_with_type
        self._processMap["create_subgraph_with_node"] = Processor.process_create_subgraph_with_node
        self._processMap["create_subgraph_with_node_neighbour"] = Processor.process_create_subgraph_with_node_neighbour
        self._processMap["create_subgraph_with_neighbour"] = Processor.process_create_subgraph_with_neighbour
        self._processMap["create_subgraph_with_type"] = Processor.process_create_subgraph_with_type
        self._processMap["query_common_neighbour"] = Processor.process_query_common_neighbour
        self._processMap["query_common_neighbour_with_limit"] = Processor.process_query_common_neighbour_with_limit
        self._processMap["query_common_neighbour_with_few_relations"] = Processor.process_query_common_neighbour_with_few_relations
        self._processMap["query_common_neighbour_without_relations"] = Processor.process_query_common_neighbour_without_relations
        self._processMap["query_union_neighbour"] = Processor.process_query_union_neighbour
        self._processMap["query_difference_neighbour"] = Processor.process_query_difference_neighbour
        self._processMap["query_standard_difference_neighbour"] = Processor.process_query_standard_difference_neighbour
        self._processMap["query_total_neighbour"] = Processor.process_query_total_neighbour
        self._processMap["query_path"] = Processor.process_query_path
        self._processMap["query_neighbour"] = Processor.process_query_neighbour
        self._processMap["query_neighbour_with_limit"] = Processor.process_query_neighbour_with_limit
        self._processMap["check_connectivity"] = Processor.process_check_connectivity
        self._processMap["query_neighbour_for_studio"] = Processor.process_query_neighbour_for_studio
        self._processMap["query_common_neighbour_for_studio"] = Processor.process_query_common_neighbour_for_studio
        self._processMap["query_neighbour_path_for_studio"] = Processor.process_query_neighbour_path_for_studio
        self._processMap["query_subgraph_by_neighbour_for_studio"] = Processor.process_query_subgraph_by_neighbour_for_studio
        self._processMap["query_subgraph_by_node_for_studio"] = Processor.process_query_subgraph_by_node_for_studio
        self._processMap["query_path_for_studio"] = Processor.process_query_path_for_studio
        self._processMap["query_neighbour_with_prop_filter"] = Processor.process_query_neighbour_with_prop_filter
        self._processMap["query_path_with_prop_filter"] = Processor.process_query_path_with_prop_filter
        self._processMap["query_neighbour_with_edge_filter"] = Processor.process_query_neighbour_with_edge_filter
        self._processMap["count_neighbour_with_prop_filter"] = Processor.process_count_neighbour_with_prop_filter
        self._processMap["query_neighbour_with_multi_edge_filter"] = Processor.process_query_neighbour_with_multi_edge_filter
        self._processMap["query_common_relation"] = Processor.process_query_common_relation
        self._processMap["count_one_neighbour_relations_top_k"] = Processor.process_count_one_neighbour_relations_top_k
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_query_pagerank(self, seqid, iprot, oprot):
        args = query_pagerank_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_pagerank_result()
        try:
            result.success = self._handler.query_pagerank(args.db_name, args.damping_factor, args.epoch_limit, args.max_convergence_error, args.vertex_init_value, args.edge_type, args.edge_props_name, args.bidirection)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_pagerank", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_pagerank_top_k(self, seqid, iprot, oprot):
        args = query_pagerank_top_k_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_pagerank_top_k_result()
        try:
            result.success = self._handler.query_pagerank_top_k(args.db_name, args.damping_factor, args.epoch_limit, args.max_convergence_error, args.vertex_init_value, args.edge_type, args.edge_props_name, args.bidirection, args.top_k)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_pagerank_top_k", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_betcentrality(self, seqid, iprot, oprot):
        args = query_betcentrality_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_betcentrality_result()
        try:
            result.success = self._handler.query_betcentrality(args.db_name, args.search_direction, args.hop)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_betcentrality", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_clocentrality(self, seqid, iprot, oprot):
        args = query_clocentrality_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_clocentrality_result()
        try:
            result.success = self._handler.query_clocentrality(args.db_name, args.if_WF, args.hop)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_clocentrality", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_louvain(self, seqid, iprot, oprot):
        args = query_louvain_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_louvain_result()
        try:
            result.success = self._handler.query_louvain(args.db_name, args.edge_type, args.edge_props_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_louvain", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_k_core(self, seqid, iprot, oprot):
        args = query_k_core_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_k_core_result()
        try:
            result.success = self._handler.query_k_core(args.db_name, args.k_max)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_k_core", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_wcc(self, seqid, iprot, oprot):
        args = query_wcc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_wcc_result()
        try:
            result.success = self._handler.query_wcc(args.db_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_wcc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_scc(self, seqid, iprot, oprot):
        args = query_scc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_scc_result()
        try:
            result.success = self._handler.query_scc(args.db_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_scc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_lpa(self, seqid, iprot, oprot):
        args = query_lpa_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_lpa_result()
        try:
            result.success = self._handler.query_lpa(args.db_name, args.epoch_limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_lpa", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_lpa_sync(self, seqid, iprot, oprot):
        args = query_lpa_sync_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_lpa_sync_result()
        try:
            result.success = self._handler.query_lpa_sync(args.db_name, args.epoch_limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_lpa_sync", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_dijkstra(self, seqid, iprot, oprot):
        args = query_dijkstra_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_dijkstra_result()
        try:
            result.success = self._handler.query_dijkstra(args.db_name, args.src_node_id, args.dest_node_id, args.search_direction, args.edge_type, args.edge_props_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_dijkstra", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_random_walk_sub(self, seqid, iprot, oprot):
        args = query_random_walk_sub_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_random_walk_sub_result()
        try:
            result.success = self._handler.query_random_walk_sub(args.db_name, args.node_id, args.length, args.num_walks, args.p, args.q, args.search_direction)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_random_walk_sub", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_euclidean_distance(self, seqid, iprot, oprot):
        args = query_euclidean_distance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_euclidean_distance_result()
        try:
            result.success = self._handler.query_euclidean_distance(args.db_name, args.A, args.B)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_euclidean_distance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_pearson_similarity(self, seqid, iprot, oprot):
        args = query_pearson_similarity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_pearson_similarity_result()
        try:
            result.success = self._handler.query_pearson_similarity(args.db_name, args.A, args.B)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_pearson_similarity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_overlap_similarity(self, seqid, iprot, oprot):
        args = query_overlap_similarity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_overlap_similarity_result()
        try:
            result.success = self._handler.query_overlap_similarity(args.db_name, args.A, args.B)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_overlap_similarity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_jaccard_similarity(self, seqid, iprot, oprot):
        args = query_jaccard_similarity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_jaccard_similarity_result()
        try:
            result.success = self._handler.query_jaccard_similarity(args.db_name, args.A, args.B)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_jaccard_similarity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_jaccard_similarity_between_two_node(self, seqid, iprot, oprot):
        args = query_jaccard_similarity_between_two_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_jaccard_similarity_between_two_node_result()
        try:
            result.success = self._handler.query_jaccard_similarity_between_two_node(args.db_name, args.A, args.B)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_jaccard_similarity_between_two_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_cosine_similarity_neighborhoods_single_source(self, seqid, iprot, oprot):
        args = query_cosine_similarity_neighborhoods_single_source_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_cosine_similarity_neighborhoods_single_source_result()
        try:
            result.success = self._handler.query_cosine_similarity_neighborhoods_single_source(args.db_name, args.node_id, args.e_type, args.weight, args.top_k)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_cosine_similarity_neighborhoods_single_source", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_knn_cosine_single_source(self, seqid, iprot, oprot):
        args = query_knn_cosine_single_source_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_knn_cosine_single_source_result()
        try:
            result.success = self._handler.query_knn_cosine_single_source(args.db_name, args.node_id, args.e_type, args.weight, args.top_k)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_knn_cosine_single_source", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_greedy_graph_coloring(self, seqid, iprot, oprot):
        args = query_greedy_graph_coloring_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_greedy_graph_coloring_result()
        try:
            result.success = self._handler.query_greedy_graph_coloring(args.db_name, args.node_type_set, args.edge_type_set)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_greedy_graph_coloring", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_slpa(self, seqid, iprot, oprot):
        args = query_slpa_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_slpa_result()
        try:
            result.success = self._handler.query_slpa(args.db_name, args.node_type_set, args.edge_type_set, args.threshold, args.max_iter, args.output_limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_slpa", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_triangle_count(self, seqid, iprot, oprot):
        args = query_triangle_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_triangle_count_result()
        try:
            result.success = self._handler.query_triangle_count(args.db_name, args.node_type_set, args.edge_type_set)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_triangle_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_local_clustering_coefficient(self, seqid, iprot, oprot):
        args = query_local_clustering_coefficient_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_local_clustering_coefficient_result()
        try:
            result.success = self._handler.query_local_clustering_coefficient(args.db_name, args.node_type_set, args.edge_type_set, args.top_k)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_local_clustering_coefficient", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_single_source_shortest_path_unweighted(self, seqid, iprot, oprot):
        args = query_single_source_shortest_path_unweighted_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_single_source_shortest_path_unweighted_result()
        try:
            result.success = self._handler.query_single_source_shortest_path_unweighted(args.db_name, args.node_id, args.node_type_set, args.edge_type_set, args.k_min, args.k_max, args.search_direction, args.max_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_single_source_shortest_path_unweighted", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_money_flow(self, seqid, iprot, oprot):
        args = query_money_flow_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_money_flow_result()
        try:
            result.success = self._handler.query_money_flow(args.db_name, args.start_node, args.start_time, args.end_time, args.money_percent, args.time_window, args.edge_type, args.time_props, args.money_props, args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_money_flow", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_cluster_for_studio(self, seqid, iprot, oprot):
        args = query_cluster_for_studio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_cluster_for_studio_result()
        try:
            result.success = self._handler.query_cluster_for_studio(args.db_name, args.node_list, args.edge_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_cluster_for_studio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_prop_cluster(self, seqid, iprot, oprot):
        args = query_prop_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_prop_cluster_result()
        try:
            result.success = self._handler.query_prop_cluster(args.db_name, args.node_list, args.edge_list, args.type_prop)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_prop_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_one_neighbour(self, seqid, iprot, oprot):
        args = query_one_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_one_neighbour_result()
        try:
            result.success = self._handler.query_one_neighbour(args.db_name, args.node_id, args.search_direction)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_one_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_simple_neighbour(self, seqid, iprot, oprot):
        args = query_simple_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_simple_neighbour_result()
        try:
            result.success = self._handler.query_simple_neighbour(args.db_name, args.node_id, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_simple_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_simple_neighbour_limit(self, seqid, iprot, oprot):
        args = query_simple_neighbour_limit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_simple_neighbour_limit_result()
        try:
            result.success = self._handler.query_simple_neighbour_limit(args.db_name, args.node_id, args.k_min, args.k_max, args.search_direction, args.condition, args.max_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_simple_neighbour_limit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_common_simple_neighbour(self, seqid, iprot, oprot):
        args = query_common_simple_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_common_simple_neighbour_result()
        try:
            result.success = self._handler.query_common_simple_neighbour(args.db_name, args.ids, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_common_simple_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_neighbour_count(self, seqid, iprot, oprot):
        args = query_neighbour_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_neighbour_count_result()
        try:
            result.success = self._handler.query_neighbour_count(args.db_name, args.node_id, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_neighbour_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_simple_path(self, seqid, iprot, oprot):
        args = query_simple_path_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_simple_path_result()
        try:
            result.success = self._handler.query_simple_path(args.db_name, args.src_node_id, args.dest_node_id, args.k_max, args.search_direction, args.condition, args.max_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_simple_path", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_full_path(self, seqid, iprot, oprot):
        args = query_full_path_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_full_path_result()
        try:
            result.success = self._handler.query_full_path(args.db_name, args.src_node_id, args.dest_node_id, args.k_max, args.search_direction, args.condition, args.max_size, args.distinct)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_full_path", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_full_path_with_set(self, seqid, iprot, oprot):
        args = query_full_path_with_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_full_path_with_set_result()
        try:
            result.success = self._handler.query_full_path_with_set(args.db_name, args.src_node_id_set, args.dest_node_id_set, args.k_max, args.search_direction, args.condition, args.max_size, args.distinct)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_full_path_with_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_shortest_path(self, seqid, iprot, oprot):
        args = query_shortest_path_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_shortest_path_result()
        try:
            result.success = self._handler.query_shortest_path(args.db_name, args.a_node_id, args.b_node_id, args.condition, args.k_max, args.search_direction)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_shortest_path", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_shortest_path_limit(self, seqid, iprot, oprot):
        args = query_shortest_path_limit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_shortest_path_limit_result()
        try:
            result.success = self._handler.query_shortest_path_limit(args.db_name, args.a_node_id, args.b_node_id, args.condition, args.k_max, args.search_direction, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_shortest_path_limit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_shortest_path_limit_v2(self, seqid, iprot, oprot):
        args = query_shortest_path_limit_v2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_shortest_path_limit_v2_result()
        try:
            result.success = self._handler.query_shortest_path_limit_v2(args.db_name, args.a_node_id, args.b_node_id, args.condition, args.k_max, args.search_direction, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_shortest_path_limit_v2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_subgraph_with_node(self, seqid, iprot, oprot):
        args = query_subgraph_with_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_subgraph_with_node_result()
        try:
            result.success = self._handler.query_subgraph_with_node(args.db_name, args.ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_subgraph_with_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_subgraph_with_node_neighbour(self, seqid, iprot, oprot):
        args = query_subgraph_with_node_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_subgraph_with_node_neighbour_result()
        try:
            result.success = self._handler.query_subgraph_with_node_neighbour(args.db_name, args.ids, args.search_direction, args.k)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_subgraph_with_node_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_subgraph_with_neighbour(self, seqid, iprot, oprot):
        args = query_subgraph_with_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_subgraph_with_neighbour_result()
        try:
            result.success = self._handler.query_subgraph_with_neighbour(args.db_name, args.node_id, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_subgraph_with_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_subgraph_with_neighbour_limit(self, seqid, iprot, oprot):
        args = query_subgraph_with_neighbour_limit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_subgraph_with_neighbour_limit_result()
        try:
            result.success = self._handler.query_subgraph_with_neighbour_limit(args.db_name, args.node_id, args.k_min, args.k_max, args.search_direction, args.condition, args.max_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_subgraph_with_neighbour_limit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_subgraph_with_type(self, seqid, iprot, oprot):
        args = query_subgraph_with_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_subgraph_with_type_result()
        try:
            result.success = self._handler.query_subgraph_with_type(args.db_name, args.node_type_list, args.edge_type_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_subgraph_with_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_subgraph_with_node(self, seqid, iprot, oprot):
        args = create_subgraph_with_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_subgraph_with_node_result()
        try:
            result.success = self._handler.create_subgraph_with_node(args.db_name, args.ids, args.new_db_name, args.readonly)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_subgraph_with_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_subgraph_with_node_neighbour(self, seqid, iprot, oprot):
        args = create_subgraph_with_node_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_subgraph_with_node_neighbour_result()
        try:
            result.success = self._handler.create_subgraph_with_node_neighbour(args.db_name, args.ids, args.search_direction, args.k, args.new_db_name, args.readonly)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_subgraph_with_node_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_subgraph_with_neighbour(self, seqid, iprot, oprot):
        args = create_subgraph_with_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_subgraph_with_neighbour_result()
        try:
            result.success = self._handler.create_subgraph_with_neighbour(args.db_name, args.node_id, args.k_min, args.k_max, args.search_direction, args.condition, args.new_db_name, args.readonly)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_subgraph_with_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_subgraph_with_type(self, seqid, iprot, oprot):
        args = create_subgraph_with_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_subgraph_with_type_result()
        try:
            result.success = self._handler.create_subgraph_with_type(args.db_name, args.node_type_list, args.edge_type_list, args.new_db_name, args.readonly)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_subgraph_with_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_common_neighbour(self, seqid, iprot, oprot):
        args = query_common_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_common_neighbour_result()
        try:
            result.success = self._handler.query_common_neighbour(args.db_name, args.ids, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_common_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_common_neighbour_with_limit(self, seqid, iprot, oprot):
        args = query_common_neighbour_with_limit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_common_neighbour_with_limit_result()
        try:
            result.success = self._handler.query_common_neighbour_with_limit(args.db_name, args.ids, args.k_min, args.k_max, args.search_direction, args.condition, args.max_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_common_neighbour_with_limit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_common_neighbour_with_few_relations(self, seqid, iprot, oprot):
        args = query_common_neighbour_with_few_relations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_common_neighbour_with_few_relations_result()
        try:
            result.success = self._handler.query_common_neighbour_with_few_relations(args.db_name, args.ids, args.k_min, args.k_max, args.search_direction, args.condition, args.max_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_common_neighbour_with_few_relations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_common_neighbour_without_relations(self, seqid, iprot, oprot):
        args = query_common_neighbour_without_relations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_common_neighbour_without_relations_result()
        try:
            result.success = self._handler.query_common_neighbour_without_relations(args.db_name, args.ids, args.k_min, args.k_max, args.search_direction, args.condition, args.max_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_common_neighbour_without_relations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_union_neighbour(self, seqid, iprot, oprot):
        args = query_union_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_union_neighbour_result()
        try:
            result.success = self._handler.query_union_neighbour(args.db_name, args.ids, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_union_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_difference_neighbour(self, seqid, iprot, oprot):
        args = query_difference_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_difference_neighbour_result()
        try:
            result.success = self._handler.query_difference_neighbour(args.db_name, args.A, args.B, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_difference_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_standard_difference_neighbour(self, seqid, iprot, oprot):
        args = query_standard_difference_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_standard_difference_neighbour_result()
        try:
            result.success = self._handler.query_standard_difference_neighbour(args.db_name, args.A, args.B, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_standard_difference_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_total_neighbour(self, seqid, iprot, oprot):
        args = query_total_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_total_neighbour_result()
        try:
            result.success = self._handler.query_total_neighbour(args.db_name, args.ids, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_total_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_path(self, seqid, iprot, oprot):
        args = query_path_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_path_result()
        try:
            result.success = self._handler.query_path(args.db_name, args.src_node_id, args.dest_node_id, args.k_min, args.k_max, args.search_direction, args.condition, args.max_size, args.query_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_path", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_neighbour(self, seqid, iprot, oprot):
        args = query_neighbour_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_neighbour_result()
        try:
            result.success = self._handler.query_neighbour(args.db_name, args.node_id, args.k_min, args.k_max, args.search_direction, args.condition, args.return_relations)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_neighbour", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_neighbour_with_limit(self, seqid, iprot, oprot):
        args = query_neighbour_with_limit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_neighbour_with_limit_result()
        try:
            result.success = self._handler.query_neighbour_with_limit(args.db_name, args.node_id, args.k_min, args.k_max, args.search_direction, args.condition, args.return_relations, args.max_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_neighbour_with_limit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_connectivity(self, seqid, iprot, oprot):
        args = check_connectivity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_connectivity_result()
        try:
            result.success = self._handler.check_connectivity(args.db_name, args.src_node_id, args.dest_node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_connectivity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_neighbour_for_studio(self, seqid, iprot, oprot):
        args = query_neighbour_for_studio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_neighbour_for_studio_result()
        try:
            result.success = self._handler.query_neighbour_for_studio(args.db_name, args.node_id, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_neighbour_for_studio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_common_neighbour_for_studio(self, seqid, iprot, oprot):
        args = query_common_neighbour_for_studio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_common_neighbour_for_studio_result()
        try:
            result.success = self._handler.query_common_neighbour_for_studio(args.db_name, args.ids, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_common_neighbour_for_studio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_neighbour_path_for_studio(self, seqid, iprot, oprot):
        args = query_neighbour_path_for_studio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_neighbour_path_for_studio_result()
        try:
            result.success = self._handler.query_neighbour_path_for_studio(args.db_name, args.search_direction, args.condition, args.nodes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_neighbour_path_for_studio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_subgraph_by_neighbour_for_studio(self, seqid, iprot, oprot):
        args = query_subgraph_by_neighbour_for_studio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_subgraph_by_neighbour_for_studio_result()
        try:
            result.success = self._handler.query_subgraph_by_neighbour_for_studio(args.db_name, args.node_id, args.k_min, args.k_max, args.search_direction, args.condition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_subgraph_by_neighbour_for_studio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_subgraph_by_node_for_studio(self, seqid, iprot, oprot):
        args = query_subgraph_by_node_for_studio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_subgraph_by_node_for_studio_result()
        try:
            result.success = self._handler.query_subgraph_by_node_for_studio(args.db_name, args.ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_subgraph_by_node_for_studio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_path_for_studio(self, seqid, iprot, oprot):
        args = query_path_for_studio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_path_for_studio_result()
        try:
            result.success = self._handler.query_path_for_studio(args.db_name, args.src_node_id, args.dest_node_id, args.k_min, args.k_max, args.search_direction, args.condition, args.max_size, args.query_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_path_for_studio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_neighbour_with_prop_filter(self, seqid, iprot, oprot):
        args = query_neighbour_with_prop_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_neighbour_with_prop_filter_result()
        try:
            result.success = self._handler.query_neighbour_with_prop_filter(args.db_name, args.start_node, args.edge, args.end_node, args.search_direction, args.k_min, args.k_max)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_neighbour_with_prop_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_path_with_prop_filter(self, seqid, iprot, oprot):
        args = query_path_with_prop_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_path_with_prop_filter_result()
        try:
            result.success = self._handler.query_path_with_prop_filter(args.db_name, args.start_node, args.edge, args.end_node, args.search_direction, args.k_min, args.k_max, args.distinct, args.max_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_path_with_prop_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_neighbour_with_edge_filter(self, seqid, iprot, oprot):
        args = query_neighbour_with_edge_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_neighbour_with_edge_filter_result()
        try:
            result.success = self._handler.query_neighbour_with_edge_filter(args.db_name, args.start_node, args.edge_type, args.is_valid_edge, args.end_node, args.search_direction)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_neighbour_with_edge_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_count_neighbour_with_prop_filter(self, seqid, iprot, oprot):
        args = count_neighbour_with_prop_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = count_neighbour_with_prop_filter_result()
        try:
            result.success = self._handler.count_neighbour_with_prop_filter(args.db_name, args.start_node, args.edge, args.end_node_type, args.end_node_order_prop_name, args.search_direction, args.k_min, args.k_max)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("count_neighbour_with_prop_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_neighbour_with_multi_edge_filter(self, seqid, iprot, oprot):
        args = query_neighbour_with_multi_edge_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_neighbour_with_multi_edge_filter_result()
        try:
            result.success = self._handler.query_neighbour_with_multi_edge_filter(args.db_name, args.start_node, args.edge_type_list, args.end_node, args.search_direction)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_neighbour_with_multi_edge_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_common_relation(self, seqid, iprot, oprot):
        args = query_common_relation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_common_relation_result()
        try:
            result.success = self._handler.query_common_relation(args.db_name, args.node_list, args.k_max, args.search_direction, args.distinct, args.max_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_common_relation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_count_one_neighbour_relations_top_k(self, seqid, iprot, oprot):
        args = count_one_neighbour_relations_top_k_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = count_one_neighbour_relations_top_k_result()
        try:
            result.success = self._handler.count_one_neighbour_relations_top_k(args.db_name, args.start_node_type, args.edge_type_set, args.end_node_type_set, args.search_direction, args.output_prop, args.top_k, args.is_desc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ezoocommon.ttypes.ezoo_exception as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("count_one_neighbour_relations_top_k", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class query_pagerank_args(object):
    """
    Attributes:
     - db_name
     - damping_factor
     - epoch_limit
     - max_convergence_error
     - vertex_init_value
     - edge_type
     - edge_props_name
     - bidirection

    """


    def __init__(self, db_name=None, damping_factor=0.8000000000000000, epoch_limit=100, max_convergence_error=0.0010000000000000, vertex_init_value=float(1), edge_type=None, edge_props_name=None, bidirection=False,):
        self.db_name = db_name
        self.damping_factor = damping_factor
        self.epoch_limit = epoch_limit
        self.max_convergence_error = max_convergence_error
        self.vertex_init_value = vertex_init_value
        self.edge_type = edge_type
        self.edge_props_name = edge_props_name
        self.bidirection = bidirection

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.damping_factor = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.epoch_limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.max_convergence_error = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.vertex_init_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.edge_type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.edge_props_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.bidirection = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_pagerank_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.damping_factor is not None:
            oprot.writeFieldBegin('damping_factor', TType.DOUBLE, 2)
            oprot.writeDouble(self.damping_factor)
            oprot.writeFieldEnd()
        if self.epoch_limit is not None:
            oprot.writeFieldBegin('epoch_limit', TType.I32, 3)
            oprot.writeI32(self.epoch_limit)
            oprot.writeFieldEnd()
        if self.max_convergence_error is not None:
            oprot.writeFieldBegin('max_convergence_error', TType.DOUBLE, 4)
            oprot.writeDouble(self.max_convergence_error)
            oprot.writeFieldEnd()
        if self.vertex_init_value is not None:
            oprot.writeFieldBegin('vertex_init_value', TType.DOUBLE, 5)
            oprot.writeDouble(self.vertex_init_value)
            oprot.writeFieldEnd()
        if self.edge_type is not None:
            oprot.writeFieldBegin('edge_type', TType.STRING, 6)
            oprot.writeString(self.edge_type.encode('utf-8') if sys.version_info[0] == 2 else self.edge_type)
            oprot.writeFieldEnd()
        if self.edge_props_name is not None:
            oprot.writeFieldBegin('edge_props_name', TType.STRING, 7)
            oprot.writeString(self.edge_props_name.encode('utf-8') if sys.version_info[0] == 2 else self.edge_props_name)
            oprot.writeFieldEnd()
        if self.bidirection is not None:
            oprot.writeFieldBegin('bidirection', TType.BOOL, 8)
            oprot.writeBool(self.bidirection)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_pagerank_args)
query_pagerank_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'damping_factor', None, 0.8000000000000000, ),  # 2
    (3, TType.I32, 'epoch_limit', None, 100, ),  # 3
    (4, TType.DOUBLE, 'max_convergence_error', None, 0.0010000000000000, ),  # 4
    (5, TType.DOUBLE, 'vertex_init_value', None, float(1), ),  # 5
    (6, TType.STRING, 'edge_type', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'edge_props_name', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'bidirection', None, False, ),  # 8
)


class query_pagerank_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.score_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_pagerank_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_pagerank_result)
query_pagerank_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.score_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_pagerank_top_k_args(object):
    """
    Attributes:
     - db_name
     - damping_factor
     - epoch_limit
     - max_convergence_error
     - vertex_init_value
     - edge_type
     - edge_props_name
     - bidirection
     - top_k

    """


    def __init__(self, db_name=None, damping_factor=0.8000000000000000, epoch_limit=100, max_convergence_error=0.0010000000000000, vertex_init_value=float(1), edge_type=None, edge_props_name=None, bidirection=False, top_k=None,):
        self.db_name = db_name
        self.damping_factor = damping_factor
        self.epoch_limit = epoch_limit
        self.max_convergence_error = max_convergence_error
        self.vertex_init_value = vertex_init_value
        self.edge_type = edge_type
        self.edge_props_name = edge_props_name
        self.bidirection = bidirection
        self.top_k = top_k

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.damping_factor = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.epoch_limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.max_convergence_error = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.vertex_init_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.edge_type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.edge_props_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.bidirection = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.top_k = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_pagerank_top_k_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.damping_factor is not None:
            oprot.writeFieldBegin('damping_factor', TType.DOUBLE, 2)
            oprot.writeDouble(self.damping_factor)
            oprot.writeFieldEnd()
        if self.epoch_limit is not None:
            oprot.writeFieldBegin('epoch_limit', TType.I32, 3)
            oprot.writeI32(self.epoch_limit)
            oprot.writeFieldEnd()
        if self.max_convergence_error is not None:
            oprot.writeFieldBegin('max_convergence_error', TType.DOUBLE, 4)
            oprot.writeDouble(self.max_convergence_error)
            oprot.writeFieldEnd()
        if self.vertex_init_value is not None:
            oprot.writeFieldBegin('vertex_init_value', TType.DOUBLE, 5)
            oprot.writeDouble(self.vertex_init_value)
            oprot.writeFieldEnd()
        if self.edge_type is not None:
            oprot.writeFieldBegin('edge_type', TType.STRING, 6)
            oprot.writeString(self.edge_type.encode('utf-8') if sys.version_info[0] == 2 else self.edge_type)
            oprot.writeFieldEnd()
        if self.edge_props_name is not None:
            oprot.writeFieldBegin('edge_props_name', TType.STRING, 7)
            oprot.writeString(self.edge_props_name.encode('utf-8') if sys.version_info[0] == 2 else self.edge_props_name)
            oprot.writeFieldEnd()
        if self.bidirection is not None:
            oprot.writeFieldBegin('bidirection', TType.BOOL, 8)
            oprot.writeBool(self.bidirection)
            oprot.writeFieldEnd()
        if self.top_k is not None:
            oprot.writeFieldBegin('top_k', TType.I32, 9)
            oprot.writeI32(self.top_k)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_pagerank_top_k_args)
query_pagerank_top_k_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'damping_factor', None, 0.8000000000000000, ),  # 2
    (3, TType.I32, 'epoch_limit', None, 100, ),  # 3
    (4, TType.DOUBLE, 'max_convergence_error', None, 0.0010000000000000, ),  # 4
    (5, TType.DOUBLE, 'vertex_init_value', None, float(1), ),  # 5
    (6, TType.STRING, 'edge_type', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'edge_props_name', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'bidirection', None, False, ),  # 8
    (9, TType.I32, 'top_k', None, None, ),  # 9
)


class query_pagerank_top_k_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.score_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_pagerank_top_k_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_pagerank_top_k_result)
query_pagerank_top_k_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.score_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_betcentrality_args(object):
    """
    Attributes:
     - db_name
     - search_direction
     - hop

    """


    def __init__(self, db_name=None, search_direction=2, hop=2147483647,):
        self.db_name = db_name
        self.search_direction = search_direction
        self.hop = hop

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.hop = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_betcentrality_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 2)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.hop is not None:
            oprot.writeFieldBegin('hop', TType.I32, 3)
            oprot.writeI32(self.hop)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_betcentrality_args)
query_betcentrality_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'search_direction', None, 2, ),  # 2
    (3, TType.I32, 'hop', None, 2147483647, ),  # 3
)


class query_betcentrality_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.score_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_betcentrality_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_betcentrality_result)
query_betcentrality_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.score_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_clocentrality_args(object):
    """
    Attributes:
     - db_name
     - if_WF
     - hop

    """


    def __init__(self, db_name=None, if_WF=True, hop=2147483647,):
        self.db_name = db_name
        self.if_WF = if_WF
        self.hop = hop

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_WF = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.hop = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_clocentrality_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.if_WF is not None:
            oprot.writeFieldBegin('if_WF', TType.BOOL, 2)
            oprot.writeBool(self.if_WF)
            oprot.writeFieldEnd()
        if self.hop is not None:
            oprot.writeFieldBegin('hop', TType.I32, 3)
            oprot.writeI32(self.hop)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_clocentrality_args)
query_clocentrality_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'if_WF', None, True, ),  # 2
    (3, TType.I32, 'hop', None, 2147483647, ),  # 3
)


class query_clocentrality_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.score_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_clocentrality_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_clocentrality_result)
query_clocentrality_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.score_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_louvain_args(object):
    """
    Attributes:
     - db_name
     - edge_type
     - edge_props_name

    """


    def __init__(self, db_name=None, edge_type=None, edge_props_name=None,):
        self.db_name = db_name
        self.edge_type = edge_type
        self.edge_props_name = edge_props_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.edge_type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.edge_props_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_louvain_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.edge_type is not None:
            oprot.writeFieldBegin('edge_type', TType.STRING, 2)
            oprot.writeString(self.edge_type.encode('utf-8') if sys.version_info[0] == 2 else self.edge_type)
            oprot.writeFieldEnd()
        if self.edge_props_name is not None:
            oprot.writeFieldBegin('edge_props_name', TType.STRING, 3)
            oprot.writeString(self.edge_props_name.encode('utf-8') if sys.version_info[0] == 2 else self.edge_props_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_louvain_args)
query_louvain_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'edge_type', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'edge_props_name', 'UTF8', None, ),  # 3
)


class query_louvain_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.community_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_louvain_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_louvain_result)
query_louvain_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.community_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_k_core_args(object):
    """
    Attributes:
     - db_name
     - k_max

    """


    def __init__(self, db_name=None, k_max=None,):
        self.db_name = db_name
        self.k_max = k_max

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_k_core_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 2)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_k_core_args)
query_k_core_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'k_max', None, None, ),  # 2
)


class query_k_core_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.community_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_k_core_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_k_core_result)
query_k_core_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.community_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_wcc_args(object):
    """
    Attributes:
     - db_name

    """


    def __init__(self, db_name=None,):
        self.db_name = db_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_wcc_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_wcc_args)
query_wcc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
)


class query_wcc_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.community_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_wcc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_wcc_result)
query_wcc_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.community_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_scc_args(object):
    """
    Attributes:
     - db_name

    """


    def __init__(self, db_name=None,):
        self.db_name = db_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_scc_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_scc_args)
query_scc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
)


class query_scc_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.community_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_scc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_scc_result)
query_scc_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.community_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_lpa_args(object):
    """
    Attributes:
     - db_name
     - epoch_limit

    """


    def __init__(self, db_name=None, epoch_limit=100,):
        self.db_name = db_name
        self.epoch_limit = epoch_limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.epoch_limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_lpa_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.epoch_limit is not None:
            oprot.writeFieldBegin('epoch_limit', TType.I32, 2)
            oprot.writeI32(self.epoch_limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_lpa_args)
query_lpa_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'epoch_limit', None, 100, ),  # 2
)


class query_lpa_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.community_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_lpa_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_lpa_result)
query_lpa_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.community_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_lpa_sync_args(object):
    """
    Attributes:
     - db_name
     - epoch_limit

    """


    def __init__(self, db_name=None, epoch_limit=100,):
        self.db_name = db_name
        self.epoch_limit = epoch_limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.epoch_limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_lpa_sync_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.epoch_limit is not None:
            oprot.writeFieldBegin('epoch_limit', TType.I32, 2)
            oprot.writeI32(self.epoch_limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_lpa_sync_args)
query_lpa_sync_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'epoch_limit', None, 100, ),  # 2
)


class query_lpa_sync_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.community_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_lpa_sync_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_lpa_sync_result)
query_lpa_sync_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.community_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_dijkstra_args(object):
    """
    Attributes:
     - db_name
     - src_node_id
     - dest_node_id
     - search_direction
     - edge_type
     - edge_props_name

    """


    def __init__(self, db_name=None, src_node_id=None, dest_node_id=None, search_direction=None, edge_type=None, edge_props_name=None,):
        self.db_name = db_name
        self.src_node_id = src_node_id
        self.dest_node_id = dest_node_id
        self.search_direction = search_direction
        self.edge_type = edge_type
        self.edge_props_name = edge_props_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.src_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dest_node_id = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.dest_node_id.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.edge_type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.edge_props_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_dijkstra_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.src_node_id is not None:
            oprot.writeFieldBegin('src_node_id', TType.I32, 2)
            oprot.writeI32(self.src_node_id)
            oprot.writeFieldEnd()
        if self.dest_node_id is not None:
            oprot.writeFieldBegin('dest_node_id', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.dest_node_id))
            for iter6 in self.dest_node_id:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 4)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.edge_type is not None:
            oprot.writeFieldBegin('edge_type', TType.STRING, 5)
            oprot.writeString(self.edge_type.encode('utf-8') if sys.version_info[0] == 2 else self.edge_type)
            oprot.writeFieldEnd()
        if self.edge_props_name is not None:
            oprot.writeFieldBegin('edge_props_name', TType.STRING, 6)
            oprot.writeString(self.edge_props_name.encode('utf-8') if sys.version_info[0] == 2 else self.edge_props_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_dijkstra_args)
query_dijkstra_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'src_node_id', None, None, ),  # 2
    (3, TType.LIST, 'dest_node_id', (TType.I32, None, False), None, ),  # 3
    (4, TType.I32, 'search_direction', None, None, ),  # 4
    (5, TType.STRING, 'edge_type', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'edge_props_name', 'UTF8', None, ),  # 6
)


class query_dijkstra_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.dij_l0()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_dijkstra_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_dijkstra_result)
query_dijkstra_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.dij_l0, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_random_walk_sub_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - length
     - num_walks
     - p
     - q
     - search_direction

    """


    def __init__(self, db_name=None, node_id=None, length=None, num_walks=None, p=None, q=None, search_direction=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.length = length
        self.num_walks = num_walks
        self.p = p
        self.q = q
        self.search_direction = search_direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.num_walks = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.p = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.q = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_random_walk_sub_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 3)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        if self.num_walks is not None:
            oprot.writeFieldBegin('num_walks', TType.I32, 4)
            oprot.writeI32(self.num_walks)
            oprot.writeFieldEnd()
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.DOUBLE, 5)
            oprot.writeDouble(self.p)
            oprot.writeFieldEnd()
        if self.q is not None:
            oprot.writeFieldBegin('q', TType.DOUBLE, 6)
            oprot.writeDouble(self.q)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 7)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_random_walk_sub_args)
query_random_walk_sub_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'length', None, None, ),  # 3
    (4, TType.I32, 'num_walks', None, None, ),  # 4
    (5, TType.DOUBLE, 'p', None, None, ),  # 5
    (6, TType.DOUBLE, 'q', None, None, ),  # 6
    (7, TType.I32, 'search_direction', None, None, ),  # 7
)


class query_random_walk_sub_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_random_walk_sub_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_random_walk_sub_result)
query_random_walk_sub_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_euclidean_distance_args(object):
    """
    Attributes:
     - db_name
     - A
     - B

    """


    def __init__(self, db_name=None, A=None, B=None,):
        self.db_name = db_name
        self.A = A
        self.B = B

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.A = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readDouble()
                        self.A.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.B = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = iprot.readDouble()
                        self.B.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_euclidean_distance_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.A is not None:
            oprot.writeFieldBegin('A', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.A))
            for iter19 in self.A:
                oprot.writeDouble(iter19)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.B is not None:
            oprot.writeFieldBegin('B', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.B))
            for iter20 in self.B:
                oprot.writeDouble(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_euclidean_distance_args)
query_euclidean_distance_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'A', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'B', (TType.DOUBLE, None, False), None, ),  # 3
)


class query_euclidean_distance_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.double_response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_euclidean_distance_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_euclidean_distance_result)
query_euclidean_distance_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.double_response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_pearson_similarity_args(object):
    """
    Attributes:
     - db_name
     - A
     - B

    """


    def __init__(self, db_name=None, A=None, B=None,):
        self.db_name = db_name
        self.A = A
        self.B = B

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.A = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readDouble()
                        self.A.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.B = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = iprot.readDouble()
                        self.B.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_pearson_similarity_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.A is not None:
            oprot.writeFieldBegin('A', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.A))
            for iter33 in self.A:
                oprot.writeDouble(iter33)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.B is not None:
            oprot.writeFieldBegin('B', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.B))
            for iter34 in self.B:
                oprot.writeDouble(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_pearson_similarity_args)
query_pearson_similarity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'A', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'B', (TType.DOUBLE, None, False), None, ),  # 3
)


class query_pearson_similarity_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.double_response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_pearson_similarity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_pearson_similarity_result)
query_pearson_similarity_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.double_response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_overlap_similarity_args(object):
    """
    Attributes:
     - db_name
     - A
     - B

    """


    def __init__(self, db_name=None, A=None, B=None,):
        self.db_name = db_name
        self.A = A
        self.B = B

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.A = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readDouble()
                        self.A.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.B = []
                    (_etype44, _size41) = iprot.readListBegin()
                    for _i45 in range(_size41):
                        _elem46 = iprot.readDouble()
                        self.B.append(_elem46)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_overlap_similarity_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.A is not None:
            oprot.writeFieldBegin('A', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.A))
            for iter47 in self.A:
                oprot.writeDouble(iter47)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.B is not None:
            oprot.writeFieldBegin('B', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.B))
            for iter48 in self.B:
                oprot.writeDouble(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_overlap_similarity_args)
query_overlap_similarity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'A', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'B', (TType.DOUBLE, None, False), None, ),  # 3
)


class query_overlap_similarity_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.double_response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_overlap_similarity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_overlap_similarity_result)
query_overlap_similarity_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.double_response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_jaccard_similarity_args(object):
    """
    Attributes:
     - db_name
     - A
     - B

    """


    def __init__(self, db_name=None, A=None, B=None,):
        self.db_name = db_name
        self.A = A
        self.B = B

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.A = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readDouble()
                        self.A.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.B = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = iprot.readDouble()
                        self.B.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_jaccard_similarity_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.A is not None:
            oprot.writeFieldBegin('A', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.A))
            for iter61 in self.A:
                oprot.writeDouble(iter61)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.B is not None:
            oprot.writeFieldBegin('B', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.B))
            for iter62 in self.B:
                oprot.writeDouble(iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_jaccard_similarity_args)
query_jaccard_similarity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'A', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'B', (TType.DOUBLE, None, False), None, ),  # 3
)


class query_jaccard_similarity_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.double_response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_jaccard_similarity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_jaccard_similarity_result)
query_jaccard_similarity_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.double_response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_jaccard_similarity_between_two_node_args(object):
    """
    Attributes:
     - db_name
     - A
     - B

    """


    def __init__(self, db_name=None, A=None, B=None,):
        self.db_name = db_name
        self.A = A
        self.B = B

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.A = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.B = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_jaccard_similarity_between_two_node_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.A is not None:
            oprot.writeFieldBegin('A', TType.I32, 2)
            oprot.writeI32(self.A)
            oprot.writeFieldEnd()
        if self.B is not None:
            oprot.writeFieldBegin('B', TType.I32, 3)
            oprot.writeI32(self.B)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_jaccard_similarity_between_two_node_args)
query_jaccard_similarity_between_two_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'A', None, None, ),  # 2
    (3, TType.I32, 'B', None, None, ),  # 3
)


class query_jaccard_similarity_between_two_node_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.double_response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_jaccard_similarity_between_two_node_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_jaccard_similarity_between_two_node_result)
query_jaccard_similarity_between_two_node_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.double_response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_cosine_similarity_neighborhoods_single_source_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - e_type
     - weight
     - top_k

    """


    def __init__(self, db_name=None, node_id=None, e_type=None, weight=None, top_k=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.e_type = e_type
        self.weight = weight
        self.top_k = top_k

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.e_type = set()
                    (_etype66, _size63) = iprot.readSetBegin()
                    for _i67 in range(_size63):
                        _elem68 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.e_type.add(_elem68)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.weight = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.top_k = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_cosine_similarity_neighborhoods_single_source_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.e_type is not None:
            oprot.writeFieldBegin('e_type', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.e_type))
            for iter69 in self.e_type:
                oprot.writeString(iter69.encode('utf-8') if sys.version_info[0] == 2 else iter69)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.weight is not None:
            oprot.writeFieldBegin('weight', TType.STRING, 4)
            oprot.writeString(self.weight.encode('utf-8') if sys.version_info[0] == 2 else self.weight)
            oprot.writeFieldEnd()
        if self.top_k is not None:
            oprot.writeFieldBegin('top_k', TType.I32, 5)
            oprot.writeI32(self.top_k)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_cosine_similarity_neighborhoods_single_source_args)
query_cosine_similarity_neighborhoods_single_source_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.SET, 'e_type', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'weight', 'UTF8', None, ),  # 4
    (5, TType.I32, 'top_k', None, None, ),  # 5
)


class query_cosine_similarity_neighborhoods_single_source_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.score_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_cosine_similarity_neighborhoods_single_source_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_cosine_similarity_neighborhoods_single_source_result)
query_cosine_similarity_neighborhoods_single_source_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.score_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_knn_cosine_single_source_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - e_type
     - weight
     - top_k

    """


    def __init__(self, db_name=None, node_id=None, e_type=None, weight=None, top_k=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.e_type = e_type
        self.weight = weight
        self.top_k = top_k

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.e_type = set()
                    (_etype73, _size70) = iprot.readSetBegin()
                    for _i74 in range(_size70):
                        _elem75 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.e_type.add(_elem75)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.weight = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.top_k = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_knn_cosine_single_source_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.e_type is not None:
            oprot.writeFieldBegin('e_type', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.e_type))
            for iter76 in self.e_type:
                oprot.writeString(iter76.encode('utf-8') if sys.version_info[0] == 2 else iter76)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.weight is not None:
            oprot.writeFieldBegin('weight', TType.STRING, 4)
            oprot.writeString(self.weight.encode('utf-8') if sys.version_info[0] == 2 else self.weight)
            oprot.writeFieldEnd()
        if self.top_k is not None:
            oprot.writeFieldBegin('top_k', TType.I32, 5)
            oprot.writeI32(self.top_k)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_knn_cosine_single_source_args)
query_knn_cosine_single_source_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.SET, 'e_type', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'weight', 'UTF8', None, ),  # 4
    (5, TType.I32, 'top_k', None, None, ),  # 5
)


class query_knn_cosine_single_source_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.score_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_knn_cosine_single_source_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_knn_cosine_single_source_result)
query_knn_cosine_single_source_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.score_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_greedy_graph_coloring_args(object):
    """
    Attributes:
     - db_name
     - node_type_set
     - edge_type_set

    """


    def __init__(self, db_name=None, node_type_set=None, edge_type_set=None,):
        self.db_name = db_name
        self.node_type_set = node_type_set
        self.edge_type_set = edge_type_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.node_type_set = set()
                    (_etype80, _size77) = iprot.readSetBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.node_type_set.add(_elem82)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.edge_type_set = set()
                    (_etype86, _size83) = iprot.readSetBegin()
                    for _i87 in range(_size83):
                        _elem88 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.edge_type_set.add(_elem88)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_greedy_graph_coloring_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_type_set is not None:
            oprot.writeFieldBegin('node_type_set', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.node_type_set))
            for iter89 in self.node_type_set:
                oprot.writeString(iter89.encode('utf-8') if sys.version_info[0] == 2 else iter89)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.edge_type_set is not None:
            oprot.writeFieldBegin('edge_type_set', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.edge_type_set))
            for iter90 in self.edge_type_set:
                oprot.writeString(iter90.encode('utf-8') if sys.version_info[0] == 2 else iter90)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_greedy_graph_coloring_args)
query_greedy_graph_coloring_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.SET, 'node_type_set', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.SET, 'edge_type_set', (TType.STRING, 'UTF8', False), None, ),  # 3
)


class query_greedy_graph_coloring_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.score_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_greedy_graph_coloring_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_greedy_graph_coloring_result)
query_greedy_graph_coloring_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.score_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_slpa_args(object):
    """
    Attributes:
     - db_name
     - node_type_set
     - edge_type_set
     - threshold
     - max_iter
     - output_limit

    """


    def __init__(self, db_name=None, node_type_set=None, edge_type_set=None, threshold=None, max_iter=None, output_limit=None,):
        self.db_name = db_name
        self.node_type_set = node_type_set
        self.edge_type_set = edge_type_set
        self.threshold = threshold
        self.max_iter = max_iter
        self.output_limit = output_limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.node_type_set = set()
                    (_etype94, _size91) = iprot.readSetBegin()
                    for _i95 in range(_size91):
                        _elem96 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.node_type_set.add(_elem96)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.edge_type_set = set()
                    (_etype100, _size97) = iprot.readSetBegin()
                    for _i101 in range(_size97):
                        _elem102 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.edge_type_set.add(_elem102)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.threshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.max_iter = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.output_limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_slpa_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_type_set is not None:
            oprot.writeFieldBegin('node_type_set', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.node_type_set))
            for iter103 in self.node_type_set:
                oprot.writeString(iter103.encode('utf-8') if sys.version_info[0] == 2 else iter103)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.edge_type_set is not None:
            oprot.writeFieldBegin('edge_type_set', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.edge_type_set))
            for iter104 in self.edge_type_set:
                oprot.writeString(iter104.encode('utf-8') if sys.version_info[0] == 2 else iter104)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.threshold is not None:
            oprot.writeFieldBegin('threshold', TType.DOUBLE, 4)
            oprot.writeDouble(self.threshold)
            oprot.writeFieldEnd()
        if self.max_iter is not None:
            oprot.writeFieldBegin('max_iter', TType.I32, 5)
            oprot.writeI32(self.max_iter)
            oprot.writeFieldEnd()
        if self.output_limit is not None:
            oprot.writeFieldBegin('output_limit', TType.I32, 6)
            oprot.writeI32(self.output_limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_slpa_args)
query_slpa_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.SET, 'node_type_set', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.SET, 'edge_type_set', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.DOUBLE, 'threshold', None, None, ),  # 4
    (5, TType.I32, 'max_iter', None, None, ),  # 5
    (6, TType.I32, 'output_limit', None, None, ),  # 6
)


class query_slpa_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.community_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_slpa_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_slpa_result)
query_slpa_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.community_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_triangle_count_args(object):
    """
    Attributes:
     - db_name
     - node_type_set
     - edge_type_set

    """


    def __init__(self, db_name=None, node_type_set=None, edge_type_set=None,):
        self.db_name = db_name
        self.node_type_set = node_type_set
        self.edge_type_set = edge_type_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.node_type_set = set()
                    (_etype108, _size105) = iprot.readSetBegin()
                    for _i109 in range(_size105):
                        _elem110 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.node_type_set.add(_elem110)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.edge_type_set = set()
                    (_etype114, _size111) = iprot.readSetBegin()
                    for _i115 in range(_size111):
                        _elem116 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.edge_type_set.add(_elem116)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_triangle_count_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_type_set is not None:
            oprot.writeFieldBegin('node_type_set', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.node_type_set))
            for iter117 in self.node_type_set:
                oprot.writeString(iter117.encode('utf-8') if sys.version_info[0] == 2 else iter117)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.edge_type_set is not None:
            oprot.writeFieldBegin('edge_type_set', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.edge_type_set))
            for iter118 in self.edge_type_set:
                oprot.writeString(iter118.encode('utf-8') if sys.version_info[0] == 2 else iter118)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_triangle_count_args)
query_triangle_count_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.SET, 'node_type_set', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.SET, 'edge_type_set', (TType.STRING, 'UTF8', False), None, ),  # 3
)


class query_triangle_count_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.double_response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_triangle_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_triangle_count_result)
query_triangle_count_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.double_response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_local_clustering_coefficient_args(object):
    """
    Attributes:
     - db_name
     - node_type_set
     - edge_type_set
     - top_k

    """


    def __init__(self, db_name=None, node_type_set=None, edge_type_set=None, top_k=None,):
        self.db_name = db_name
        self.node_type_set = node_type_set
        self.edge_type_set = edge_type_set
        self.top_k = top_k

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.node_type_set = set()
                    (_etype122, _size119) = iprot.readSetBegin()
                    for _i123 in range(_size119):
                        _elem124 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.node_type_set.add(_elem124)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.edge_type_set = set()
                    (_etype128, _size125) = iprot.readSetBegin()
                    for _i129 in range(_size125):
                        _elem130 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.edge_type_set.add(_elem130)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.top_k = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_local_clustering_coefficient_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_type_set is not None:
            oprot.writeFieldBegin('node_type_set', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.node_type_set))
            for iter131 in self.node_type_set:
                oprot.writeString(iter131.encode('utf-8') if sys.version_info[0] == 2 else iter131)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.edge_type_set is not None:
            oprot.writeFieldBegin('edge_type_set', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.edge_type_set))
            for iter132 in self.edge_type_set:
                oprot.writeString(iter132.encode('utf-8') if sys.version_info[0] == 2 else iter132)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.top_k is not None:
            oprot.writeFieldBegin('top_k', TType.I32, 4)
            oprot.writeI32(self.top_k)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_local_clustering_coefficient_args)
query_local_clustering_coefficient_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.SET, 'node_type_set', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.SET, 'edge_type_set', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.I32, 'top_k', None, None, ),  # 4
)


class query_local_clustering_coefficient_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.score_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_local_clustering_coefficient_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_local_clustering_coefficient_result)
query_local_clustering_coefficient_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.score_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_single_source_shortest_path_unweighted_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - node_type_set
     - edge_type_set
     - k_min
     - k_max
     - search_direction
     - max_size

    """


    def __init__(self, db_name=None, node_id=None, node_type_set=None, edge_type_set=None, k_min=None, k_max=None, search_direction=None, max_size=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.node_type_set = node_type_set
        self.edge_type_set = edge_type_set
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.max_size = max_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.node_type_set = set()
                    (_etype136, _size133) = iprot.readSetBegin()
                    for _i137 in range(_size133):
                        _elem138 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.node_type_set.add(_elem138)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.edge_type_set = set()
                    (_etype142, _size139) = iprot.readSetBegin()
                    for _i143 in range(_size139):
                        _elem144 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.edge_type_set.add(_elem144)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.max_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_single_source_shortest_path_unweighted_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.node_type_set is not None:
            oprot.writeFieldBegin('node_type_set', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.node_type_set))
            for iter145 in self.node_type_set:
                oprot.writeString(iter145.encode('utf-8') if sys.version_info[0] == 2 else iter145)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.edge_type_set is not None:
            oprot.writeFieldBegin('edge_type_set', TType.SET, 4)
            oprot.writeSetBegin(TType.STRING, len(self.edge_type_set))
            for iter146 in self.edge_type_set:
                oprot.writeString(iter146.encode('utf-8') if sys.version_info[0] == 2 else iter146)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 5)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 6)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 7)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I64, 8)
            oprot.writeI64(self.max_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_single_source_shortest_path_unweighted_args)
query_single_source_shortest_path_unweighted_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.SET, 'node_type_set', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.SET, 'edge_type_set', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I32, 'k_min', None, None, ),  # 5
    (6, TType.I32, 'k_max', None, None, ),  # 6
    (7, TType.I32, 'search_direction', None, None, ),  # 7
    (8, TType.I64, 'max_size', None, None, ),  # 8
)


class query_single_source_shortest_path_unweighted_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_single_source_shortest_path_unweighted_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_single_source_shortest_path_unweighted_result)
query_single_source_shortest_path_unweighted_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_money_flow_args(object):
    """
    Attributes:
     - db_name
     - start_node
     - start_time
     - end_time
     - money_percent
     - time_window
     - edge_type
     - time_props
     - money_props
     - mode

    """


    def __init__(self, db_name=None, start_node=None, start_time=None, end_time=None, money_percent=None, time_window=None, edge_type=None, time_props=None, money_props=None, mode=None,):
        self.db_name = db_name
        self.start_node = start_node
        self.start_time = start_time
        self.end_time = end_time
        self.money_percent = money_percent
        self.time_window = time_window
        self.edge_type = edge_type
        self.time_props = time_props
        self.money_props = money_props
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start_node = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.start_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.end_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.money_percent = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.time_window = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.edge_type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.time_props = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.money_props = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_money_flow_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.start_node is not None:
            oprot.writeFieldBegin('start_node', TType.I32, 2)
            oprot.writeI32(self.start_node)
            oprot.writeFieldEnd()
        if self.start_time is not None:
            oprot.writeFieldBegin('start_time', TType.I64, 3)
            oprot.writeI64(self.start_time)
            oprot.writeFieldEnd()
        if self.end_time is not None:
            oprot.writeFieldBegin('end_time', TType.I64, 4)
            oprot.writeI64(self.end_time)
            oprot.writeFieldEnd()
        if self.money_percent is not None:
            oprot.writeFieldBegin('money_percent', TType.I32, 5)
            oprot.writeI32(self.money_percent)
            oprot.writeFieldEnd()
        if self.time_window is not None:
            oprot.writeFieldBegin('time_window', TType.I64, 6)
            oprot.writeI64(self.time_window)
            oprot.writeFieldEnd()
        if self.edge_type is not None:
            oprot.writeFieldBegin('edge_type', TType.STRING, 7)
            oprot.writeString(self.edge_type.encode('utf-8') if sys.version_info[0] == 2 else self.edge_type)
            oprot.writeFieldEnd()
        if self.time_props is not None:
            oprot.writeFieldBegin('time_props', TType.STRING, 8)
            oprot.writeString(self.time_props.encode('utf-8') if sys.version_info[0] == 2 else self.time_props)
            oprot.writeFieldEnd()
        if self.money_props is not None:
            oprot.writeFieldBegin('money_props', TType.STRING, 9)
            oprot.writeString(self.money_props.encode('utf-8') if sys.version_info[0] == 2 else self.money_props)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 10)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_money_flow_args)
query_money_flow_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'start_node', None, None, ),  # 2
    (3, TType.I64, 'start_time', None, None, ),  # 3
    (4, TType.I64, 'end_time', None, None, ),  # 4
    (5, TType.I32, 'money_percent', None, None, ),  # 5
    (6, TType.I64, 'time_window', None, None, ),  # 6
    (7, TType.STRING, 'edge_type', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'time_props', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'money_props', 'UTF8', None, ),  # 9
    (10, TType.I32, 'mode', None, None, ),  # 10
)


class query_money_flow_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.money_flow_return()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_money_flow_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_money_flow_result)
query_money_flow_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.money_flow_return, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_cluster_for_studio_args(object):
    """
    Attributes:
     - db_name
     - node_list
     - edge_list

    """


    def __init__(self, db_name=None, node_list=None, edge_list=None,):
        self.db_name = db_name
        self.node_list = node_list
        self.edge_list = edge_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.node_list = []
                    (_etype150, _size147) = iprot.readListBegin()
                    for _i151 in range(_size147):
                        _elem152 = iprot.readI32()
                        self.node_list.append(_elem152)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.edge_list = []
                    (_etype156, _size153) = iprot.readListBegin()
                    for _i157 in range(_size153):
                        _elem158 = ezootypes.ttypes.edge_i()
                        _elem158.read(iprot)
                        self.edge_list.append(_elem158)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_cluster_for_studio_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_list is not None:
            oprot.writeFieldBegin('node_list', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.node_list))
            for iter159 in self.node_list:
                oprot.writeI32(iter159)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.edge_list is not None:
            oprot.writeFieldBegin('edge_list', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.edge_list))
            for iter160 in self.edge_list:
                iter160.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_cluster_for_studio_args)
query_cluster_for_studio_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'node_list', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'edge_list', (TType.STRUCT, [ezootypes.ttypes.edge_i, None], False), None, ),  # 3
)


class query_cluster_for_studio_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.cluster_for_studio()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_cluster_for_studio_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_cluster_for_studio_result)
query_cluster_for_studio_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.cluster_for_studio, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_prop_cluster_args(object):
    """
    Attributes:
     - db_name
     - node_list
     - edge_list
     - type_prop

    """


    def __init__(self, db_name=None, node_list=None, edge_list=None, type_prop=None,):
        self.db_name = db_name
        self.node_list = node_list
        self.edge_list = edge_list
        self.type_prop = type_prop

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.node_list = []
                    (_etype164, _size161) = iprot.readListBegin()
                    for _i165 in range(_size161):
                        _elem166 = iprot.readI32()
                        self.node_list.append(_elem166)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.edge_list = []
                    (_etype170, _size167) = iprot.readListBegin()
                    for _i171 in range(_size167):
                        _elem172 = ezootypes.ttypes.edge_i()
                        _elem172.read(iprot)
                        self.edge_list.append(_elem172)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.type_prop = {}
                    (_ktype174, _vtype175, _size173) = iprot.readMapBegin()
                    for _i177 in range(_size173):
                        _key178 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val179 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.type_prop[_key178] = _val179
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_prop_cluster_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_list is not None:
            oprot.writeFieldBegin('node_list', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.node_list))
            for iter180 in self.node_list:
                oprot.writeI32(iter180)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.edge_list is not None:
            oprot.writeFieldBegin('edge_list', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.edge_list))
            for iter181 in self.edge_list:
                iter181.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.type_prop is not None:
            oprot.writeFieldBegin('type_prop', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.type_prop))
            for kiter182, viter183 in self.type_prop.items():
                oprot.writeString(kiter182.encode('utf-8') if sys.version_info[0] == 2 else kiter182)
                oprot.writeString(viter183.encode('utf-8') if sys.version_info[0] == 2 else viter183)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_prop_cluster_args)
query_prop_cluster_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'node_list', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'edge_list', (TType.STRUCT, [ezootypes.ttypes.edge_i, None], False), None, ),  # 3
    (4, TType.MAP, 'type_prop', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)


class query_prop_cluster_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.prop_cluster_for_studio()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_prop_cluster_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_prop_cluster_result)
query_prop_cluster_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.prop_cluster_for_studio, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_one_neighbour_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - search_direction

    """


    def __init__(self, db_name=None, node_id=None, search_direction=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.search_direction = search_direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_one_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 3)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_one_neighbour_args)
query_one_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'search_direction', None, None, ),  # 3
)


class query_one_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.one_neighbour()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_one_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_one_neighbour_result)
query_one_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.one_neighbour, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_simple_neighbour_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, node_id=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_simple_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_simple_neighbour_args)
query_simple_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
)


class query_simple_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour_simple_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_simple_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_simple_neighbour_result)
query_simple_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour_simple_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_simple_neighbour_limit_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - k_min
     - k_max
     - search_direction
     - condition
     - max_size

    """


    def __init__(self, db_name=None, node_id=None, k_min=None, k_max=None, search_direction=None, condition=None, max_size=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.max_size = max_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_simple_neighbour_limit_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 7)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_simple_neighbour_limit_args)
query_simple_neighbour_limit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.I32, 'max_size', None, None, ),  # 7
)


class query_simple_neighbour_limit_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour_simple_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_simple_neighbour_limit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_simple_neighbour_limit_result)
query_simple_neighbour_limit_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour_simple_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_common_simple_neighbour_args(object):
    """
    Attributes:
     - db_name
     - ids
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, ids=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.ids = ids
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype187, _size184) = iprot.readListBegin()
                    for _i188 in range(_size184):
                        _elem189 = iprot.readI32()
                        self.ids.append(_elem189)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_simple_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter190 in self.ids:
                oprot.writeI32(iter190)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_simple_neighbour_args)
query_common_simple_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
)


class query_common_simple_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.common_simple_neighbour()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_simple_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_simple_neighbour_result)
query_common_simple_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.common_simple_neighbour, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_neighbour_count_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, node_id=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_count_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_count_args)
query_neighbour_count_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
)


class query_neighbour_count_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour_count_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_count_result)
query_neighbour_count_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour_count_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_simple_path_args(object):
    """
    Attributes:
     - db_name
     - src_node_id
     - dest_node_id
     - k_max
     - search_direction
     - condition
     - max_size

    """


    def __init__(self, db_name=None, src_node_id=None, dest_node_id=None, k_max=None, search_direction=None, condition=None, max_size=None,):
        self.db_name = db_name
        self.src_node_id = src_node_id
        self.dest_node_id = dest_node_id
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.max_size = max_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.src_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dest_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_simple_path_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.src_node_id is not None:
            oprot.writeFieldBegin('src_node_id', TType.I32, 2)
            oprot.writeI32(self.src_node_id)
            oprot.writeFieldEnd()
        if self.dest_node_id is not None:
            oprot.writeFieldBegin('dest_node_id', TType.I32, 3)
            oprot.writeI32(self.dest_node_id)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 7)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_simple_path_args)
query_simple_path_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'src_node_id', None, None, ),  # 2
    (3, TType.I32, 'dest_node_id', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.I32, 'max_size', None, None, ),  # 7
)


class query_simple_path_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths_simple_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_simple_path_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_simple_path_result)
query_simple_path_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths_simple_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_full_path_args(object):
    """
    Attributes:
     - db_name
     - src_node_id
     - dest_node_id
     - k_max
     - search_direction
     - condition
     - max_size
     - distinct

    """


    def __init__(self, db_name=None, src_node_id=None, dest_node_id=None, k_max=None, search_direction=None, condition=None, max_size=None, distinct=None,):
        self.db_name = db_name
        self.src_node_id = src_node_id
        self.dest_node_id = dest_node_id
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.max_size = max_size
        self.distinct = distinct

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.src_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dest_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.distinct = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_full_path_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.src_node_id is not None:
            oprot.writeFieldBegin('src_node_id', TType.I32, 2)
            oprot.writeI32(self.src_node_id)
            oprot.writeFieldEnd()
        if self.dest_node_id is not None:
            oprot.writeFieldBegin('dest_node_id', TType.I32, 3)
            oprot.writeI32(self.dest_node_id)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 7)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        if self.distinct is not None:
            oprot.writeFieldBegin('distinct', TType.BOOL, 8)
            oprot.writeBool(self.distinct)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_full_path_args)
query_full_path_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'src_node_id', None, None, ),  # 2
    (3, TType.I32, 'dest_node_id', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.I32, 'max_size', None, None, ),  # 7
    (8, TType.BOOL, 'distinct', None, None, ),  # 8
)


class query_full_path_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths_simple_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_full_path_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_full_path_result)
query_full_path_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths_simple_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_full_path_with_set_args(object):
    """
    Attributes:
     - db_name
     - src_node_id_set
     - dest_node_id_set
     - k_max
     - search_direction
     - condition
     - max_size
     - distinct

    """


    def __init__(self, db_name=None, src_node_id_set=None, dest_node_id_set=None, k_max=None, search_direction=None, condition=None, max_size=None, distinct=None,):
        self.db_name = db_name
        self.src_node_id_set = src_node_id_set
        self.dest_node_id_set = dest_node_id_set
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.max_size = max_size
        self.distinct = distinct

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.src_node_id_set = set()
                    (_etype194, _size191) = iprot.readSetBegin()
                    for _i195 in range(_size191):
                        _elem196 = iprot.readI32()
                        self.src_node_id_set.add(_elem196)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.dest_node_id_set = set()
                    (_etype200, _size197) = iprot.readSetBegin()
                    for _i201 in range(_size197):
                        _elem202 = iprot.readI32()
                        self.dest_node_id_set.add(_elem202)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.distinct = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_full_path_with_set_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.src_node_id_set is not None:
            oprot.writeFieldBegin('src_node_id_set', TType.SET, 2)
            oprot.writeSetBegin(TType.I32, len(self.src_node_id_set))
            for iter203 in self.src_node_id_set:
                oprot.writeI32(iter203)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.dest_node_id_set is not None:
            oprot.writeFieldBegin('dest_node_id_set', TType.SET, 3)
            oprot.writeSetBegin(TType.I32, len(self.dest_node_id_set))
            for iter204 in self.dest_node_id_set:
                oprot.writeI32(iter204)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 7)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        if self.distinct is not None:
            oprot.writeFieldBegin('distinct', TType.I32, 8)
            oprot.writeI32(self.distinct)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_full_path_with_set_args)
query_full_path_with_set_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.SET, 'src_node_id_set', (TType.I32, None, False), None, ),  # 2
    (3, TType.SET, 'dest_node_id_set', (TType.I32, None, False), None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.I32, 'max_size', None, None, ),  # 7
    (8, TType.I32, 'distinct', None, None, ),  # 8
)


class query_full_path_with_set_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths_simple_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_full_path_with_set_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_full_path_with_set_result)
query_full_path_with_set_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths_simple_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_shortest_path_args(object):
    """
    Attributes:
     - db_name
     - a_node_id
     - b_node_id
     - condition
     - k_max
     - search_direction

    """


    def __init__(self, db_name=None, a_node_id=None, b_node_id=None, condition=None, k_max=None, search_direction=None,):
        self.db_name = db_name
        self.a_node_id = a_node_id
        self.b_node_id = b_node_id
        self.condition = condition
        self.k_max = k_max
        self.search_direction = search_direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.a_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.b_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_shortest_path_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.a_node_id is not None:
            oprot.writeFieldBegin('a_node_id', TType.I32, 2)
            oprot.writeI32(self.a_node_id)
            oprot.writeFieldEnd()
        if self.b_node_id is not None:
            oprot.writeFieldBegin('b_node_id', TType.I32, 3)
            oprot.writeI32(self.b_node_id)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 4)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 5)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 6)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_shortest_path_args)
query_shortest_path_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'a_node_id', None, None, ),  # 2
    (3, TType.I32, 'b_node_id', None, None, ),  # 3
    (4, TType.STRING, 'condition', 'UTF8', None, ),  # 4
    (5, TType.I32, 'k_max', None, None, ),  # 5
    (6, TType.I32, 'search_direction', None, None, ),  # 6
)


class query_shortest_path_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.one_path_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_shortest_path_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_shortest_path_result)
query_shortest_path_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.one_path_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_shortest_path_limit_args(object):
    """
    Attributes:
     - db_name
     - a_node_id
     - b_node_id
     - condition
     - k_max
     - search_direction
     - limit

    """


    def __init__(self, db_name=None, a_node_id=None, b_node_id=None, condition=None, k_max=None, search_direction=None, limit=None,):
        self.db_name = db_name
        self.a_node_id = a_node_id
        self.b_node_id = b_node_id
        self.condition = condition
        self.k_max = k_max
        self.search_direction = search_direction
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.a_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.b_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_shortest_path_limit_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.a_node_id is not None:
            oprot.writeFieldBegin('a_node_id', TType.I32, 2)
            oprot.writeI32(self.a_node_id)
            oprot.writeFieldEnd()
        if self.b_node_id is not None:
            oprot.writeFieldBegin('b_node_id', TType.I32, 3)
            oprot.writeI32(self.b_node_id)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 4)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 5)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 6)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 7)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_shortest_path_limit_args)
query_shortest_path_limit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'a_node_id', None, None, ),  # 2
    (3, TType.I32, 'b_node_id', None, None, ),  # 3
    (4, TType.STRING, 'condition', 'UTF8', None, ),  # 4
    (5, TType.I32, 'k_max', None, None, ),  # 5
    (6, TType.I32, 'search_direction', None, None, ),  # 6
    (7, TType.I32, 'limit', None, None, ),  # 7
)


class query_shortest_path_limit_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.one_path_v3()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_shortest_path_limit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_shortest_path_limit_result)
query_shortest_path_limit_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.one_path_v3, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_shortest_path_limit_v2_args(object):
    """
    Attributes:
     - db_name
     - a_node_id
     - b_node_id
     - condition
     - k_max
     - search_direction
     - limit

    """


    def __init__(self, db_name=None, a_node_id=None, b_node_id=None, condition=None, k_max=None, search_direction=None, limit=None,):
        self.db_name = db_name
        self.a_node_id = a_node_id
        self.b_node_id = b_node_id
        self.condition = condition
        self.k_max = k_max
        self.search_direction = search_direction
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.a_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.b_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_shortest_path_limit_v2_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.a_node_id is not None:
            oprot.writeFieldBegin('a_node_id', TType.I32, 2)
            oprot.writeI32(self.a_node_id)
            oprot.writeFieldEnd()
        if self.b_node_id is not None:
            oprot.writeFieldBegin('b_node_id', TType.I32, 3)
            oprot.writeI32(self.b_node_id)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 4)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 5)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 6)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 7)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_shortest_path_limit_v2_args)
query_shortest_path_limit_v2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'a_node_id', None, None, ),  # 2
    (3, TType.I32, 'b_node_id', None, None, ),  # 3
    (4, TType.STRING, 'condition', 'UTF8', None, ),  # 4
    (5, TType.I32, 'k_max', None, None, ),  # 5
    (6, TType.I32, 'search_direction', None, None, ),  # 6
    (7, TType.I32, 'limit', None, None, ),  # 7
)


class query_shortest_path_limit_v2_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_shortest_path_limit_v2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_shortest_path_limit_v2_result)
query_shortest_path_limit_v2_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_subgraph_with_node_args(object):
    """
    Attributes:
     - db_name
     - ids

    """


    def __init__(self, db_name=None, ids=None,):
        self.db_name = db_name
        self.ids = ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype208, _size205) = iprot.readListBegin()
                    for _i209 in range(_size205):
                        _elem210 = iprot.readI32()
                        self.ids.append(_elem210)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_with_node_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter211 in self.ids:
                oprot.writeI32(iter211)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_with_node_args)
query_subgraph_with_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
)


class query_subgraph_with_node_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.graph()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_with_node_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_with_node_result)
query_subgraph_with_node_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.graph, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_subgraph_with_node_neighbour_args(object):
    """
    Attributes:
     - db_name
     - ids
     - search_direction
     - k

    """


    def __init__(self, db_name=None, ids=None, search_direction=None, k=None,):
        self.db_name = db_name
        self.ids = ids
        self.search_direction = search_direction
        self.k = k

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype215, _size212) = iprot.readListBegin()
                    for _i216 in range(_size212):
                        _elem217 = iprot.readI32()
                        self.ids.append(_elem217)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_with_node_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter218 in self.ids:
                oprot.writeI32(iter218)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 3)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.I32, 4)
            oprot.writeI32(self.k)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_with_node_neighbour_args)
query_subgraph_with_node_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'search_direction', None, None, ),  # 3
    (4, TType.I32, 'k', None, None, ),  # 4
)


class query_subgraph_with_node_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.graph()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_with_node_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_with_node_neighbour_result)
query_subgraph_with_node_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.graph, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_subgraph_with_neighbour_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, node_id=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_with_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_with_neighbour_args)
query_subgraph_with_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
)


class query_subgraph_with_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.graph()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_with_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_with_neighbour_result)
query_subgraph_with_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.graph, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_subgraph_with_neighbour_limit_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - k_min
     - k_max
     - search_direction
     - condition
     - max_size

    """


    def __init__(self, db_name=None, node_id=None, k_min=None, k_max=None, search_direction=None, condition=None, max_size=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.max_size = max_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_with_neighbour_limit_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 7)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_with_neighbour_limit_args)
query_subgraph_with_neighbour_limit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.I32, 'max_size', None, None, ),  # 7
)


class query_subgraph_with_neighbour_limit_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.graph()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_with_neighbour_limit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_with_neighbour_limit_result)
query_subgraph_with_neighbour_limit_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.graph, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_subgraph_with_type_args(object):
    """
    Attributes:
     - db_name
     - node_type_list
     - edge_type_list

    """


    def __init__(self, db_name=None, node_type_list=None, edge_type_list=None,):
        self.db_name = db_name
        self.node_type_list = node_type_list
        self.edge_type_list = edge_type_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.node_type_list = []
                    (_etype222, _size219) = iprot.readListBegin()
                    for _i223 in range(_size219):
                        _elem224 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.node_type_list.append(_elem224)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.edge_type_list = []
                    (_etype228, _size225) = iprot.readListBegin()
                    for _i229 in range(_size225):
                        _elem230 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.edge_type_list.append(_elem230)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_with_type_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_type_list is not None:
            oprot.writeFieldBegin('node_type_list', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.node_type_list))
            for iter231 in self.node_type_list:
                oprot.writeString(iter231.encode('utf-8') if sys.version_info[0] == 2 else iter231)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.edge_type_list is not None:
            oprot.writeFieldBegin('edge_type_list', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.edge_type_list))
            for iter232 in self.edge_type_list:
                oprot.writeString(iter232.encode('utf-8') if sys.version_info[0] == 2 else iter232)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_with_type_args)
query_subgraph_with_type_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'node_type_list', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'edge_type_list', (TType.STRING, 'UTF8', False), None, ),  # 3
)


class query_subgraph_with_type_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.graph()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_with_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_with_type_result)
query_subgraph_with_type_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.graph, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class create_subgraph_with_node_args(object):
    """
    Attributes:
     - db_name
     - ids
     - new_db_name
     - readonly

    """


    def __init__(self, db_name=None, ids=None, new_db_name=None, readonly=None,):
        self.db_name = db_name
        self.ids = ids
        self.new_db_name = new_db_name
        self.readonly = readonly

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype236, _size233) = iprot.readListBegin()
                    for _i237 in range(_size233):
                        _elem238 = iprot.readI32()
                        self.ids.append(_elem238)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.new_db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.readonly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_subgraph_with_node_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter239 in self.ids:
                oprot.writeI32(iter239)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.new_db_name is not None:
            oprot.writeFieldBegin('new_db_name', TType.STRING, 3)
            oprot.writeString(self.new_db_name.encode('utf-8') if sys.version_info[0] == 2 else self.new_db_name)
            oprot.writeFieldEnd()
        if self.readonly is not None:
            oprot.writeFieldBegin('readonly', TType.BOOL, 4)
            oprot.writeBool(self.readonly)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_subgraph_with_node_args)
create_subgraph_with_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.STRING, 'new_db_name', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'readonly', None, None, ),  # 4
)


class create_subgraph_with_node_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.Response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_subgraph_with_node_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_subgraph_with_node_result)
create_subgraph_with_node_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.Response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class create_subgraph_with_node_neighbour_args(object):
    """
    Attributes:
     - db_name
     - ids
     - search_direction
     - k
     - new_db_name
     - readonly

    """


    def __init__(self, db_name=None, ids=None, search_direction=None, k=None, new_db_name=None, readonly=None,):
        self.db_name = db_name
        self.ids = ids
        self.search_direction = search_direction
        self.k = k
        self.new_db_name = new_db_name
        self.readonly = readonly

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype243, _size240) = iprot.readListBegin()
                    for _i244 in range(_size240):
                        _elem245 = iprot.readI32()
                        self.ids.append(_elem245)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.new_db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.readonly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_subgraph_with_node_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter246 in self.ids:
                oprot.writeI32(iter246)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 3)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.I32, 4)
            oprot.writeI32(self.k)
            oprot.writeFieldEnd()
        if self.new_db_name is not None:
            oprot.writeFieldBegin('new_db_name', TType.STRING, 5)
            oprot.writeString(self.new_db_name.encode('utf-8') if sys.version_info[0] == 2 else self.new_db_name)
            oprot.writeFieldEnd()
        if self.readonly is not None:
            oprot.writeFieldBegin('readonly', TType.BOOL, 6)
            oprot.writeBool(self.readonly)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_subgraph_with_node_neighbour_args)
create_subgraph_with_node_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'search_direction', None, None, ),  # 3
    (4, TType.I32, 'k', None, None, ),  # 4
    (5, TType.STRING, 'new_db_name', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'readonly', None, None, ),  # 6
)


class create_subgraph_with_node_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.Response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_subgraph_with_node_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_subgraph_with_node_neighbour_result)
create_subgraph_with_node_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.Response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class create_subgraph_with_neighbour_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - k_min
     - k_max
     - search_direction
     - condition
     - new_db_name
     - readonly

    """


    def __init__(self, db_name=None, node_id=None, k_min=None, k_max=None, search_direction=None, condition=None, new_db_name=None, readonly=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.new_db_name = new_db_name
        self.readonly = readonly

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.new_db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.readonly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_subgraph_with_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.new_db_name is not None:
            oprot.writeFieldBegin('new_db_name', TType.STRING, 7)
            oprot.writeString(self.new_db_name.encode('utf-8') if sys.version_info[0] == 2 else self.new_db_name)
            oprot.writeFieldEnd()
        if self.readonly is not None:
            oprot.writeFieldBegin('readonly', TType.BOOL, 8)
            oprot.writeBool(self.readonly)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_subgraph_with_neighbour_args)
create_subgraph_with_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'new_db_name', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'readonly', None, None, ),  # 8
)


class create_subgraph_with_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.Response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_subgraph_with_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_subgraph_with_neighbour_result)
create_subgraph_with_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.Response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class create_subgraph_with_type_args(object):
    """
    Attributes:
     - db_name
     - node_type_list
     - edge_type_list
     - new_db_name
     - readonly

    """


    def __init__(self, db_name=None, node_type_list=None, edge_type_list=None, new_db_name=None, readonly=None,):
        self.db_name = db_name
        self.node_type_list = node_type_list
        self.edge_type_list = edge_type_list
        self.new_db_name = new_db_name
        self.readonly = readonly

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.node_type_list = []
                    (_etype250, _size247) = iprot.readListBegin()
                    for _i251 in range(_size247):
                        _elem252 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.node_type_list.append(_elem252)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.edge_type_list = []
                    (_etype256, _size253) = iprot.readListBegin()
                    for _i257 in range(_size253):
                        _elem258 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.edge_type_list.append(_elem258)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.new_db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.readonly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_subgraph_with_type_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_type_list is not None:
            oprot.writeFieldBegin('node_type_list', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.node_type_list))
            for iter259 in self.node_type_list:
                oprot.writeString(iter259.encode('utf-8') if sys.version_info[0] == 2 else iter259)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.edge_type_list is not None:
            oprot.writeFieldBegin('edge_type_list', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.edge_type_list))
            for iter260 in self.edge_type_list:
                oprot.writeString(iter260.encode('utf-8') if sys.version_info[0] == 2 else iter260)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.new_db_name is not None:
            oprot.writeFieldBegin('new_db_name', TType.STRING, 4)
            oprot.writeString(self.new_db_name.encode('utf-8') if sys.version_info[0] == 2 else self.new_db_name)
            oprot.writeFieldEnd()
        if self.readonly is not None:
            oprot.writeFieldBegin('readonly', TType.BOOL, 5)
            oprot.writeBool(self.readonly)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_subgraph_with_type_args)
create_subgraph_with_type_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'node_type_list', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'edge_type_list', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'new_db_name', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'readonly', None, None, ),  # 5
)


class create_subgraph_with_type_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.Response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_subgraph_with_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_subgraph_with_type_result)
create_subgraph_with_type_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.Response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_common_neighbour_args(object):
    """
    Attributes:
     - db_name
     - ids
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, ids=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.ids = ids
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype264, _size261) = iprot.readListBegin()
                    for _i265 in range(_size261):
                        _elem266 = iprot.readI32()
                        self.ids.append(_elem266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter267 in self.ids:
                oprot.writeI32(iter267)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_neighbour_args)
query_common_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
)


class query_common_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.common_neighbour()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_neighbour_result)
query_common_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.common_neighbour, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_common_neighbour_with_limit_args(object):
    """
    Attributes:
     - db_name
     - ids
     - k_min
     - k_max
     - search_direction
     - condition
     - max_size

    """


    def __init__(self, db_name=None, ids=None, k_min=None, k_max=None, search_direction=None, condition=None, max_size=None,):
        self.db_name = db_name
        self.ids = ids
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.max_size = max_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype271, _size268) = iprot.readListBegin()
                    for _i272 in range(_size268):
                        _elem273 = iprot.readI32()
                        self.ids.append(_elem273)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_neighbour_with_limit_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter274 in self.ids:
                oprot.writeI32(iter274)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 7)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_neighbour_with_limit_args)
query_common_neighbour_with_limit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.I32, 'max_size', None, None, ),  # 7
)


class query_common_neighbour_with_limit_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.common_neighbour()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_neighbour_with_limit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_neighbour_with_limit_result)
query_common_neighbour_with_limit_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.common_neighbour, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_common_neighbour_with_few_relations_args(object):
    """
    Attributes:
     - db_name
     - ids
     - k_min
     - k_max
     - search_direction
     - condition
     - max_size

    """


    def __init__(self, db_name=None, ids=None, k_min=None, k_max=None, search_direction=None, condition=None, max_size=None,):
        self.db_name = db_name
        self.ids = ids
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.max_size = max_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype278, _size275) = iprot.readListBegin()
                    for _i279 in range(_size275):
                        _elem280 = iprot.readI32()
                        self.ids.append(_elem280)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_neighbour_with_few_relations_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter281 in self.ids:
                oprot.writeI32(iter281)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 7)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_neighbour_with_few_relations_args)
query_common_neighbour_with_few_relations_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.I32, 'max_size', None, None, ),  # 7
)


class query_common_neighbour_with_few_relations_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.common_neighbour()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_neighbour_with_few_relations_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_neighbour_with_few_relations_result)
query_common_neighbour_with_few_relations_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.common_neighbour, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_common_neighbour_without_relations_args(object):
    """
    Attributes:
     - db_name
     - ids
     - k_min
     - k_max
     - search_direction
     - condition
     - max_size

    """


    def __init__(self, db_name=None, ids=None, k_min=None, k_max=None, search_direction=None, condition=None, max_size=None,):
        self.db_name = db_name
        self.ids = ids
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.max_size = max_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype285, _size282) = iprot.readListBegin()
                    for _i286 in range(_size282):
                        _elem287 = iprot.readI32()
                        self.ids.append(_elem287)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_neighbour_without_relations_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter288 in self.ids:
                oprot.writeI32(iter288)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 7)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_neighbour_without_relations_args)
query_common_neighbour_without_relations_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.I32, 'max_size', None, None, ),  # 7
)


class query_common_neighbour_without_relations_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.common_neighbour()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_neighbour_without_relations_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_neighbour_without_relations_result)
query_common_neighbour_without_relations_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.common_neighbour, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_union_neighbour_args(object):
    """
    Attributes:
     - db_name
     - ids
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, ids=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.ids = ids
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype292, _size289) = iprot.readListBegin()
                    for _i293 in range(_size289):
                        _elem294 = iprot.readI32()
                        self.ids.append(_elem294)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_union_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter295 in self.ids:
                oprot.writeI32(iter295)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_union_neighbour_args)
query_union_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
)


class query_union_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_union_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_union_neighbour_result)
query_union_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_difference_neighbour_args(object):
    """
    Attributes:
     - db_name
     - A
     - B
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, A=None, B=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.A = A
        self.B = B
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.A = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.B = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_difference_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.A is not None:
            oprot.writeFieldBegin('A', TType.I32, 2)
            oprot.writeI32(self.A)
            oprot.writeFieldEnd()
        if self.B is not None:
            oprot.writeFieldBegin('B', TType.I32, 3)
            oprot.writeI32(self.B)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 4)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 5)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 6)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 7)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_difference_neighbour_args)
query_difference_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'A', None, None, ),  # 2
    (3, TType.I32, 'B', None, None, ),  # 3
    (4, TType.I32, 'k_min', None, None, ),  # 4
    (5, TType.I32, 'k_max', None, None, ),  # 5
    (6, TType.I32, 'search_direction', None, None, ),  # 6
    (7, TType.STRING, 'condition', 'UTF8', None, ),  # 7
)


class query_difference_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_difference_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_difference_neighbour_result)
query_difference_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_standard_difference_neighbour_args(object):
    """
    Attributes:
     - db_name
     - A
     - B
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, A=None, B=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.A = A
        self.B = B
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.A = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.B = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_standard_difference_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.A is not None:
            oprot.writeFieldBegin('A', TType.I32, 2)
            oprot.writeI32(self.A)
            oprot.writeFieldEnd()
        if self.B is not None:
            oprot.writeFieldBegin('B', TType.I32, 3)
            oprot.writeI32(self.B)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 4)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 5)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 6)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 7)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_standard_difference_neighbour_args)
query_standard_difference_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'A', None, None, ),  # 2
    (3, TType.I32, 'B', None, None, ),  # 3
    (4, TType.I32, 'k_min', None, None, ),  # 4
    (5, TType.I32, 'k_max', None, None, ),  # 5
    (6, TType.I32, 'search_direction', None, None, ),  # 6
    (7, TType.STRING, 'condition', 'UTF8', None, ),  # 7
)


class query_standard_difference_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_standard_difference_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_standard_difference_neighbour_result)
query_standard_difference_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_total_neighbour_args(object):
    """
    Attributes:
     - db_name
     - ids
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, ids=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.ids = ids
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype299, _size296) = iprot.readListBegin()
                    for _i300 in range(_size296):
                        _elem301 = iprot.readI32()
                        self.ids.append(_elem301)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_total_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter302 in self.ids:
                oprot.writeI32(iter302)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_total_neighbour_args)
query_total_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
)


class query_total_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_total_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_total_neighbour_result)
query_total_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_path_args(object):
    """
    Attributes:
     - db_name
     - src_node_id
     - dest_node_id
     - k_min
     - k_max
     - search_direction
     - condition
     - max_size
     - query_type

    """


    def __init__(self, db_name=None, src_node_id=None, dest_node_id=None, k_min=None, k_max=None, search_direction=None, condition=None, max_size=None, query_type=None,):
        self.db_name = db_name
        self.src_node_id = src_node_id
        self.dest_node_id = dest_node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.max_size = max_size
        self.query_type = query_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.src_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dest_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.query_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_path_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.src_node_id is not None:
            oprot.writeFieldBegin('src_node_id', TType.I32, 2)
            oprot.writeI32(self.src_node_id)
            oprot.writeFieldEnd()
        if self.dest_node_id is not None:
            oprot.writeFieldBegin('dest_node_id', TType.I32, 3)
            oprot.writeI32(self.dest_node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 4)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 5)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 6)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 7)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 8)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        if self.query_type is not None:
            oprot.writeFieldBegin('query_type', TType.I32, 9)
            oprot.writeI32(self.query_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_path_args)
query_path_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'src_node_id', None, None, ),  # 2
    (3, TType.I32, 'dest_node_id', None, None, ),  # 3
    (4, TType.I32, 'k_min', None, None, ),  # 4
    (5, TType.I32, 'k_max', None, None, ),  # 5
    (6, TType.I32, 'search_direction', None, None, ),  # 6
    (7, TType.STRING, 'condition', 'UTF8', None, ),  # 7
    (8, TType.I32, 'max_size', None, None, ),  # 8
    (9, TType.I32, 'query_type', None, None, ),  # 9
)


class query_path_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_path_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_path_result)
query_path_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_neighbour_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - k_min
     - k_max
     - search_direction
     - condition
     - return_relations

    """


    def __init__(self, db_name=None, node_id=None, k_min=None, k_max=None, search_direction=None, condition=None, return_relations=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.return_relations = return_relations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.return_relations = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.return_relations is not None:
            oprot.writeFieldBegin('return_relations', TType.BOOL, 7)
            oprot.writeBool(self.return_relations)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_args)
query_neighbour_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.BOOL, 'return_relations', None, None, ),  # 7
)


class query_neighbour_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_result)
query_neighbour_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_neighbour_with_limit_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - k_min
     - k_max
     - search_direction
     - condition
     - return_relations
     - max_size

    """


    def __init__(self, db_name=None, node_id=None, k_min=None, k_max=None, search_direction=None, condition=None, return_relations=None, max_size=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.return_relations = return_relations
        self.max_size = max_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.return_relations = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_with_limit_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.return_relations is not None:
            oprot.writeFieldBegin('return_relations', TType.BOOL, 7)
            oprot.writeBool(self.return_relations)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 8)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_with_limit_args)
query_neighbour_with_limit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
    (7, TType.BOOL, 'return_relations', None, None, ),  # 7
    (8, TType.I32, 'max_size', None, None, ),  # 8
)


class query_neighbour_with_limit_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_with_limit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_with_limit_result)
query_neighbour_with_limit_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class check_connectivity_args(object):
    """
    Attributes:
     - db_name
     - src_node_id
     - dest_node_id

    """


    def __init__(self, db_name=None, src_node_id=None, dest_node_id=None,):
        self.db_name = db_name
        self.src_node_id = src_node_id
        self.dest_node_id = dest_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.src_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dest_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_connectivity_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.src_node_id is not None:
            oprot.writeFieldBegin('src_node_id', TType.I32, 2)
            oprot.writeI32(self.src_node_id)
            oprot.writeFieldEnd()
        if self.dest_node_id is not None:
            oprot.writeFieldBegin('dest_node_id', TType.I32, 3)
            oprot.writeI32(self.dest_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_connectivity_args)
check_connectivity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'src_node_id', None, None, ),  # 2
    (3, TType.I32, 'dest_node_id', None, None, ),  # 3
)


class check_connectivity_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.bool_response()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_connectivity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_connectivity_result)
check_connectivity_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.bool_response, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_neighbour_for_studio_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, node_id=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_for_studio_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_for_studio_args)
query_neighbour_for_studio_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
)


class query_neighbour_for_studio_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_for_studio_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_for_studio_result)
query_neighbour_for_studio_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_common_neighbour_for_studio_args(object):
    """
    Attributes:
     - db_name
     - ids
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, ids=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.ids = ids
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype306, _size303) = iprot.readListBegin()
                    for _i307 in range(_size303):
                        _elem308 = iprot.readI32()
                        self.ids.append(_elem308)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_neighbour_for_studio_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter309 in self.ids:
                oprot.writeI32(iter309)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_neighbour_for_studio_args)
query_common_neighbour_for_studio_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
)


class query_common_neighbour_for_studio_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.common_neighbour_for_studio()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_neighbour_for_studio_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_neighbour_for_studio_result)
query_common_neighbour_for_studio_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.common_neighbour_for_studio, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_neighbour_path_for_studio_args(object):
    """
    Attributes:
     - db_name
     - search_direction
     - condition
     - nodes

    """


    def __init__(self, db_name=None, search_direction=None, condition=None, nodes=None,):
        self.db_name = db_name
        self.search_direction = search_direction
        self.condition = condition
        self.nodes = nodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.nodes = {}
                    (_ktype311, _vtype312, _size310) = iprot.readMapBegin()
                    for _i314 in range(_size310):
                        _key315 = iprot.readI32()
                        _val316 = []
                        (_etype320, _size317) = iprot.readListBegin()
                        for _i321 in range(_size317):
                            _elem322 = iprot.readI32()
                            _val316.append(_elem322)
                        iprot.readListEnd()
                        self.nodes[_key315] = _val316
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_path_for_studio_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 2)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 3)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.nodes is not None:
            oprot.writeFieldBegin('nodes', TType.MAP, 4)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.nodes))
            for kiter323, viter324 in self.nodes.items():
                oprot.writeI32(kiter323)
                oprot.writeListBegin(TType.I32, len(viter324))
                for iter325 in viter324:
                    oprot.writeI32(iter325)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_path_for_studio_args)
query_neighbour_path_for_studio_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'search_direction', None, None, ),  # 2
    (3, TType.STRING, 'condition', 'UTF8', None, ),  # 3
    (4, TType.MAP, 'nodes', (TType.I32, None, TType.LIST, (TType.I32, None, False), False), None, ),  # 4
)


class query_neighbour_path_for_studio_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.neighbour_path()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_path_for_studio_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_path_for_studio_result)
query_neighbour_path_for_studio_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.neighbour_path, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_subgraph_by_neighbour_for_studio_args(object):
    """
    Attributes:
     - db_name
     - node_id
     - k_min
     - k_max
     - search_direction
     - condition

    """


    def __init__(self, db_name=None, node_id=None, k_min=None, k_max=None, search_direction=None, condition=None,):
        self.db_name = db_name
        self.node_id = node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_by_neighbour_for_studio_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 3)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 4)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 6)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_by_neighbour_for_studio_args)
query_subgraph_by_neighbour_for_studio_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
    (3, TType.I32, 'k_min', None, None, ),  # 3
    (4, TType.I32, 'k_max', None, None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'condition', 'UTF8', None, ),  # 6
)


class query_subgraph_by_neighbour_for_studio_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.graph_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_by_neighbour_for_studio_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_by_neighbour_for_studio_result)
query_subgraph_by_neighbour_for_studio_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.graph_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_subgraph_by_node_for_studio_args(object):
    """
    Attributes:
     - db_name
     - ids

    """


    def __init__(self, db_name=None, ids=None,):
        self.db_name = db_name
        self.ids = ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype329, _size326) = iprot.readListBegin()
                    for _i330 in range(_size326):
                        _elem331 = iprot.readI32()
                        self.ids.append(_elem331)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_by_node_for_studio_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ids))
            for iter332 in self.ids:
                oprot.writeI32(iter332)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_by_node_for_studio_args)
query_subgraph_by_node_for_studio_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'ids', (TType.I32, None, False), None, ),  # 2
)


class query_subgraph_by_node_for_studio_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.graph_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_subgraph_by_node_for_studio_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_subgraph_by_node_for_studio_result)
query_subgraph_by_node_for_studio_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.graph_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_path_for_studio_args(object):
    """
    Attributes:
     - db_name
     - src_node_id
     - dest_node_id
     - k_min
     - k_max
     - search_direction
     - condition
     - max_size
     - query_type

    """


    def __init__(self, db_name=None, src_node_id=None, dest_node_id=None, k_min=None, k_max=None, search_direction=None, condition=None, max_size=None, query_type=None,):
        self.db_name = db_name
        self.src_node_id = src_node_id
        self.dest_node_id = dest_node_id
        self.k_min = k_min
        self.k_max = k_max
        self.search_direction = search_direction
        self.condition = condition
        self.max_size = max_size
        self.query_type = query_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.src_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dest_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.condition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.max_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.query_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_path_for_studio_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.src_node_id is not None:
            oprot.writeFieldBegin('src_node_id', TType.I32, 2)
            oprot.writeI32(self.src_node_id)
            oprot.writeFieldEnd()
        if self.dest_node_id is not None:
            oprot.writeFieldBegin('dest_node_id', TType.I32, 3)
            oprot.writeI32(self.dest_node_id)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 4)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 5)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 6)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.condition is not None:
            oprot.writeFieldBegin('condition', TType.STRING, 7)
            oprot.writeString(self.condition.encode('utf-8') if sys.version_info[0] == 2 else self.condition)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I32, 8)
            oprot.writeI32(self.max_size)
            oprot.writeFieldEnd()
        if self.query_type is not None:
            oprot.writeFieldBegin('query_type', TType.I32, 9)
            oprot.writeI32(self.query_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_path_for_studio_args)
query_path_for_studio_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'src_node_id', None, None, ),  # 2
    (3, TType.I32, 'dest_node_id', None, None, ),  # 3
    (4, TType.I32, 'k_min', None, None, ),  # 4
    (5, TType.I32, 'k_max', None, None, ),  # 5
    (6, TType.I32, 'search_direction', None, None, ),  # 6
    (7, TType.STRING, 'condition', 'UTF8', None, ),  # 7
    (8, TType.I32, 'max_size', None, None, ),  # 8
    (9, TType.I32, 'query_type', None, None, ),  # 9
)


class query_path_for_studio_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths_v2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_path_for_studio_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_path_for_studio_result)
query_path_for_studio_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths_v2, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_neighbour_with_prop_filter_args(object):
    """
    Attributes:
     - db_name
     - start_node
     - edge
     - end_node
     - search_direction
     - k_min
     - k_max

    """


    def __init__(self, db_name=None, start_node=None, edge=None, end_node=None, search_direction=None, k_min=None, k_max=None,):
        self.db_name = db_name
        self.start_node = start_node
        self.edge = edge
        self.end_node = end_node
        self.search_direction = search_direction
        self.k_min = k_min
        self.k_max = k_max

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.start_node = ezootypes.ttypes.node_filter()
                    self.start_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.edge = ezootypes.ttypes.edge_filter()
                    self.edge.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.end_node = ezootypes.ttypes.node_filter()
                    self.end_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_with_prop_filter_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.start_node is not None:
            oprot.writeFieldBegin('start_node', TType.STRUCT, 2)
            self.start_node.write(oprot)
            oprot.writeFieldEnd()
        if self.edge is not None:
            oprot.writeFieldBegin('edge', TType.STRUCT, 3)
            self.edge.write(oprot)
            oprot.writeFieldEnd()
        if self.end_node is not None:
            oprot.writeFieldBegin('end_node', TType.STRUCT, 4)
            self.end_node.write(oprot)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 6)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 7)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_with_prop_filter_args)
query_neighbour_with_prop_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'start_node', [ezootypes.ttypes.node_filter, None], None, ),  # 2
    (3, TType.STRUCT, 'edge', [ezootypes.ttypes.edge_filter, None], None, ),  # 3
    (4, TType.STRUCT, 'end_node', [ezootypes.ttypes.node_filter, None], None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.I32, 'k_min', None, None, ),  # 6
    (7, TType.I32, 'k_max', None, None, ),  # 7
)


class query_neighbour_with_prop_filter_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_with_prop_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_with_prop_filter_result)
query_neighbour_with_prop_filter_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_path_with_prop_filter_args(object):
    """
    Attributes:
     - db_name
     - start_node
     - edge
     - end_node
     - search_direction
     - k_min
     - k_max
     - distinct
     - max_size

    """


    def __init__(self, db_name=None, start_node=None, edge=None, end_node=None, search_direction=None, k_min=None, k_max=None, distinct=None, max_size=None,):
        self.db_name = db_name
        self.start_node = start_node
        self.edge = edge
        self.end_node = end_node
        self.search_direction = search_direction
        self.k_min = k_min
        self.k_max = k_max
        self.distinct = distinct
        self.max_size = max_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.start_node = ezootypes.ttypes.node_filter()
                    self.start_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.edge = ezootypes.ttypes.edge_filter()
                    self.edge.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.end_node = ezootypes.ttypes.node_filter()
                    self.end_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.distinct = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.max_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_path_with_prop_filter_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.start_node is not None:
            oprot.writeFieldBegin('start_node', TType.STRUCT, 2)
            self.start_node.write(oprot)
            oprot.writeFieldEnd()
        if self.edge is not None:
            oprot.writeFieldBegin('edge', TType.STRUCT, 3)
            self.edge.write(oprot)
            oprot.writeFieldEnd()
        if self.end_node is not None:
            oprot.writeFieldBegin('end_node', TType.STRUCT, 4)
            self.end_node.write(oprot)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 6)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 7)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.distinct is not None:
            oprot.writeFieldBegin('distinct', TType.I32, 8)
            oprot.writeI32(self.distinct)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I64, 9)
            oprot.writeI64(self.max_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_path_with_prop_filter_args)
query_path_with_prop_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'start_node', [ezootypes.ttypes.node_filter, None], None, ),  # 2
    (3, TType.STRUCT, 'edge', [ezootypes.ttypes.edge_filter, None], None, ),  # 3
    (4, TType.STRUCT, 'end_node', [ezootypes.ttypes.node_filter, None], None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.I32, 'k_min', None, None, ),  # 6
    (7, TType.I32, 'k_max', None, None, ),  # 7
    (8, TType.I32, 'distinct', None, None, ),  # 8
    (9, TType.I64, 'max_size', None, None, ),  # 9
)


class query_path_with_prop_filter_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_path_with_prop_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_path_with_prop_filter_result)
query_path_with_prop_filter_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_neighbour_with_edge_filter_args(object):
    """
    Attributes:
     - db_name
     - start_node
     - edge_type
     - is_valid_edge
     - end_node
     - search_direction

    """


    def __init__(self, db_name=None, start_node=None, edge_type=None, is_valid_edge=None, end_node=None, search_direction=None,):
        self.db_name = db_name
        self.start_node = start_node
        self.edge_type = edge_type
        self.is_valid_edge = is_valid_edge
        self.end_node = end_node
        self.search_direction = search_direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.start_node = ezootypes.ttypes.node_filter()
                    self.start_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.edge_type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_valid_edge = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.end_node = ezootypes.ttypes.node_filter()
                    self.end_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_with_edge_filter_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.start_node is not None:
            oprot.writeFieldBegin('start_node', TType.STRUCT, 2)
            self.start_node.write(oprot)
            oprot.writeFieldEnd()
        if self.edge_type is not None:
            oprot.writeFieldBegin('edge_type', TType.STRING, 3)
            oprot.writeString(self.edge_type.encode('utf-8') if sys.version_info[0] == 2 else self.edge_type)
            oprot.writeFieldEnd()
        if self.is_valid_edge is not None:
            oprot.writeFieldBegin('is_valid_edge', TType.BOOL, 4)
            oprot.writeBool(self.is_valid_edge)
            oprot.writeFieldEnd()
        if self.end_node is not None:
            oprot.writeFieldBegin('end_node', TType.STRUCT, 5)
            self.end_node.write(oprot)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 6)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_with_edge_filter_args)
query_neighbour_with_edge_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'start_node', [ezootypes.ttypes.node_filter, None], None, ),  # 2
    (3, TType.STRING, 'edge_type', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'is_valid_edge', None, None, ),  # 4
    (5, TType.STRUCT, 'end_node', [ezootypes.ttypes.node_filter, None], None, ),  # 5
    (6, TType.I32, 'search_direction', None, None, ),  # 6
)


class query_neighbour_with_edge_filter_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.one_neighbour_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_with_edge_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_with_edge_filter_result)
query_neighbour_with_edge_filter_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.one_neighbour_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class count_neighbour_with_prop_filter_args(object):
    """
    Attributes:
     - db_name
     - start_node
     - edge
     - end_node_type
     - end_node_order_prop_name
     - search_direction
     - k_min
     - k_max

    """


    def __init__(self, db_name=None, start_node=None, edge=None, end_node_type=None, end_node_order_prop_name=None, search_direction=None, k_min=None, k_max=None,):
        self.db_name = db_name
        self.start_node = start_node
        self.edge = edge
        self.end_node_type = end_node_type
        self.end_node_order_prop_name = end_node_order_prop_name
        self.search_direction = search_direction
        self.k_min = k_min
        self.k_max = k_max

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.start_node = ezootypes.ttypes.node_filter()
                    self.start_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.edge = ezootypes.ttypes.edge_filter()
                    self.edge.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.end_node_type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.end_node_order_prop_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.k_min = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('count_neighbour_with_prop_filter_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.start_node is not None:
            oprot.writeFieldBegin('start_node', TType.STRUCT, 2)
            self.start_node.write(oprot)
            oprot.writeFieldEnd()
        if self.edge is not None:
            oprot.writeFieldBegin('edge', TType.STRUCT, 3)
            self.edge.write(oprot)
            oprot.writeFieldEnd()
        if self.end_node_type is not None:
            oprot.writeFieldBegin('end_node_type', TType.STRING, 4)
            oprot.writeString(self.end_node_type.encode('utf-8') if sys.version_info[0] == 2 else self.end_node_type)
            oprot.writeFieldEnd()
        if self.end_node_order_prop_name is not None:
            oprot.writeFieldBegin('end_node_order_prop_name', TType.STRING, 5)
            oprot.writeString(self.end_node_order_prop_name.encode('utf-8') if sys.version_info[0] == 2 else self.end_node_order_prop_name)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 6)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.k_min is not None:
            oprot.writeFieldBegin('k_min', TType.I32, 7)
            oprot.writeI32(self.k_min)
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 8)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(count_neighbour_with_prop_filter_args)
count_neighbour_with_prop_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'start_node', [ezootypes.ttypes.node_filter, None], None, ),  # 2
    (3, TType.STRUCT, 'edge', [ezootypes.ttypes.edge_filter, None], None, ),  # 3
    (4, TType.STRING, 'end_node_type', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'end_node_order_prop_name', 'UTF8', None, ),  # 5
    (6, TType.I32, 'search_direction', None, None, ),  # 6
    (7, TType.I32, 'k_min', None, None, ),  # 7
    (8, TType.I32, 'k_max', None, None, ),  # 8
)


class count_neighbour_with_prop_filter_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.count_neighbour_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('count_neighbour_with_prop_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(count_neighbour_with_prop_filter_result)
count_neighbour_with_prop_filter_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.count_neighbour_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_neighbour_with_multi_edge_filter_args(object):
    """
    Attributes:
     - db_name
     - start_node
     - edge_type_list
     - end_node
     - search_direction

    """


    def __init__(self, db_name=None, start_node=None, edge_type_list=None, end_node=None, search_direction=None,):
        self.db_name = db_name
        self.start_node = start_node
        self.edge_type_list = edge_type_list
        self.end_node = end_node
        self.search_direction = search_direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.start_node = ezootypes.ttypes.node_filter()
                    self.start_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.edge_type_list = []
                    (_etype336, _size333) = iprot.readListBegin()
                    for _i337 in range(_size333):
                        _elem338 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.edge_type_list.append(_elem338)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.end_node = ezootypes.ttypes.node_filter()
                    self.end_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_with_multi_edge_filter_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.start_node is not None:
            oprot.writeFieldBegin('start_node', TType.STRUCT, 2)
            self.start_node.write(oprot)
            oprot.writeFieldEnd()
        if self.edge_type_list is not None:
            oprot.writeFieldBegin('edge_type_list', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.edge_type_list))
            for iter339 in self.edge_type_list:
                oprot.writeString(iter339.encode('utf-8') if sys.version_info[0] == 2 else iter339)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.end_node is not None:
            oprot.writeFieldBegin('end_node', TType.STRUCT, 4)
            self.end_node.write(oprot)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_with_multi_edge_filter_args)
query_neighbour_with_multi_edge_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'start_node', [ezootypes.ttypes.node_filter, None], None, ),  # 2
    (3, TType.LIST, 'edge_type_list', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'end_node', [ezootypes.ttypes.node_filter, None], None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
)


class query_neighbour_with_multi_edge_filter_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.one_neighbour_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_neighbour_with_multi_edge_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_neighbour_with_multi_edge_filter_result)
query_neighbour_with_multi_edge_filter_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.one_neighbour_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class query_common_relation_args(object):
    """
    Attributes:
     - db_name
     - node_list
     - k_max
     - search_direction
     - distinct
     - max_size

    """


    def __init__(self, db_name=None, node_list=None, k_max=None, search_direction=None, distinct=None, max_size=None,):
        self.db_name = db_name
        self.node_list = node_list
        self.k_max = k_max
        self.search_direction = search_direction
        self.distinct = distinct
        self.max_size = max_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.node_list = []
                    (_etype343, _size340) = iprot.readListBegin()
                    for _i344 in range(_size340):
                        _elem345 = ezootypes.ttypes.node_filter()
                        _elem345.read(iprot)
                        self.node_list.append(_elem345)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.k_max = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.distinct = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.max_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_relation_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.node_list is not None:
            oprot.writeFieldBegin('node_list', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.node_list))
            for iter346 in self.node_list:
                iter346.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.k_max is not None:
            oprot.writeFieldBegin('k_max', TType.I32, 3)
            oprot.writeI32(self.k_max)
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 4)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.distinct is not None:
            oprot.writeFieldBegin('distinct', TType.I32, 5)
            oprot.writeI32(self.distinct)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I64, 6)
            oprot.writeI64(self.max_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_relation_args)
query_common_relation_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'node_list', (TType.STRUCT, [ezootypes.ttypes.node_filter, None], False), None, ),  # 2
    (3, TType.I32, 'k_max', None, None, ),  # 3
    (4, TType.I32, 'search_direction', None, None, ),  # 4
    (5, TType.I32, 'distinct', None, None, ),  # 5
    (6, TType.I64, 'max_size', None, None, ),  # 6
)


class query_common_relation_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.paths_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_common_relation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_common_relation_result)
query_common_relation_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.paths_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)


class count_one_neighbour_relations_top_k_args(object):
    """
    Attributes:
     - db_name
     - start_node_type
     - edge_type_set
     - end_node_type_set
     - search_direction
     - output_prop
     - top_k
     - is_desc

    """


    def __init__(self, db_name=None, start_node_type=None, edge_type_set=None, end_node_type_set=None, search_direction=None, output_prop=None, top_k=None, is_desc=None,):
        self.db_name = db_name
        self.start_node_type = start_node_type
        self.edge_type_set = edge_type_set
        self.end_node_type_set = end_node_type_set
        self.search_direction = search_direction
        self.output_prop = output_prop
        self.top_k = top_k
        self.is_desc = is_desc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.start_node_type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.edge_type_set = set()
                    (_etype350, _size347) = iprot.readSetBegin()
                    for _i351 in range(_size347):
                        _elem352 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.edge_type_set.add(_elem352)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.end_node_type_set = set()
                    (_etype356, _size353) = iprot.readSetBegin()
                    for _i357 in range(_size353):
                        _elem358 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.end_node_type_set.add(_elem358)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.search_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.output_prop = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.top_k = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.is_desc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('count_one_neighbour_relations_top_k_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.start_node_type is not None:
            oprot.writeFieldBegin('start_node_type', TType.STRING, 2)
            oprot.writeString(self.start_node_type.encode('utf-8') if sys.version_info[0] == 2 else self.start_node_type)
            oprot.writeFieldEnd()
        if self.edge_type_set is not None:
            oprot.writeFieldBegin('edge_type_set', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.edge_type_set))
            for iter359 in self.edge_type_set:
                oprot.writeString(iter359.encode('utf-8') if sys.version_info[0] == 2 else iter359)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.end_node_type_set is not None:
            oprot.writeFieldBegin('end_node_type_set', TType.SET, 4)
            oprot.writeSetBegin(TType.STRING, len(self.end_node_type_set))
            for iter360 in self.end_node_type_set:
                oprot.writeString(iter360.encode('utf-8') if sys.version_info[0] == 2 else iter360)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.search_direction is not None:
            oprot.writeFieldBegin('search_direction', TType.I32, 5)
            oprot.writeI32(self.search_direction)
            oprot.writeFieldEnd()
        if self.output_prop is not None:
            oprot.writeFieldBegin('output_prop', TType.STRING, 6)
            oprot.writeString(self.output_prop.encode('utf-8') if sys.version_info[0] == 2 else self.output_prop)
            oprot.writeFieldEnd()
        if self.top_k is not None:
            oprot.writeFieldBegin('top_k', TType.I32, 7)
            oprot.writeI32(self.top_k)
            oprot.writeFieldEnd()
        if self.is_desc is not None:
            oprot.writeFieldBegin('is_desc', TType.BOOL, 8)
            oprot.writeBool(self.is_desc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(count_one_neighbour_relations_top_k_args)
count_one_neighbour_relations_top_k_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'start_node_type', 'UTF8', None, ),  # 2
    (3, TType.SET, 'edge_type_set', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.SET, 'end_node_type_set', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I32, 'search_direction', None, None, ),  # 5
    (6, TType.STRING, 'output_prop', 'UTF8', None, ),  # 6
    (7, TType.I32, 'top_k', None, None, ),  # 7
    (8, TType.BOOL, 'is_desc', None, None, ),  # 8
)


class count_one_neighbour_relations_top_k_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ezootypes.ttypes.count_neighbour_l1()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ezoocommon.ttypes.ezoo_exception.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('count_one_neighbour_relations_top_k_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(count_one_neighbour_relations_top_k_result)
count_one_neighbour_relations_top_k_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ezootypes.ttypes.count_neighbour_l1, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ezoocommon.ttypes.ezoo_exception, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
