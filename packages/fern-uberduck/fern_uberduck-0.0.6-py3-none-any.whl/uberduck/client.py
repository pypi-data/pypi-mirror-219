# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic
import typing_extensions

from .core.api_error import ApiError
from .core.jsonable_encoder import jsonable_encoder
from .core.remove_none_from_headers import remove_none_from_headers
from .environment import UberduckEnvironment
from .errors.unprocessable_entity_error import UnprocessableEntityError
from .resources.backing_tracks.client import AsyncBackingTracksClient, BackingTracksClient
from .resources.reference_audios.client import AsyncReferenceAudiosClient, ReferenceAudiosClient
from .types.convert_english_to_ipa_phonemes_request_phones import ConvertEnglishToIpaPhonemesRequestPhones
from .types.dataset_speaker import DatasetSpeaker
from .types.freestyle_request_backing_track import FreestyleRequestBackingTrack
from .types.g_2_p_response import G2PResponse
from .types.get_voice_data_request_mode import GetVoiceDataRequestMode
from .types.get_voices_request_mode import GetVoicesRequestMode
from .types.http_validation_error import HttpValidationError
from .types.mix_item import MixItem
from .types.sample import Sample
from .types.speak_status_response import SpeakStatusResponse
from .types.tts_request import TtsRequest
from .types.uuid import Uuid
from .types.voice_return import VoiceReturn
from .types.voice_stats import VoiceStats

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class Uberduck:
    def __init__(
        self, *, environment: UberduckEnvironment = UberduckEnvironment.PRODUCTION, token: typing.Optional[str] = None
    ):
        self._environment = environment
        self._token = token
        self.reference_audios = ReferenceAudiosClient(environment=self._environment, token=self._token)
        self.backing_tracks = BackingTracksClient(environment=self._environment, token=self._token)

    def get_voices(
        self,
        *,
        mode: GetVoicesRequestMode,
        language: typing.Optional[str] = None,
        is_commercial: typing.Optional[bool] = None,
        is_private: typing.Optional[bool] = None,
        slim: typing.Optional[bool] = None,
    ) -> typing.List[VoiceReturn]:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", "voices"),
            params={
                "mode": mode,
                "language": language,
                "is_commercial": is_commercial,
                "is_private": is_private,
                "slim": slim,
            },
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[VoiceReturn], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_voice_detail(self, voicemodel_uuid: str) -> VoiceReturn:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"voices/{voicemodel_uuid}/detail"),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VoiceReturn, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fetch_voice_samples(self, voicemodel_uuid: str) -> typing.List[Sample]:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"voices/{voicemodel_uuid}/samples"),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Sample], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_lyrics(
        self,
        *,
        subject: typing.Optional[str] = OMIT,
        lines: typing.Optional[int] = OMIT,
        backing_track: typing.Optional[str] = OMIT,
        generate_title: typing.Optional[bool] = OMIT,
    ) -> typing.Any:
        _request: typing.Dict[str, typing.Any] = {}
        if subject is not OMIT:
            _request["subject"] = subject
        if lines is not OMIT:
            _request["lines"] = lines
        if backing_track is not OMIT:
            _request["backing_track"] = backing_track
        if generate_title is not OMIT:
            _request["generate_title"] = generate_title
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "tts/lyrics"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_freestyle(
        self,
        *,
        subject: typing.Optional[str] = OMIT,
        lines: typing.Optional[int] = OMIT,
        lyrics: typing.Optional[typing.List[typing.List[str]]] = OMIT,
        bpm: typing.Optional[float] = OMIT,
        backing_track: typing.Optional[FreestyleRequestBackingTrack] = OMIT,
        voice: typing.Optional[str] = OMIT,
        voicemodel_uuid: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        format: typing.Optional[typing_extensions.Literal["json"]] = OMIT,
        generate_title: typing.Optional[bool] = OMIT,
    ) -> typing.Any:
        _request: typing.Dict[str, typing.Any] = {}
        if subject is not OMIT:
            _request["subject"] = subject
        if lines is not OMIT:
            _request["lines"] = lines
        if lyrics is not OMIT:
            _request["lyrics"] = lyrics
        if bpm is not OMIT:
            _request["bpm"] = bpm
        if backing_track is not OMIT:
            _request["backing_track"] = backing_track
        if voice is not OMIT:
            _request["voice"] = voice
        if voicemodel_uuid is not OMIT:
            _request["voicemodel_uuid"] = voicemodel_uuid
        if title is not OMIT:
            _request["title"] = title
        if format is not OMIT:
            _request["format"] = format
        if generate_title is not OMIT:
            _request["generate_title"] = generate_title
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "tts/freestyle"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def do_voice_to_voice_conversion(
        self,
        *,
        voicemodel_uuid: str,
        input: typing.Optional[str] = OMIT,
        reference_audio_uuid: typing.Optional[str] = OMIT,
        pitch_shift: typing.Optional[int] = OMIT,
        mix: typing.Optional[typing.List[MixItem]] = OMIT,
    ) -> typing.Any:
        _request: typing.Dict[str, typing.Any] = {"voicemodel_uuid": voicemodel_uuid}
        if input is not OMIT:
            _request["input"] = input
        if reference_audio_uuid is not OMIT:
            _request["reference_audio_uuid"] = reference_audio_uuid
        if pitch_shift is not OMIT:
            _request["pitch_shift"] = pitch_shift
        if mix is not OMIT:
            _request["mix"] = mix
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "tts/convert"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def train(
        self,
        *,
        name: typing.Optional[str] = OMIT,
        model_type: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        base_model_uuid: typing.Optional[str] = OMIT,
        data: typing.Optional[typing.List[DatasetSpeaker]] = OMIT,
        device_count: typing.Optional[int] = OMIT,
        rank: typing.Optional[int] = OMIT,
        epochs: typing.Optional[int] = OMIT,
        batch_size: typing.Optional[int] = OMIT,
        learning_rate: typing.Optional[float] = OMIT,
        ignored_layers: typing.Optional[typing.List[str]] = OMIT,
        save_on_finish: typing.Optional[bool] = OMIT,
        is_cleaned: typing.Optional[bool] = OMIT,
        epochs_per_checkpoint: typing.Optional[int] = OMIT,
        is_torchmoji: typing.Optional[bool] = OMIT,
        is_multispeaker: typing.Optional[bool] = OMIT,
        is_speaker_encoder: typing.Optional[bool] = OMIT,
    ) -> typing.Any:
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if model_type is not OMIT:
            _request["model_type"] = model_type
        if description is not OMIT:
            _request["description"] = description
        if base_model_uuid is not OMIT:
            _request["base_model_uuid"] = base_model_uuid
        if data is not OMIT:
            _request["data"] = data
        if device_count is not OMIT:
            _request["device_count"] = device_count
        if rank is not OMIT:
            _request["rank"] = rank
        if epochs is not OMIT:
            _request["epochs"] = epochs
        if batch_size is not OMIT:
            _request["batch_size"] = batch_size
        if learning_rate is not OMIT:
            _request["learning_rate"] = learning_rate
        if ignored_layers is not OMIT:
            _request["ignored_layers"] = ignored_layers
        if save_on_finish is not OMIT:
            _request["save_on_finish"] = save_on_finish
        if is_cleaned is not OMIT:
            _request["is_cleaned"] = is_cleaned
        if epochs_per_checkpoint is not OMIT:
            _request["epochs_per_checkpoint"] = epochs_per_checkpoint
        if is_torchmoji is not OMIT:
            _request["is_torchmoji"] = is_torchmoji
        if is_multispeaker is not OMIT:
            _request["is_multispeaker"] = is_multispeaker
        if is_speaker_encoder is not OMIT:
            _request["is_speaker_encoder"] = is_speaker_encoder
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "train"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_speak_status(self, *, uuid: str) -> SpeakStatusResponse:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", "speak-status"),
            params={"uuid": uuid},
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SpeakStatusResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_speech(self, *, request: TtsRequest, uberduck_id: typing.Optional[str] = None) -> Uuid:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "speak"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers(
                {
                    "uberduck-id": uberduck_id,
                    "Authorization": f"Bearer {self._token}" if self._token is not None else None,
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Uuid, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_speech_synchronously(self, *, request: TtsRequest, uberduck_id: typing.Optional[str] = None) -> None:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "speak-synchronous"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers(
                {
                    "uberduck-id": uberduck_id,
                    "Authorization": f"Bearer {self._token}" if self._token is not None else None,
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_voice_stats(
        self,
        *,
        username: typing.Optional[str] = None,
        voicemodel_uuid: typing.Union[typing.Optional[str], typing.List[str]],
    ) -> typing.List[VoiceStats]:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", "voice-stats"),
            params={"username": username, "voicemodel_uuid": voicemodel_uuid},
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[VoiceStats], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_voice_data(
        self,
        *,
        name: str,
        architecture: typing.Optional[str] = None,
        mode: typing.Optional[GetVoiceDataRequestMode] = None,
    ) -> VoiceReturn:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", "voice-data"),
            params={"name": name, "architecture": architecture, "mode": mode},
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VoiceReturn, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def convert_english_to_ipa_phonemes(
        self, *, text: str, phones: typing.Optional[ConvertEnglishToIpaPhonemesRequestPhones] = None
    ) -> G2PResponse:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", "g2p"),
            params={"text": text, "phones": phones},
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(G2PResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncUberduck:
    def __init__(
        self, *, environment: UberduckEnvironment = UberduckEnvironment.PRODUCTION, token: typing.Optional[str] = None
    ):
        self._environment = environment
        self._token = token
        self.reference_audios = AsyncReferenceAudiosClient(environment=self._environment, token=self._token)
        self.backing_tracks = AsyncBackingTracksClient(environment=self._environment, token=self._token)

    async def get_voices(
        self,
        *,
        mode: GetVoicesRequestMode,
        language: typing.Optional[str] = None,
        is_commercial: typing.Optional[bool] = None,
        is_private: typing.Optional[bool] = None,
        slim: typing.Optional[bool] = None,
    ) -> typing.List[VoiceReturn]:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", "voices"),
                params={
                    "mode": mode,
                    "language": language,
                    "is_commercial": is_commercial,
                    "is_private": is_private,
                    "slim": slim,
                },
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[VoiceReturn], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_voice_detail(self, voicemodel_uuid: str) -> VoiceReturn:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"voices/{voicemodel_uuid}/detail"),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VoiceReturn, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fetch_voice_samples(self, voicemodel_uuid: str) -> typing.List[Sample]:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"voices/{voicemodel_uuid}/samples"),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Sample], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_lyrics(
        self,
        *,
        subject: typing.Optional[str] = OMIT,
        lines: typing.Optional[int] = OMIT,
        backing_track: typing.Optional[str] = OMIT,
        generate_title: typing.Optional[bool] = OMIT,
    ) -> typing.Any:
        _request: typing.Dict[str, typing.Any] = {}
        if subject is not OMIT:
            _request["subject"] = subject
        if lines is not OMIT:
            _request["lines"] = lines
        if backing_track is not OMIT:
            _request["backing_track"] = backing_track
        if generate_title is not OMIT:
            _request["generate_title"] = generate_title
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "tts/lyrics"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_freestyle(
        self,
        *,
        subject: typing.Optional[str] = OMIT,
        lines: typing.Optional[int] = OMIT,
        lyrics: typing.Optional[typing.List[typing.List[str]]] = OMIT,
        bpm: typing.Optional[float] = OMIT,
        backing_track: typing.Optional[FreestyleRequestBackingTrack] = OMIT,
        voice: typing.Optional[str] = OMIT,
        voicemodel_uuid: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        format: typing.Optional[typing_extensions.Literal["json"]] = OMIT,
        generate_title: typing.Optional[bool] = OMIT,
    ) -> typing.Any:
        _request: typing.Dict[str, typing.Any] = {}
        if subject is not OMIT:
            _request["subject"] = subject
        if lines is not OMIT:
            _request["lines"] = lines
        if lyrics is not OMIT:
            _request["lyrics"] = lyrics
        if bpm is not OMIT:
            _request["bpm"] = bpm
        if backing_track is not OMIT:
            _request["backing_track"] = backing_track
        if voice is not OMIT:
            _request["voice"] = voice
        if voicemodel_uuid is not OMIT:
            _request["voicemodel_uuid"] = voicemodel_uuid
        if title is not OMIT:
            _request["title"] = title
        if format is not OMIT:
            _request["format"] = format
        if generate_title is not OMIT:
            _request["generate_title"] = generate_title
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "tts/freestyle"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def do_voice_to_voice_conversion(
        self,
        *,
        voicemodel_uuid: str,
        input: typing.Optional[str] = OMIT,
        reference_audio_uuid: typing.Optional[str] = OMIT,
        pitch_shift: typing.Optional[int] = OMIT,
        mix: typing.Optional[typing.List[MixItem]] = OMIT,
    ) -> typing.Any:
        _request: typing.Dict[str, typing.Any] = {"voicemodel_uuid": voicemodel_uuid}
        if input is not OMIT:
            _request["input"] = input
        if reference_audio_uuid is not OMIT:
            _request["reference_audio_uuid"] = reference_audio_uuid
        if pitch_shift is not OMIT:
            _request["pitch_shift"] = pitch_shift
        if mix is not OMIT:
            _request["mix"] = mix
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "tts/convert"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def train(
        self,
        *,
        name: typing.Optional[str] = OMIT,
        model_type: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        base_model_uuid: typing.Optional[str] = OMIT,
        data: typing.Optional[typing.List[DatasetSpeaker]] = OMIT,
        device_count: typing.Optional[int] = OMIT,
        rank: typing.Optional[int] = OMIT,
        epochs: typing.Optional[int] = OMIT,
        batch_size: typing.Optional[int] = OMIT,
        learning_rate: typing.Optional[float] = OMIT,
        ignored_layers: typing.Optional[typing.List[str]] = OMIT,
        save_on_finish: typing.Optional[bool] = OMIT,
        is_cleaned: typing.Optional[bool] = OMIT,
        epochs_per_checkpoint: typing.Optional[int] = OMIT,
        is_torchmoji: typing.Optional[bool] = OMIT,
        is_multispeaker: typing.Optional[bool] = OMIT,
        is_speaker_encoder: typing.Optional[bool] = OMIT,
    ) -> typing.Any:
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if model_type is not OMIT:
            _request["model_type"] = model_type
        if description is not OMIT:
            _request["description"] = description
        if base_model_uuid is not OMIT:
            _request["base_model_uuid"] = base_model_uuid
        if data is not OMIT:
            _request["data"] = data
        if device_count is not OMIT:
            _request["device_count"] = device_count
        if rank is not OMIT:
            _request["rank"] = rank
        if epochs is not OMIT:
            _request["epochs"] = epochs
        if batch_size is not OMIT:
            _request["batch_size"] = batch_size
        if learning_rate is not OMIT:
            _request["learning_rate"] = learning_rate
        if ignored_layers is not OMIT:
            _request["ignored_layers"] = ignored_layers
        if save_on_finish is not OMIT:
            _request["save_on_finish"] = save_on_finish
        if is_cleaned is not OMIT:
            _request["is_cleaned"] = is_cleaned
        if epochs_per_checkpoint is not OMIT:
            _request["epochs_per_checkpoint"] = epochs_per_checkpoint
        if is_torchmoji is not OMIT:
            _request["is_torchmoji"] = is_torchmoji
        if is_multispeaker is not OMIT:
            _request["is_multispeaker"] = is_multispeaker
        if is_speaker_encoder is not OMIT:
            _request["is_speaker_encoder"] = is_speaker_encoder
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "train"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_speak_status(self, *, uuid: str) -> SpeakStatusResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", "speak-status"),
                params={"uuid": uuid},
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SpeakStatusResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_speech(self, *, request: TtsRequest, uberduck_id: typing.Optional[str] = None) -> Uuid:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "speak"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers(
                    {
                        "uberduck-id": uberduck_id,
                        "Authorization": f"Bearer {self._token}" if self._token is not None else None,
                    }
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Uuid, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_speech_synchronously(
        self, *, request: TtsRequest, uberduck_id: typing.Optional[str] = None
    ) -> None:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "speak-synchronous"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers(
                    {
                        "uberduck-id": uberduck_id,
                        "Authorization": f"Bearer {self._token}" if self._token is not None else None,
                    }
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_voice_stats(
        self,
        *,
        username: typing.Optional[str] = None,
        voicemodel_uuid: typing.Union[typing.Optional[str], typing.List[str]],
    ) -> typing.List[VoiceStats]:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", "voice-stats"),
                params={"username": username, "voicemodel_uuid": voicemodel_uuid},
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[VoiceStats], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_voice_data(
        self,
        *,
        name: str,
        architecture: typing.Optional[str] = None,
        mode: typing.Optional[GetVoiceDataRequestMode] = None,
    ) -> VoiceReturn:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", "voice-data"),
                params={"name": name, "architecture": architecture, "mode": mode},
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VoiceReturn, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def convert_english_to_ipa_phonemes(
        self, *, text: str, phones: typing.Optional[ConvertEnglishToIpaPhonemesRequestPhones] = None
    ) -> G2PResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", "g2p"),
                params={"text": text, "phones": phones},
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(G2PResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
