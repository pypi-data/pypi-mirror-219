# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['LogExportConfigArgs', 'LogExportConfig']

@pulumi.input_type
class LogExportConfigArgs:
    def __init__(__self__, *,
                 auth_principal: pulumi.Input[str],
                 log_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]] = None,
                 redact: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a LogExportConfig resource.
        :param pulumi.Input[str] auth_principal: Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP Project ID that the cluster service account has permissions to write to for cloud logging
        :param pulumi.Input[str] log_name: An identifier for the logs in the customer's log sink
        :param pulumi.Input[str] type: The cloud selection that we're exporting to along with the cloud logging platform. Possible values are `GCP_CLOUD_LOGGING` or `AWS_CLOUDWATCH`
        :param pulumi.Input[bool] redact: Controls whether logs are redacted before forwarding to customer sinks
        :param pulumi.Input[str] region: Controls whether all logs are sent to a specific region in the customer sink
        """
        pulumi.set(__self__, "auth_principal", auth_principal)
        pulumi.set(__self__, "log_name", log_name)
        pulumi.set(__self__, "type", type)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="authPrincipal")
    def auth_principal(self) -> pulumi.Input[str]:
        """
        Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP Project ID that the cluster service account has permissions to write to for cloud logging
        """
        return pulumi.get(self, "auth_principal")

    @auth_principal.setter
    def auth_principal(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_principal", value)

    @property
    @pulumi.getter(name="logName")
    def log_name(self) -> pulumi.Input[str]:
        """
        An identifier for the logs in the customer's log sink
        """
        return pulumi.get(self, "log_name")

    @log_name.setter
    def log_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The cloud selection that we're exporting to along with the cloud logging platform. Possible values are `GCP_CLOUD_LOGGING` or `AWS_CLOUDWATCH`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def redact(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether logs are redacted before forwarding to customer sinks
        """
        return pulumi.get(self, "redact")

    @redact.setter
    def redact(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redact", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Controls whether all logs are sent to a specific region in the customer sink
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class _LogExportConfigState:
    def __init__(__self__, *,
                 auth_principal: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]] = None,
                 log_name: Optional[pulumi.Input[str]] = None,
                 redact: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None,
                 user_message: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering LogExportConfig resources.
        :param pulumi.Input[str] auth_principal: Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP Project ID that the cluster service account has permissions to write to for cloud logging
        :param pulumi.Input[str] log_name: An identifier for the logs in the customer's log sink
        :param pulumi.Input[bool] redact: Controls whether logs are redacted before forwarding to customer sinks
        :param pulumi.Input[str] region: Controls whether all logs are sent to a specific region in the customer sink
        :param pulumi.Input[str] type: The cloud selection that we're exporting to along with the cloud logging platform. Possible values are `GCP_CLOUD_LOGGING` or `AWS_CLOUDWATCH`
        """
        if auth_principal is not None:
            pulumi.set(__self__, "auth_principal", auth_principal)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if log_name is not None:
            pulumi.set(__self__, "log_name", log_name)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if user_message is not None:
            pulumi.set(__self__, "user_message", user_message)

    @property
    @pulumi.getter(name="authPrincipal")
    def auth_principal(self) -> Optional[pulumi.Input[str]]:
        """
        Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP Project ID that the cluster service account has permissions to write to for cloud logging
        """
        return pulumi.get(self, "auth_principal")

    @auth_principal.setter
    def auth_principal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_principal", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="logName")
    def log_name(self) -> Optional[pulumi.Input[str]]:
        """
        An identifier for the logs in the customer's log sink
        """
        return pulumi.get(self, "log_name")

    @log_name.setter
    def log_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_name", value)

    @property
    @pulumi.getter
    def redact(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether logs are redacted before forwarding to customer sinks
        """
        return pulumi.get(self, "redact")

    @redact.setter
    def redact(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redact", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Controls whether all logs are sent to a specific region in the customer sink
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud selection that we're exporting to along with the cloud logging platform. Possible values are `GCP_CLOUD_LOGGING` or `AWS_CLOUDWATCH`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="userMessage")
    def user_message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user_message")

    @user_message.setter
    def user_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_message", value)


class LogExportConfig(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 auth_principal: Optional[pulumi.Input[str]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LogExportConfigGroupArgs']]]]] = None,
                 log_name: Optional[pulumi.Input[str]] = None,
                 redact: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        Log Export Config Resource

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] auth_principal: Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP Project ID that the cluster service account has permissions to write to for cloud logging
        :param pulumi.Input[str] log_name: An identifier for the logs in the customer's log sink
        :param pulumi.Input[bool] redact: Controls whether logs are redacted before forwarding to customer sinks
        :param pulumi.Input[str] region: Controls whether all logs are sent to a specific region in the customer sink
        :param pulumi.Input[str] type: The cloud selection that we're exporting to along with the cloud logging platform. Possible values are `GCP_CLOUD_LOGGING` or `AWS_CLOUDWATCH`
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: LogExportConfigArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Log Export Config Resource

        :param str resource_name: The name of the resource.
        :param LogExportConfigArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(LogExportConfigArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 auth_principal: Optional[pulumi.Input[str]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LogExportConfigGroupArgs']]]]] = None,
                 log_name: Optional[pulumi.Input[str]] = None,
                 redact: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = LogExportConfigArgs.__new__(LogExportConfigArgs)

            if auth_principal is None and not opts.urn:
                raise TypeError("Missing required property 'auth_principal'")
            __props__.__dict__["auth_principal"] = auth_principal
            __props__.__dict__["groups"] = groups
            if log_name is None and not opts.urn:
                raise TypeError("Missing required property 'log_name'")
            __props__.__dict__["log_name"] = log_name
            __props__.__dict__["redact"] = redact
            __props__.__dict__["region"] = region
            if type is None and not opts.urn:
                raise TypeError("Missing required property 'type'")
            __props__.__dict__["type"] = type
            __props__.__dict__["created_at"] = None
            __props__.__dict__["status"] = None
            __props__.__dict__["updated_at"] = None
            __props__.__dict__["user_message"] = None
        super(LogExportConfig, __self__).__init__(
            'cockroach:index/logExportConfig:LogExportConfig',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            auth_principal: Optional[pulumi.Input[str]] = None,
            created_at: Optional[pulumi.Input[str]] = None,
            groups: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LogExportConfigGroupArgs']]]]] = None,
            log_name: Optional[pulumi.Input[str]] = None,
            redact: Optional[pulumi.Input[bool]] = None,
            region: Optional[pulumi.Input[str]] = None,
            status: Optional[pulumi.Input[str]] = None,
            type: Optional[pulumi.Input[str]] = None,
            updated_at: Optional[pulumi.Input[str]] = None,
            user_message: Optional[pulumi.Input[str]] = None) -> 'LogExportConfig':
        """
        Get an existing LogExportConfig resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] auth_principal: Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP Project ID that the cluster service account has permissions to write to for cloud logging
        :param pulumi.Input[str] log_name: An identifier for the logs in the customer's log sink
        :param pulumi.Input[bool] redact: Controls whether logs are redacted before forwarding to customer sinks
        :param pulumi.Input[str] region: Controls whether all logs are sent to a specific region in the customer sink
        :param pulumi.Input[str] type: The cloud selection that we're exporting to along with the cloud logging platform. Possible values are `GCP_CLOUD_LOGGING` or `AWS_CLOUDWATCH`
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _LogExportConfigState.__new__(_LogExportConfigState)

        __props__.__dict__["auth_principal"] = auth_principal
        __props__.__dict__["created_at"] = created_at
        __props__.__dict__["groups"] = groups
        __props__.__dict__["log_name"] = log_name
        __props__.__dict__["redact"] = redact
        __props__.__dict__["region"] = region
        __props__.__dict__["status"] = status
        __props__.__dict__["type"] = type
        __props__.__dict__["updated_at"] = updated_at
        __props__.__dict__["user_message"] = user_message
        return LogExportConfig(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="authPrincipal")
    def auth_principal(self) -> pulumi.Output[str]:
        """
        Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP Project ID that the cluster service account has permissions to write to for cloud logging
        """
        return pulumi.get(self, "auth_principal")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> pulumi.Output[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Output[Optional[Sequence['outputs.LogExportConfigGroup']]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="logName")
    def log_name(self) -> pulumi.Output[str]:
        """
        An identifier for the logs in the customer's log sink
        """
        return pulumi.get(self, "log_name")

    @property
    @pulumi.getter
    def redact(self) -> pulumi.Output[Optional[bool]]:
        """
        Controls whether logs are redacted before forwarding to customer sinks
        """
        return pulumi.get(self, "redact")

    @property
    @pulumi.getter
    def region(self) -> pulumi.Output[str]:
        """
        Controls whether all logs are sent to a specific region in the customer sink
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> pulumi.Output[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[str]:
        """
        The cloud selection that we're exporting to along with the cloud logging platform. Possible values are `GCP_CLOUD_LOGGING` or `AWS_CLOUDWATCH`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> pulumi.Output[str]:
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="userMessage")
    def user_message(self) -> pulumi.Output[str]:
        return pulumi.get(self, "user_message")

