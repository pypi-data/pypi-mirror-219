# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AdaptiveDynamicStreamingTemplateStreamInfo',
    'AdaptiveDynamicStreamingTemplateStreamInfoAudio',
    'AdaptiveDynamicStreamingTemplateStreamInfoVideo',
    'AiAnalysisTemplateClassificationConfigure',
    'AiAnalysisTemplateCoverConfigure',
    'AiAnalysisTemplateFrameTagConfigure',
    'AiAnalysisTemplateTagConfigure',
    'AiRecognitionTemplateAsrFullTextConfigure',
    'AiRecognitionTemplateAsrWordsConfigure',
    'AiRecognitionTemplateFaceConfigure',
    'AiRecognitionTemplateOcrFullTextConfigure',
    'AiRecognitionTemplateOcrWordsConfigure',
    'TranscodeTemplateAudioTemplate',
    'TranscodeTemplateEnhanceConfig',
    'TranscodeTemplateEnhanceConfigVideoEnhance',
    'TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepair',
    'TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhance',
    'TranscodeTemplateEnhanceConfigVideoEnhanceDenoise',
    'TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhance',
    'TranscodeTemplateEnhanceConfigVideoEnhanceFrameRate',
    'TranscodeTemplateEnhanceConfigVideoEnhanceHdr',
    'TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhance',
    'TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhance',
    'TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepair',
    'TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhance',
    'TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolution',
    'TranscodeTemplateTehdConfig',
    'TranscodeTemplateVideoTemplate',
    'WatermarkTemplateImageTemplate',
    'WatermarkTemplateSvgTemplate',
    'WatermarkTemplateTextTemplate',
    'WorkflowAiAnalysisTask',
    'WorkflowAiContentReviewTask',
    'WorkflowAiRecognitionTask',
    'WorkflowMediaProcessTask',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorage',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo',
    'WorkflowMediaProcessTaskAnimatedGraphicTaskSet',
    'WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage',
    'WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorage',
    'WorkflowMediaProcessTaskImageSpriteTaskSet',
    'WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat',
    'WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage',
    'WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorage',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSet',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorage',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorage',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo',
    'WorkflowMediaProcessTaskTranscodeTaskSet',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfo',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfo',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfo',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfo',
    'WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet',
    'WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat',
    'WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage',
    'WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorage',
    'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter',
    'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate',
    'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate',
    'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig',
    'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate',
    'WorkflowMediaProcessTaskTranscodeTaskSetRawParameter',
    'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate',
    'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig',
    'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo',
    'WorkflowOutputStorage',
    'WorkflowOutputStorageCosOutputStorage',
    'WorkflowTaskNotifyConfig',
    'WorkflowTrigger',
    'WorkflowTriggerCosFileUploadTrigger',
]

@pulumi.output_type
class AdaptiveDynamicStreamingTemplateStreamInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeAudio":
            suggest = "remove_audio"
        elif key == "removeVideo":
            suggest = "remove_video"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveDynamicStreamingTemplateStreamInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio: 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoAudio',
                 video: 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoVideo',
                 remove_audio: Optional[int] = None,
                 remove_video: Optional[int] = None):
        """
        :param 'AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs' audio: Audio parameter information.
        :param 'AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs' video: Video parameter information.
        :param int remove_audio: Whether to remove audio stream, value:0: reserved.1: remove.
        :param int remove_video: Whether to remove video stream, value:0: reserved.1: remove.
        """
        pulumi.set(__self__, "audio", audio)
        pulumi.set(__self__, "video", video)
        if remove_audio is not None:
            pulumi.set(__self__, "remove_audio", remove_audio)
        if remove_video is not None:
            pulumi.set(__self__, "remove_video", remove_video)

    @property
    @pulumi.getter
    def audio(self) -> 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoAudio':
        """
        Audio parameter information.
        """
        return pulumi.get(self, "audio")

    @property
    @pulumi.getter
    def video(self) -> 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoVideo':
        """
        Video parameter information.
        """
        return pulumi.get(self, "video")

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> Optional[int]:
        """
        Whether to remove audio stream, value:0: reserved.1: remove.
        """
        return pulumi.get(self, "remove_audio")

    @property
    @pulumi.getter(name="removeVideo")
    def remove_video(self) -> Optional[int]:
        """
        Whether to remove video stream, value:0: reserved.1: remove.
        """
        return pulumi.get(self, "remove_video")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplateStreamInfoAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"
        elif key == "audioChannel":
            suggest = "audio_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveDynamicStreamingTemplateStreamInfoAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 sample_rate: int,
                 audio_channel: Optional[int] = None):
        """
        :param int bitrate: Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        :param str codec: Encoding format of audio stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        :param int sample_rate: Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        :param int audio_channel: Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Encoding format of audio stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> int:
        """
        Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[int]:
        """
        Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        return pulumi.get(self, "audio_channel")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplateStreamInfoVideo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillType":
            suggest = "fill_type"
        elif key == "resolutionAdaptive":
            suggest = "resolution_adaptive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveDynamicStreamingTemplateStreamInfoVideo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoVideo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoVideo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 fps: int,
                 fill_type: Optional[str] = None,
                 gop: Optional[int] = None,
                 height: Optional[int] = None,
                 resolution_adaptive: Optional[str] = None,
                 vcrf: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param int bitrate: Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        :param str codec: Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        :param int fps: Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        :param str fill_type: Filling type, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling type:stretch: Stretching, stretching each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched.black: Leave black, keep the video aspect ratio unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and use Gaussian blur for the rest of the edge.Default value: black.Note: Adaptive stream only supports stretch, black.
        :param int gop: The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        :param int height: The maximum value of the height (or short side) of the video streaming, value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default value: 0.
        :param str resolution_adaptive: Adaptive resolution, optional value:open: At this time, Width represents the long side of the video, Height represents the short side of the video.close: At this point, Width represents the width of the video, and Height represents the height of the video.Default value: open.Note: In adaptive mode, Width cannot be smaller than Height.
        :param int vcrf: Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        :param int width: The maximum value of the width (or long side) of the video streaming, value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default value: 0.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def fps(self) -> int:
        """
        Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[str]:
        """
        Filling type, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling type:stretch: Stretching, stretching each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched.black: Leave black, keep the video aspect ratio unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and use Gaussian blur for the rest of the edge.Default value: black.Note: Adaptive stream only supports stretch, black.
        """
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def gop(self) -> Optional[int]:
        """
        The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        """
        return pulumi.get(self, "gop")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        The maximum value of the height (or short side) of the video streaming, value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default value: 0.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[str]:
        """
        Adaptive resolution, optional value:open: At this time, Width represents the long side of the video, Height represents the short side of the video.close: At this point, Width represents the width of the video, and Height represents the height of the video.Default value: open.Note: In adaptive mode, Width cannot be smaller than Height.
        """
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[int]:
        """
        Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        """
        return pulumi.get(self, "vcrf")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        The maximum value of the width (or long side) of the video streaming, value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default value: 0.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class AiAnalysisTemplateClassificationConfigure(dict):
    def __init__(__self__, *,
                 switch: str):
        """
        :param str switch: Ai classification task switch, optional value:ON/OFF.
        """
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> str:
        """
        Ai classification task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class AiAnalysisTemplateCoverConfigure(dict):
    def __init__(__self__, *,
                 switch: str):
        """
        :param str switch: Ai cover task switch, optional value:ON/OFF.
        """
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> str:
        """
        Ai cover task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class AiAnalysisTemplateFrameTagConfigure(dict):
    def __init__(__self__, *,
                 switch: str):
        """
        :param str switch: Ai frame tag task switch, optional value:ON/OFF.
        """
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> str:
        """
        Ai frame tag task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class AiAnalysisTemplateTagConfigure(dict):
    def __init__(__self__, *,
                 switch: str):
        """
        :param str switch: Ai tag task switch, optional value:ON/OFF.
        """
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> str:
        """
        Ai tag task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class AiRecognitionTemplateAsrFullTextConfigure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subtitleFormat":
            suggest = "subtitle_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiRecognitionTemplateAsrFullTextConfigure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiRecognitionTemplateAsrFullTextConfigure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiRecognitionTemplateAsrFullTextConfigure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: str,
                 subtitle_format: Optional[str] = None):
        """
        :param str switch: Asr full text recognition task switch, optional value:ON/OFF.
        :param str subtitle_format: Generated subtitle file format, if left blank or blank string means no subtitle file will be generated, optional value:vtt: Generate WebVTT subtitle files.
        """
        pulumi.set(__self__, "switch", switch)
        if subtitle_format is not None:
            pulumi.set(__self__, "subtitle_format", subtitle_format)

    @property
    @pulumi.getter
    def switch(self) -> str:
        """
        Asr full text recognition task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter(name="subtitleFormat")
    def subtitle_format(self) -> Optional[str]:
        """
        Generated subtitle file format, if left blank or blank string means no subtitle file will be generated, optional value:vtt: Generate WebVTT subtitle files.
        """
        return pulumi.get(self, "subtitle_format")


@pulumi.output_type
class AiRecognitionTemplateAsrWordsConfigure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSets":
            suggest = "label_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiRecognitionTemplateAsrWordsConfigure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiRecognitionTemplateAsrWordsConfigure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiRecognitionTemplateAsrWordsConfigure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: str,
                 label_sets: Optional[Sequence[str]] = None):
        """
        :param str switch: Asr word recognition task switch, optional value:ON/OFF.
        :param Sequence[str] label_sets: Keyword filter label, specify the label of the keyword to be returned. If not filled or empty, all results will be returned.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
        """
        pulumi.set(__self__, "switch", switch)
        if label_sets is not None:
            pulumi.set(__self__, "label_sets", label_sets)

    @property
    @pulumi.getter
    def switch(self) -> str:
        """
        Asr word recognition task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter(name="labelSets")
    def label_sets(self) -> Optional[Sequence[str]]:
        """
        Keyword filter label, specify the label of the keyword to be returned. If not filled or empty, all results will be returned.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
        """
        return pulumi.get(self, "label_sets")


@pulumi.output_type
class AiRecognitionTemplateFaceConfigure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultLibraryLabelSets":
            suggest = "default_library_label_sets"
        elif key == "faceLibrary":
            suggest = "face_library"
        elif key == "userDefineLibraryLabelSets":
            suggest = "user_define_library_label_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiRecognitionTemplateFaceConfigure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiRecognitionTemplateFaceConfigure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiRecognitionTemplateFaceConfigure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: str,
                 default_library_label_sets: Optional[Sequence[str]] = None,
                 face_library: Optional[str] = None,
                 score: Optional[float] = None,
                 user_define_library_label_sets: Optional[Sequence[str]] = None):
        """
        :param str switch: Ai face recognition task switch, optional value:ON/OFF.
        :param Sequence[str] default_library_label_sets: Default face filter tag, specify the tag of the default face that needs to be returned. If not filled or empty, all default face results will be returned. Label optional value:entertainment, sport, politician.
        :param str face_library: Face library selection, optional value:Default, UserDefine, AllDefault value: All, use the system default face library and user-defined face library.
        :param float score: Face recognition filter score, when the recognition result reaches the score above, the recognition result will be returned. The default is 95 points. Value range: 0 - 100.
        :param Sequence[str] user_define_library_label_sets: User-defined face filter tag, specify the tag of the user-defined face that needs to be returned. If not filled or empty, all custom face results will be returned.The maximum number of tags is 100, and the length of each tag is up to 16 characters.
        """
        pulumi.set(__self__, "switch", switch)
        if default_library_label_sets is not None:
            pulumi.set(__self__, "default_library_label_sets", default_library_label_sets)
        if face_library is not None:
            pulumi.set(__self__, "face_library", face_library)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if user_define_library_label_sets is not None:
            pulumi.set(__self__, "user_define_library_label_sets", user_define_library_label_sets)

    @property
    @pulumi.getter
    def switch(self) -> str:
        """
        Ai face recognition task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter(name="defaultLibraryLabelSets")
    def default_library_label_sets(self) -> Optional[Sequence[str]]:
        """
        Default face filter tag, specify the tag of the default face that needs to be returned. If not filled or empty, all default face results will be returned. Label optional value:entertainment, sport, politician.
        """
        return pulumi.get(self, "default_library_label_sets")

    @property
    @pulumi.getter(name="faceLibrary")
    def face_library(self) -> Optional[str]:
        """
        Face library selection, optional value:Default, UserDefine, AllDefault value: All, use the system default face library and user-defined face library.
        """
        return pulumi.get(self, "face_library")

    @property
    @pulumi.getter
    def score(self) -> Optional[float]:
        """
        Face recognition filter score, when the recognition result reaches the score above, the recognition result will be returned. The default is 95 points. Value range: 0 - 100.
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter(name="userDefineLibraryLabelSets")
    def user_define_library_label_sets(self) -> Optional[Sequence[str]]:
        """
        User-defined face filter tag, specify the tag of the user-defined face that needs to be returned. If not filled or empty, all custom face results will be returned.The maximum number of tags is 100, and the length of each tag is up to 16 characters.
        """
        return pulumi.get(self, "user_define_library_label_sets")


@pulumi.output_type
class AiRecognitionTemplateOcrFullTextConfigure(dict):
    def __init__(__self__, *,
                 switch: str):
        """
        :param str switch: Ocr full text recognition task switch, optional value:ON/OFF.
        """
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> str:
        """
        Ocr full text recognition task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class AiRecognitionTemplateOcrWordsConfigure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSets":
            suggest = "label_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiRecognitionTemplateOcrWordsConfigure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiRecognitionTemplateOcrWordsConfigure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiRecognitionTemplateOcrWordsConfigure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 switch: str,
                 label_sets: Optional[Sequence[str]] = None):
        """
        :param str switch: Ocr words recognition task switch, optional value:ON/OFF.
        :param Sequence[str] label_sets: Keyword filter label, specify the label of the keyword to be returned. If not filled or empty, all results will be returned.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
        """
        pulumi.set(__self__, "switch", switch)
        if label_sets is not None:
            pulumi.set(__self__, "label_sets", label_sets)

    @property
    @pulumi.getter
    def switch(self) -> str:
        """
        Ocr words recognition task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter(name="labelSets")
    def label_sets(self) -> Optional[Sequence[str]]:
        """
        Keyword filter label, specify the label of the keyword to be returned. If not filled or empty, all results will be returned.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
        """
        return pulumi.get(self, "label_sets")


@pulumi.output_type
class TranscodeTemplateAudioTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"
        elif key == "audioChannel":
            suggest = "audio_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TranscodeTemplateAudioTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TranscodeTemplateAudioTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TranscodeTemplateAudioTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 sample_rate: int,
                 audio_channel: Optional[int] = None):
        """
        :param int bitrate: Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        :param str codec: Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        :param int sample_rate: Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        :param int audio_channel: Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> int:
        """
        Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[int]:
        """
        Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        return pulumi.get(self, "audio_channel")


@pulumi.output_type
class TranscodeTemplateEnhanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "videoEnhance":
            suggest = "video_enhance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TranscodeTemplateEnhanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TranscodeTemplateEnhanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TranscodeTemplateEnhanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 video_enhance: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhance'] = None):
        """
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceArgs' video_enhance: Video Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if video_enhance is not None:
            pulumi.set(__self__, "video_enhance", video_enhance)

    @property
    @pulumi.getter(name="videoEnhance")
    def video_enhance(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhance']:
        """
        Video Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "video_enhance")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactRepair":
            suggest = "artifact_repair"
        elif key == "colorEnhance":
            suggest = "color_enhance"
        elif key == "faceEnhance":
            suggest = "face_enhance"
        elif key == "frameRate":
            suggest = "frame_rate"
        elif key == "imageQualityEnhance":
            suggest = "image_quality_enhance"
        elif key == "lowLightEnhance":
            suggest = "low_light_enhance"
        elif key == "scratchRepair":
            suggest = "scratch_repair"
        elif key == "sharpEnhance":
            suggest = "sharp_enhance"
        elif key == "superResolution":
            suggest = "super_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TranscodeTemplateEnhanceConfigVideoEnhance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TranscodeTemplateEnhanceConfigVideoEnhance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TranscodeTemplateEnhanceConfigVideoEnhance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_repair: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepair'] = None,
                 color_enhance: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhance'] = None,
                 denoise: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceDenoise'] = None,
                 face_enhance: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhance'] = None,
                 frame_rate: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceFrameRate'] = None,
                 hdr: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceHdr'] = None,
                 image_quality_enhance: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhance'] = None,
                 low_light_enhance: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhance'] = None,
                 scratch_repair: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepair'] = None,
                 sharp_enhance: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhance'] = None,
                 super_resolution: Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolution'] = None):
        """
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepairArgs' artifact_repair: De-artifact (glitch) configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhanceArgs' color_enhance: Color Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceDenoiseArgs' denoise: Video Noise Reduction Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhanceArgs' face_enhance: Face Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceFrameRateArgs' frame_rate: Interpolation frame rate configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceHdrArgs' hdr: HDR configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhanceArgs' image_quality_enhance: Comprehensive Enhanced Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhanceArgs' low_light_enhance: Low Light Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepairArgs' scratch_repair: De-scratch configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhanceArgs' sharp_enhance: Detail Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolutionArgs' super_resolution: Super resolution configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if artifact_repair is not None:
            pulumi.set(__self__, "artifact_repair", artifact_repair)
        if color_enhance is not None:
            pulumi.set(__self__, "color_enhance", color_enhance)
        if denoise is not None:
            pulumi.set(__self__, "denoise", denoise)
        if face_enhance is not None:
            pulumi.set(__self__, "face_enhance", face_enhance)
        if frame_rate is not None:
            pulumi.set(__self__, "frame_rate", frame_rate)
        if hdr is not None:
            pulumi.set(__self__, "hdr", hdr)
        if image_quality_enhance is not None:
            pulumi.set(__self__, "image_quality_enhance", image_quality_enhance)
        if low_light_enhance is not None:
            pulumi.set(__self__, "low_light_enhance", low_light_enhance)
        if scratch_repair is not None:
            pulumi.set(__self__, "scratch_repair", scratch_repair)
        if sharp_enhance is not None:
            pulumi.set(__self__, "sharp_enhance", sharp_enhance)
        if super_resolution is not None:
            pulumi.set(__self__, "super_resolution", super_resolution)

    @property
    @pulumi.getter(name="artifactRepair")
    def artifact_repair(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepair']:
        """
        De-artifact (glitch) configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "artifact_repair")

    @property
    @pulumi.getter(name="colorEnhance")
    def color_enhance(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhance']:
        """
        Color Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "color_enhance")

    @property
    @pulumi.getter
    def denoise(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceDenoise']:
        """
        Video Noise Reduction Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "denoise")

    @property
    @pulumi.getter(name="faceEnhance")
    def face_enhance(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhance']:
        """
        Face Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "face_enhance")

    @property
    @pulumi.getter(name="frameRate")
    def frame_rate(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceFrameRate']:
        """
        Interpolation frame rate configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "frame_rate")

    @property
    @pulumi.getter
    def hdr(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceHdr']:
        """
        HDR configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "hdr")

    @property
    @pulumi.getter(name="imageQualityEnhance")
    def image_quality_enhance(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhance']:
        """
        Comprehensive Enhanced Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "image_quality_enhance")

    @property
    @pulumi.getter(name="lowLightEnhance")
    def low_light_enhance(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhance']:
        """
        Low Light Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "low_light_enhance")

    @property
    @pulumi.getter(name="scratchRepair")
    def scratch_repair(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepair']:
        """
        De-scratch configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "scratch_repair")

    @property
    @pulumi.getter(name="sharpEnhance")
    def sharp_enhance(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhance']:
        """
        Detail Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "sharp_enhance")

    @property
    @pulumi.getter(name="superResolution")
    def super_resolution(self) -> Optional['outputs.TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolution']:
        """
        Super resolution configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "super_resolution")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepair(dict):
    def __init__(__self__, *,
                 switch: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param str type: Type, optional value: weak/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type, optional value: weak/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhance(dict):
    def __init__(__self__, *,
                 switch: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param str type: Type, optional value: weak/normal/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type, optional value: weak/normal/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceDenoise(dict):
    def __init__(__self__, *,
                 switch: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param str type: Type, optional value: weak/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type, optional value: weak/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhance(dict):
    def __init__(__self__, *,
                 intensity: Optional[float] = None,
                 switch: Optional[str] = None):
        """
        :param float intensity: Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        if intensity is not None:
            pulumi.set(__self__, "intensity", intensity)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def intensity(self) -> Optional[float]:
        """
        Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "intensity")

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceFrameRate(dict):
    def __init__(__self__, *,
                 fps: Optional[int] = None,
                 switch: Optional[str] = None):
        """
        :param int fps: Frame rate, value range: [0, 100], unit: Hz.Default value: 0.Note: For transcoding, this parameter will override the Fps inside the VideoTemplate.Note: This field may return null, indicating that no valid value can be obtained.
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def fps(self) -> Optional[int]:
        """
        Frame rate, value range: [0, 100], unit: Hz.Default value: 0.Note: For transcoding, this parameter will override the Fps inside the VideoTemplate.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceHdr(dict):
    def __init__(__self__, *,
                 switch: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param str type: Type, optional value: HDR10/HLG.Default value: HDR10.Note: The encoding method of video needs to be libx265.Note: Video encoding bit depth is 10.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type, optional value: HDR10/HLG.Default value: HDR10.Note: The encoding method of video needs to be libx265.Note: Video encoding bit depth is 10.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhance(dict):
    def __init__(__self__, *,
                 switch: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param str type: Type, optional value: weak/normal/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type, optional value: weak/normal/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhance(dict):
    def __init__(__self__, *,
                 switch: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param str type: Type, optional value: normal.Default value: normal.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type, optional value: normal.Default value: normal.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepair(dict):
    def __init__(__self__, *,
                 intensity: Optional[float] = None,
                 switch: Optional[str] = None):
        """
        :param float intensity: Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        if intensity is not None:
            pulumi.set(__self__, "intensity", intensity)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def intensity(self) -> Optional[float]:
        """
        Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "intensity")

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhance(dict):
    def __init__(__self__, *,
                 intensity: Optional[float] = None,
                 switch: Optional[str] = None):
        """
        :param float intensity: Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        if intensity is not None:
            pulumi.set(__self__, "intensity", intensity)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def intensity(self) -> Optional[float]:
        """
        Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "intensity")

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolution(dict):
    def __init__(__self__, *,
                 size: Optional[int] = None,
                 switch: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param int size: Super resolution multiple, optional value:2: currently only supports 2x super resolution.Default value: 2.Note: This field may return null, indicating that no valid value can be obtained.
        :param str switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param str type: Type, optional value:lq: super-resolution for low-definition video with more noise.hq: super resolution for high-definition video.Default value: lq.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        Super resolution multiple, optional value:2: currently only supports 2x super resolution.Default value: 2.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type, optional value:lq: super-resolution for low-definition video with more noise.hq: super resolution for high-definition video.Default value: lq.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TranscodeTemplateTehdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVideoBitrate":
            suggest = "max_video_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TranscodeTemplateTehdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TranscodeTemplateTehdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TranscodeTemplateTehdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 max_video_bitrate: Optional[int] = None):
        """
        :param str type: Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        :param int max_video_bitrate: The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        """
        pulumi.set(__self__, "type", type)
        if max_video_bitrate is not None:
            pulumi.set(__self__, "max_video_bitrate", max_video_bitrate)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="maxVideoBitrate")
    def max_video_bitrate(self) -> Optional[int]:
        """
        The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        """
        return pulumi.get(self, "max_video_bitrate")


@pulumi.output_type
class TranscodeTemplateVideoTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillType":
            suggest = "fill_type"
        elif key == "resolutionAdaptive":
            suggest = "resolution_adaptive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TranscodeTemplateVideoTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TranscodeTemplateVideoTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TranscodeTemplateVideoTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 fps: int,
                 fill_type: Optional[str] = None,
                 gop: Optional[int] = None,
                 height: Optional[int] = None,
                 resolution_adaptive: Optional[str] = None,
                 vcrf: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param int bitrate: Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        :param str codec: Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        :param int fps: Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        :param str fill_type: Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        :param int gop: The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        :param int height: The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        :param str resolution_adaptive: Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        :param int vcrf: Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        :param int width: The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def fps(self) -> int:
        """
        Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[str]:
        """
        Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        """
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def gop(self) -> Optional[int]:
        """
        The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        """
        return pulumi.get(self, "gop")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[str]:
        """
        Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        """
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[int]:
        """
        Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        """
        return pulumi.get(self, "vcrf")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WatermarkTemplateImageTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageContent":
            suggest = "image_content"
        elif key == "repeatType":
            suggest = "repeat_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WatermarkTemplateImageTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WatermarkTemplateImageTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WatermarkTemplateImageTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_content: str,
                 height: Optional[str] = None,
                 repeat_type: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str image_content: Watermark image[Base64](https://tools.ietf.org/html/rfc4648) encoded string. Support jpeg, png image format.
        :param str height: The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels. The value range is 0 or [8, 4096].Default value: 0px. Indicates that Height is scaled according to the aspect ratio of the original watermark image.
        :param str repeat_type: Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges:once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        :param str width: The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixel, such as 100px means that the Width is 100 pixels. The value range is [8, 4096].Default value: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> str:
        """
        Watermark image[Base64](https://tools.ietf.org/html/rfc4648) encoded string. Support jpeg, png image format.
        """
        return pulumi.get(self, "image_content")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels. The value range is 0 or [8, 4096].Default value: 0px. Indicates that Height is scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[str]:
        """
        Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges:once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        """
        return pulumi.get(self, "repeat_type")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixel, such as 100px means that the Width is 100 pixels. The value range is [8, 4096].Default value: 10%.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WatermarkTemplateSvgTemplate(dict):
    def __init__(__self__, *,
                 height: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str height: The height of the watermark, supports px, W%, H%, S%, L% six formats:When the string ends with px, it means that the watermark Height unit is pixels, such as 100px means that the Height is 100 pixels; when filling 0px and Width is not 0px, it means that the height of the watermark is proportionally scaled according to the original SVG image; when both Width and Height are filled When 0px, it means that the height of the watermark takes the height of the original SVG image.When the string ends with W%, it means that the watermark Height is a percentage of the video width, such as 10W% means that the Height is 10% of the video width.When the string ends with H%, it means that the watermark Height is the percentage size of the video height, such as 10H% means that the Height is 10% of the video height.When the string ends with S%, it means that the watermark Height is the percentage size of the short side of the video, such as 10S% means that the Height is 10% of the short side of the video.When the string ends with L%, it means that the watermark Height is the percentage size of the long side of the video, such as 10L% means that the Height is 10% of the long side of the video.When the string ends with %, the meaning is the same as H%.Default value: 0px.
        :param str width: The width of the watermark, supports px, %, W%, H%, S%, L% six formats.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels; when filling 0px and the Height is not 0px, it means that the width of the watermark is proportionally scaled according to the original SVG image; when both Width and Height are filled When 0px, it means that the width of the watermark takes the width of the original SVG image.When the string ends with W%, it means that the watermark Width is a percentage of the video width, such as 10W% means that the Width is 10% of the video width.When the string ends with H%, it means that the watermark Width is a percentage of the video height, such as 10H% means that the Width is 10% of the video height.When the string ends with S%, it means that the watermark Width is the percentage size of the short side of the video, such as 10S% means that the Width is 10% of the short side of the video.When the string ends with L%, it means that the watermark Width is the percentage size of the long side of the video, such as 10L% means that the Width is 10% of the long side of the video.When the string ends with %, it has the same meaning as W%.Default value: 10W%.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        The height of the watermark, supports px, W%, H%, S%, L% six formats:When the string ends with px, it means that the watermark Height unit is pixels, such as 100px means that the Height is 100 pixels; when filling 0px and Width is not 0px, it means that the height of the watermark is proportionally scaled according to the original SVG image; when both Width and Height are filled When 0px, it means that the height of the watermark takes the height of the original SVG image.When the string ends with W%, it means that the watermark Height is a percentage of the video width, such as 10W% means that the Height is 10% of the video width.When the string ends with H%, it means that the watermark Height is the percentage size of the video height, such as 10H% means that the Height is 10% of the video height.When the string ends with S%, it means that the watermark Height is the percentage size of the short side of the video, such as 10S% means that the Height is 10% of the short side of the video.When the string ends with L%, it means that the watermark Height is the percentage size of the long side of the video, such as 10L% means that the Height is 10% of the long side of the video.When the string ends with %, the meaning is the same as H%.Default value: 0px.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        The width of the watermark, supports px, %, W%, H%, S%, L% six formats.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels; when filling 0px and the Height is not 0px, it means that the width of the watermark is proportionally scaled according to the original SVG image; when both Width and Height are filled When 0px, it means that the width of the watermark takes the width of the original SVG image.When the string ends with W%, it means that the watermark Width is a percentage of the video width, such as 10W% means that the Width is 10% of the video width.When the string ends with H%, it means that the watermark Width is a percentage of the video height, such as 10H% means that the Width is 10% of the video height.When the string ends with S%, it means that the watermark Width is the percentage size of the short side of the video, such as 10S% means that the Width is 10% of the short side of the video.When the string ends with L%, it means that the watermark Width is the percentage size of the long side of the video, such as 10L% means that the Width is 10% of the long side of the video.When the string ends with %, it has the same meaning as W%.Default value: 10W%.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WatermarkTemplateTextTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontAlpha":
            suggest = "font_alpha"
        elif key == "fontColor":
            suggest = "font_color"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "fontType":
            suggest = "font_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WatermarkTemplateTextTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WatermarkTemplateTextTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WatermarkTemplateTextTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_alpha: float,
                 font_color: str,
                 font_size: str,
                 font_type: str):
        """
        :param float font_alpha: Text transparency, value range: (0, 1].0: fully transparent.1: fully opaque.Default value: 1.
        :param str font_color: Font color, format: 0xRRGGBB, default value: 0xFFFFFF (white).
        :param str font_size: Font size, format: Npx, N is a number.
        :param str font_type: Font type, currently supports two:simkai.ttf: can support Chinese and English.arial.ttf: English only.
        """
        pulumi.set(__self__, "font_alpha", font_alpha)
        pulumi.set(__self__, "font_color", font_color)
        pulumi.set(__self__, "font_size", font_size)
        pulumi.set(__self__, "font_type", font_type)

    @property
    @pulumi.getter(name="fontAlpha")
    def font_alpha(self) -> float:
        """
        Text transparency, value range: (0, 1].0: fully transparent.1: fully opaque.Default value: 1.
        """
        return pulumi.get(self, "font_alpha")

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> str:
        """
        Font color, format: 0xRRGGBB, default value: 0xFFFFFF (white).
        """
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> str:
        """
        Font size, format: Npx, N is a number.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="fontType")
    def font_type(self) -> str:
        """
        Font type, currently supports two:simkai.ttf: can support Chinese and English.arial.ttf: English only.
        """
        return pulumi.get(self, "font_type")


@pulumi.output_type
class WorkflowAiAnalysisTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extendedParameter":
            suggest = "extended_parameter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowAiAnalysisTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowAiAnalysisTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowAiAnalysisTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 extended_parameter: Optional[str] = None):
        """
        :param int definition: Video Content Analysis Template ID.
        :param str extended_parameter: Extension parameter whose value is a serialized json string.Note: This parameter is a customized demand parameter, which requires offline docking.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if extended_parameter is not None:
            pulumi.set(__self__, "extended_parameter", extended_parameter)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Video Content Analysis Template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="extendedParameter")
    def extended_parameter(self) -> Optional[str]:
        """
        Extension parameter whose value is a serialized json string.Note: This parameter is a customized demand parameter, which requires offline docking.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "extended_parameter")


@pulumi.output_type
class WorkflowAiContentReviewTask(dict):
    def __init__(__self__, *,
                 definition: int):
        """
        :param int definition: Video Content Review Template ID.
        """
        pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Video Content Review Template ID.
        """
        return pulumi.get(self, "definition")


@pulumi.output_type
class WorkflowAiRecognitionTask(dict):
    def __init__(__self__, *,
                 definition: int):
        """
        :param int definition: Video Intelligent Recognition Template ID.
        """
        pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Video Intelligent Recognition Template ID.
        """
        return pulumi.get(self, "definition")


@pulumi.output_type
class WorkflowMediaProcessTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptiveDynamicStreamingTaskSets":
            suggest = "adaptive_dynamic_streaming_task_sets"
        elif key == "animatedGraphicTaskSets":
            suggest = "animated_graphic_task_sets"
        elif key == "imageSpriteTaskSets":
            suggest = "image_sprite_task_sets"
        elif key == "sampleSnapshotTaskSets":
            suggest = "sample_snapshot_task_sets"
        elif key == "snapshotByTimeOffsetTaskSets":
            suggest = "snapshot_by_time_offset_task_sets"
        elif key == "transcodeTaskSets":
            suggest = "transcode_task_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_dynamic_streaming_task_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet']] = None,
                 animated_graphic_task_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskAnimatedGraphicTaskSet']] = None,
                 image_sprite_task_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskImageSpriteTaskSet']] = None,
                 sample_snapshot_task_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSet']] = None,
                 snapshot_by_time_offset_task_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet']] = None,
                 transcode_task_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskTranscodeTaskSet']] = None):
        """
        :param Sequence['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetArgs'] adaptive_dynamic_streaming_task_sets: Transfer Adaptive Code Stream Task List.
        :param Sequence['WorkflowMediaProcessTaskAnimatedGraphicTaskSetArgs'] animated_graphic_task_sets: Video Rotation Map Task List.
        :param Sequence['WorkflowMediaProcessTaskImageSpriteTaskSetArgs'] image_sprite_task_sets: Sprite image capture task list for video.
        :param Sequence['WorkflowMediaProcessTaskSampleSnapshotTaskSetArgs'] sample_snapshot_task_sets: Screenshot task list for video sampling.
        :param Sequence['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetArgs'] snapshot_by_time_offset_task_sets: Screenshot the task list of the video according to the time point.
        :param Sequence['WorkflowMediaProcessTaskTranscodeTaskSetArgs'] transcode_task_sets: Video Transcoding Task List.
        """
        if adaptive_dynamic_streaming_task_sets is not None:
            pulumi.set(__self__, "adaptive_dynamic_streaming_task_sets", adaptive_dynamic_streaming_task_sets)
        if animated_graphic_task_sets is not None:
            pulumi.set(__self__, "animated_graphic_task_sets", animated_graphic_task_sets)
        if image_sprite_task_sets is not None:
            pulumi.set(__self__, "image_sprite_task_sets", image_sprite_task_sets)
        if sample_snapshot_task_sets is not None:
            pulumi.set(__self__, "sample_snapshot_task_sets", sample_snapshot_task_sets)
        if snapshot_by_time_offset_task_sets is not None:
            pulumi.set(__self__, "snapshot_by_time_offset_task_sets", snapshot_by_time_offset_task_sets)
        if transcode_task_sets is not None:
            pulumi.set(__self__, "transcode_task_sets", transcode_task_sets)

    @property
    @pulumi.getter(name="adaptiveDynamicStreamingTaskSets")
    def adaptive_dynamic_streaming_task_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet']]:
        """
        Transfer Adaptive Code Stream Task List.
        """
        return pulumi.get(self, "adaptive_dynamic_streaming_task_sets")

    @property
    @pulumi.getter(name="animatedGraphicTaskSets")
    def animated_graphic_task_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskAnimatedGraphicTaskSet']]:
        """
        Video Rotation Map Task List.
        """
        return pulumi.get(self, "animated_graphic_task_sets")

    @property
    @pulumi.getter(name="imageSpriteTaskSets")
    def image_sprite_task_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskImageSpriteTaskSet']]:
        """
        Sprite image capture task list for video.
        """
        return pulumi.get(self, "image_sprite_task_sets")

    @property
    @pulumi.getter(name="sampleSnapshotTaskSets")
    def sample_snapshot_task_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSet']]:
        """
        Screenshot task list for video sampling.
        """
        return pulumi.get(self, "sample_snapshot_task_sets")

    @property
    @pulumi.getter(name="snapshotByTimeOffsetTaskSets")
    def snapshot_by_time_offset_task_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet']]:
        """
        Screenshot the task list of the video according to the time point.
        """
        return pulumi.get(self, "snapshot_by_time_offset_task_sets")

    @property
    @pulumi.getter(name="transcodeTaskSets")
    def transcode_task_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskTranscodeTaskSet']]:
        """
        Video Transcoding Task List.
        """
        return pulumi.get(self, "transcode_task_sets")


@pulumi.output_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputObjectPath":
            suggest = "output_object_path"
        elif key == "outputStorage":
            suggest = "output_storage"
        elif key == "segmentObjectName":
            suggest = "segment_object_name"
        elif key == "subStreamObjectName":
            suggest = "sub_stream_object_name"
        elif key == "watermarkSets":
            suggest = "watermark_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 output_object_path: Optional[str] = None,
                 output_storage: Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage'] = None,
                 segment_object_name: Optional[str] = None,
                 sub_stream_object_name: Optional[str] = None,
                 watermark_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet']] = None):
        """
        :param int definition: Transfer Adaptive Code Stream Template ID.
        :param str output_object_path: After converting to an adaptive stream, the output path of the manifest file can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_adaptiveDynamicStreaming_{definition}.{format}`.
        :param 'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageArgs' output_storage: The target storage of the file after converting to the adaptive code stream, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        :param str segment_object_name: After converting to an adaptive stream (only HLS), the output path of the fragmented file can only be a relative path. If not filled, the default is a relative path: `{inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}_{segmentNumber}.{format}`.
        :param str sub_stream_object_name: After converting to an adaptive stream, the output path of the sub-stream file can only be a relative path. If not filled, the default is a relative path: {inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}.{format}`.
        :param Sequence['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetArgs'] watermark_sets: Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        pulumi.set(__self__, "definition", definition)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)
        if segment_object_name is not None:
            pulumi.set(__self__, "segment_object_name", segment_object_name)
        if sub_stream_object_name is not None:
            pulumi.set(__self__, "sub_stream_object_name", sub_stream_object_name)
        if watermark_sets is not None:
            pulumi.set(__self__, "watermark_sets", watermark_sets)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Transfer Adaptive Code Stream Template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[str]:
        """
        After converting to an adaptive stream, the output path of the manifest file can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_adaptiveDynamicStreaming_{definition}.{format}`.
        """
        return pulumi.get(self, "output_object_path")

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage']:
        """
        The target storage of the file after converting to the adaptive code stream, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @property
    @pulumi.getter(name="segmentObjectName")
    def segment_object_name(self) -> Optional[str]:
        """
        After converting to an adaptive stream (only HLS), the output path of the fragmented file can only be a relative path. If not filled, the default is a relative path: `{inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}_{segmentNumber}.{format}`.
        """
        return pulumi.get(self, "segment_object_name")

    @property
    @pulumi.getter(name="subStreamObjectName")
    def sub_stream_object_name(self) -> Optional[str]:
        """
        After converting to an adaptive stream, the output path of the sub-stream file can only be a relative path. If not filled, the default is a relative path: {inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}.{format}`.
        """
        return pulumi.get(self, "sub_stream_object_name")

    @property
    @pulumi.getter(name="watermarkSets")
    def watermark_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet']]:
        """
        Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        return pulumi.get(self, "watermark_sets")


@pulumi.output_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosOutputStorage":
            suggest = "cos_output_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_output_storage: Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorage'] = None):
        """
        :param str type: The type of media processing output object storage location, now only supports COS.
        :param 'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorageArgs' cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorage']:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")


@pulumi.output_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorage(dict):
    def __init__(__self__, *,
                 bucket: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param str region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "rawParameter":
            suggest = "raw_parameter"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 end_time_offset: Optional[float] = None,
                 raw_parameter: Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter'] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param int definition: Watermark Template ID.
        :param float end_time_offset: End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        :param 'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterArgs' raw_parameter: Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        :param float start_time_offset: The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        :param str svg_content: SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        :param str text_content: Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if raw_parameter is not None:
            pulumi.set(__self__, "raw_parameter", raw_parameter)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Watermark Template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="rawParameter")
    def raw_parameter(self) -> Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter']:
        """
        Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        """
        return pulumi.get(self, "raw_parameter")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coordinateOrigin":
            suggest = "coordinate_origin"
        elif key == "imageTemplate":
            suggest = "image_template"
        elif key == "xPos":
            suggest = "x_pos"
        elif key == "yPos":
            suggest = "y_pos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 coordinate_origin: Optional[str] = None,
                 image_template: Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate'] = None,
                 x_pos: Optional[str] = None,
                 y_pos: Optional[str] = None):
        """
        :param str type: Watermark type, optional value:image: image watermark.
        :param str coordinate_origin: Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        :param 'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateArgs' image_template: Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        :param str x_pos: The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        :param str y_pos: The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        pulumi.set(__self__, "type", type)
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if image_template is not None:
            pulumi.set(__self__, "image_template", image_template)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Watermark type, optional value:image: image watermark.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[str]:
        """
        Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @property
    @pulumi.getter(name="imageTemplate")
    def image_template(self) -> Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate']:
        """
        Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        """
        return pulumi.get(self, "image_template")

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[str]:
        """
        The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "x_pos")

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[str]:
        """
        The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "y_pos")


@pulumi.output_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageContent":
            suggest = "image_content"
        elif key == "repeatType":
            suggest = "repeat_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_content: 'outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent',
                 height: Optional[str] = None,
                 repeat_type: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param 'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs' image_content: The input content of the watermark image. Support jpeg, png image format.
        :param str height: The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        :param str repeat_type: Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        :param str width: The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> 'outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent':
        """
        The input content of the watermark image. Support jpeg, png image format.
        """
        return pulumi.get(self, "image_content")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[str]:
        """
        Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        """
        return pulumi.get(self, "repeat_type")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosInputInfo":
            suggest = "cos_input_info"
        elif key == "urlInputInfo":
            suggest = "url_input_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_input_info: Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo'] = None,
                 url_input_info: Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo'] = None):
        """
        :param str type: Enter the type of source object, which supports COS and URL.
        :param 'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs' cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param 'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs' url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo']:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo']:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")


@pulumi.output_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo(dict):
    def __init__(__self__, *,
                 bucket: str,
                 object: str,
                 region: str):
        """
        :param str bucket: The name of the COS Bucket where the media processing object file is located.
        :param str object: Input path for media processing object files.
        :param str region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Video URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WorkflowMediaProcessTaskAnimatedGraphicTaskSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "outputObjectPath":
            suggest = "output_object_path"
        elif key == "outputStorage":
            suggest = "output_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskAnimatedGraphicTaskSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskAnimatedGraphicTaskSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskAnimatedGraphicTaskSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 end_time_offset: float,
                 start_time_offset: float,
                 output_object_path: Optional[str] = None,
                 output_storage: Optional['outputs.WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage'] = None):
        """
        :param int definition: Video turntable template id.
        :param float end_time_offset: The end time of the animation in the video, in seconds.
        :param float start_time_offset: The start time of the animation in the video, in seconds.
        :param str output_object_path: The output path of the file after rotating the image, which can be a relative path or an absolute path. If not filled, the default is a relative path: {inputName}_animatedGraphic_{definition}.{format}.
        :param 'WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageArgs' output_storage: The target storage of the transcoded file, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "start_time_offset", start_time_offset)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Video turntable template id.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> float:
        """
        The end time of the animation in the video, in seconds.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> float:
        """
        The start time of the animation in the video, in seconds.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[str]:
        """
        The output path of the file after rotating the image, which can be a relative path or an absolute path. If not filled, the default is a relative path: {inputName}_animatedGraphic_{definition}.{format}.
        """
        return pulumi.get(self, "output_object_path")

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage']:
        """
        The target storage of the transcoded file, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")


@pulumi.output_type
class WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosOutputStorage":
            suggest = "cos_output_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_output_storage: Optional['outputs.WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorage'] = None):
        """
        :param str type: The type of media processing output object storage location, now only supports COS.
        :param 'WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorageArgs' cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorage']:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")


@pulumi.output_type
class WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorage(dict):
    def __init__(__self__, *,
                 bucket: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param str region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskImageSpriteTaskSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectNumberFormat":
            suggest = "object_number_format"
        elif key == "outputObjectPath":
            suggest = "output_object_path"
        elif key == "outputStorage":
            suggest = "output_storage"
        elif key == "webVttObjectName":
            suggest = "web_vtt_object_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskImageSpriteTaskSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskImageSpriteTaskSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskImageSpriteTaskSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 object_number_format: Optional['outputs.WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat'] = None,
                 output_object_path: Optional[str] = None,
                 output_storage: Optional['outputs.WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage'] = None,
                 web_vtt_object_name: Optional[str] = None):
        """
        :param int definition: Sprite Illustration Template ID.
        :param 'WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormatArgs' object_number_format: Rules for the `{number}` variable in the output path after intercepting the Sprite image.Note: This field may return null, indicating that no valid value can be obtained.
        :param str output_object_path: After capturing the sprite image, the output path of the sprite image file can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_imageSprite_{definition}_{number}.{format}`.
        :param 'WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageArgs' output_storage: The target storage of the file after the sprite image is intercepted, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        :param str web_vtt_object_name: After capturing the sprite image, the output path of the Web VTT file can only be a relative path. If not filled, the default is a relative path: `{inputName}_imageSprite_{definition}.{format}`.
        """
        pulumi.set(__self__, "definition", definition)
        if object_number_format is not None:
            pulumi.set(__self__, "object_number_format", object_number_format)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)
        if web_vtt_object_name is not None:
            pulumi.set(__self__, "web_vtt_object_name", web_vtt_object_name)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Sprite Illustration Template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="objectNumberFormat")
    def object_number_format(self) -> Optional['outputs.WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat']:
        """
        Rules for the `{number}` variable in the output path after intercepting the Sprite image.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "object_number_format")

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[str]:
        """
        After capturing the sprite image, the output path of the sprite image file can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_imageSprite_{definition}_{number}.{format}`.
        """
        return pulumi.get(self, "output_object_path")

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage']:
        """
        The target storage of the file after the sprite image is intercepted, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @property
    @pulumi.getter(name="webVttObjectName")
    def web_vtt_object_name(self) -> Optional[str]:
        """
        After capturing the sprite image, the output path of the Web VTT file can only be a relative path. If not filled, the default is a relative path: `{inputName}_imageSprite_{definition}.{format}`.
        """
        return pulumi.get(self, "web_vtt_object_name")


@pulumi.output_type
class WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialValue":
            suggest = "initial_value"
        elif key == "minLength":
            suggest = "min_length"
        elif key == "placeHolder":
            suggest = "place_holder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 increment: Optional[int] = None,
                 initial_value: Optional[int] = None,
                 min_length: Optional[int] = None,
                 place_holder: Optional[str] = None):
        """
        :param int increment: The growth step of the `{number}` variable, the default is 1.
        :param int initial_value: The starting value of `{number}` variable, the default is 0.
        :param int min_length: The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        :param str place_holder: When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if initial_value is not None:
            pulumi.set(__self__, "initial_value", initial_value)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if place_holder is not None:
            pulumi.set(__self__, "place_holder", place_holder)

    @property
    @pulumi.getter
    def increment(self) -> Optional[int]:
        """
        The growth step of the `{number}` variable, the default is 1.
        """
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="initialValue")
    def initial_value(self) -> Optional[int]:
        """
        The starting value of `{number}` variable, the default is 0.
        """
        return pulumi.get(self, "initial_value")

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[int]:
        """
        The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        """
        return pulumi.get(self, "min_length")

    @property
    @pulumi.getter(name="placeHolder")
    def place_holder(self) -> Optional[str]:
        """
        When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        return pulumi.get(self, "place_holder")


@pulumi.output_type
class WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosOutputStorage":
            suggest = "cos_output_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_output_storage: Optional['outputs.WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorage'] = None):
        """
        :param str type: The type of media processing output object storage location, now only supports COS.
        :param 'WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorageArgs' cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorage']:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")


@pulumi.output_type
class WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorage(dict):
    def __init__(__self__, *,
                 bucket: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param str region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectNumberFormat":
            suggest = "object_number_format"
        elif key == "outputObjectPath":
            suggest = "output_object_path"
        elif key == "outputStorage":
            suggest = "output_storage"
        elif key == "watermarkSets":
            suggest = "watermark_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSampleSnapshotTaskSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 object_number_format: Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat'] = None,
                 output_object_path: Optional[str] = None,
                 output_storage: Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage'] = None,
                 watermark_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet']] = None):
        """
        :param int definition: Sample screenshot template ID.
        :param 'WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormatArgs' object_number_format: Rules for the `{number}` variable in the output path after sampling the screenshot.Note: This field may return null, indicating that no valid value can be obtained.
        :param str output_object_path: The output path of the image file after sampling the screenshot, which can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_sampleSnapshot_{definition}_{number}.{format}`.
        :param 'WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageArgs' output_storage: The target storage of the file after the screenshot at the time point, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        :param Sequence['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetArgs'] watermark_sets: Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        pulumi.set(__self__, "definition", definition)
        if object_number_format is not None:
            pulumi.set(__self__, "object_number_format", object_number_format)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)
        if watermark_sets is not None:
            pulumi.set(__self__, "watermark_sets", watermark_sets)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Sample screenshot template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="objectNumberFormat")
    def object_number_format(self) -> Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat']:
        """
        Rules for the `{number}` variable in the output path after sampling the screenshot.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "object_number_format")

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[str]:
        """
        The output path of the image file after sampling the screenshot, which can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_sampleSnapshot_{definition}_{number}.{format}`.
        """
        return pulumi.get(self, "output_object_path")

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage']:
        """
        The target storage of the file after the screenshot at the time point, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @property
    @pulumi.getter(name="watermarkSets")
    def watermark_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet']]:
        """
        Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        return pulumi.get(self, "watermark_sets")


@pulumi.output_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialValue":
            suggest = "initial_value"
        elif key == "minLength":
            suggest = "min_length"
        elif key == "placeHolder":
            suggest = "place_holder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 increment: Optional[int] = None,
                 initial_value: Optional[int] = None,
                 min_length: Optional[int] = None,
                 place_holder: Optional[str] = None):
        """
        :param int increment: The growth step of the `{number}` variable, the default is 1.
        :param int initial_value: The starting value of `{number}` variable, the default is 0.
        :param int min_length: The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        :param str place_holder: When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if initial_value is not None:
            pulumi.set(__self__, "initial_value", initial_value)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if place_holder is not None:
            pulumi.set(__self__, "place_holder", place_holder)

    @property
    @pulumi.getter
    def increment(self) -> Optional[int]:
        """
        The growth step of the `{number}` variable, the default is 1.
        """
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="initialValue")
    def initial_value(self) -> Optional[int]:
        """
        The starting value of `{number}` variable, the default is 0.
        """
        return pulumi.get(self, "initial_value")

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[int]:
        """
        The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        """
        return pulumi.get(self, "min_length")

    @property
    @pulumi.getter(name="placeHolder")
    def place_holder(self) -> Optional[str]:
        """
        When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        return pulumi.get(self, "place_holder")


@pulumi.output_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosOutputStorage":
            suggest = "cos_output_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_output_storage: Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorage'] = None):
        """
        :param str type: The type of media processing output object storage location, now only supports COS.
        :param 'WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorageArgs' cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorage']:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")


@pulumi.output_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorage(dict):
    def __init__(__self__, *,
                 bucket: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param str region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "rawParameter":
            suggest = "raw_parameter"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 end_time_offset: Optional[float] = None,
                 raw_parameter: Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter'] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param int definition: Watermark Template ID.
        :param float end_time_offset: End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        :param 'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterArgs' raw_parameter: Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        :param float start_time_offset: The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        :param str svg_content: SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        :param str text_content: Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if raw_parameter is not None:
            pulumi.set(__self__, "raw_parameter", raw_parameter)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Watermark Template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="rawParameter")
    def raw_parameter(self) -> Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter']:
        """
        Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        """
        return pulumi.get(self, "raw_parameter")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coordinateOrigin":
            suggest = "coordinate_origin"
        elif key == "imageTemplate":
            suggest = "image_template"
        elif key == "xPos":
            suggest = "x_pos"
        elif key == "yPos":
            suggest = "y_pos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 coordinate_origin: Optional[str] = None,
                 image_template: Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate'] = None,
                 x_pos: Optional[str] = None,
                 y_pos: Optional[str] = None):
        """
        :param str type: Watermark type, optional value:image: image watermark.
        :param str coordinate_origin: Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        :param 'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateArgs' image_template: Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        :param str x_pos: The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        :param str y_pos: The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        pulumi.set(__self__, "type", type)
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if image_template is not None:
            pulumi.set(__self__, "image_template", image_template)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Watermark type, optional value:image: image watermark.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[str]:
        """
        Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @property
    @pulumi.getter(name="imageTemplate")
    def image_template(self) -> Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate']:
        """
        Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        """
        return pulumi.get(self, "image_template")

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[str]:
        """
        The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "x_pos")

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[str]:
        """
        The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "y_pos")


@pulumi.output_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageContent":
            suggest = "image_content"
        elif key == "repeatType":
            suggest = "repeat_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_content: 'outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent',
                 height: Optional[str] = None,
                 repeat_type: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param 'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs' image_content: The input content of the watermark image. Support jpeg, png image format.
        :param str height: The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        :param str repeat_type: Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        :param str width: The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> 'outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent':
        """
        The input content of the watermark image. Support jpeg, png image format.
        """
        return pulumi.get(self, "image_content")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[str]:
        """
        Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        """
        return pulumi.get(self, "repeat_type")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosInputInfo":
            suggest = "cos_input_info"
        elif key == "urlInputInfo":
            suggest = "url_input_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_input_info: Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo'] = None,
                 url_input_info: Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo'] = None):
        """
        :param str type: Enter the type of source object, which supports COS and URL.
        :param 'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs' cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param 'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs' url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo']:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo']:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")


@pulumi.output_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo(dict):
    def __init__(__self__, *,
                 bucket: str,
                 object: str,
                 region: str):
        """
        :param str bucket: The name of the COS Bucket where the media processing object file is located.
        :param str object: Input path for media processing object files.
        :param str region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Video URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extTimeOffsetSets":
            suggest = "ext_time_offset_sets"
        elif key == "objectNumberFormat":
            suggest = "object_number_format"
        elif key == "outputObjectPath":
            suggest = "output_object_path"
        elif key == "outputStorage":
            suggest = "output_storage"
        elif key == "timeOffsetSets":
            suggest = "time_offset_sets"
        elif key == "watermarkSets":
            suggest = "watermark_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 ext_time_offset_sets: Optional[Sequence[str]] = None,
                 object_number_format: Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat'] = None,
                 output_object_path: Optional[str] = None,
                 output_storage: Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage'] = None,
                 time_offset_sets: Optional[Sequence[float]] = None,
                 watermark_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet']] = None):
        """
        :param int definition: Specified time point screenshot template ID.
        :param Sequence[str] ext_time_offset_sets: Screenshot time point list, the time point supports two formats: s and %:;When the string ends with s, it means that the time point is in seconds, such as 3.5s means that the time point is the 3.5th second.When the string ends with %, it means that the time point is the percentage of the video duration, such as 10% means that the time point is the first 10% of the time in the video.
        :param 'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormatArgs' object_number_format: Rules for the `{number}` variable in the output path after the screenshot at the time point.Note: This field may return null, indicating that no valid value can be obtained.
        :param str output_object_path: The output path of the picture file after the snapshot at the time point can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_snapshotByTimeOffset_{definition}_{number}.{format}`.
        :param 'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageArgs' output_storage: The target storage of the file after the screenshot at the time point, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        :param Sequence[float] time_offset_sets: Screenshot time point list, the unit is &lt;font color=red&gt;seconds&lt;/font&gt;. This parameter is no longer recommended, it is recommended that you use the ExtTimeOffsetSet parameter.
        :param Sequence['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetArgs'] watermark_sets: Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        pulumi.set(__self__, "definition", definition)
        if ext_time_offset_sets is not None:
            pulumi.set(__self__, "ext_time_offset_sets", ext_time_offset_sets)
        if object_number_format is not None:
            pulumi.set(__self__, "object_number_format", object_number_format)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)
        if time_offset_sets is not None:
            pulumi.set(__self__, "time_offset_sets", time_offset_sets)
        if watermark_sets is not None:
            pulumi.set(__self__, "watermark_sets", watermark_sets)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Specified time point screenshot template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="extTimeOffsetSets")
    def ext_time_offset_sets(self) -> Optional[Sequence[str]]:
        """
        Screenshot time point list, the time point supports two formats: s and %:;When the string ends with s, it means that the time point is in seconds, such as 3.5s means that the time point is the 3.5th second.When the string ends with %, it means that the time point is the percentage of the video duration, such as 10% means that the time point is the first 10% of the time in the video.
        """
        return pulumi.get(self, "ext_time_offset_sets")

    @property
    @pulumi.getter(name="objectNumberFormat")
    def object_number_format(self) -> Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat']:
        """
        Rules for the `{number}` variable in the output path after the screenshot at the time point.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "object_number_format")

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[str]:
        """
        The output path of the picture file after the snapshot at the time point can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_snapshotByTimeOffset_{definition}_{number}.{format}`.
        """
        return pulumi.get(self, "output_object_path")

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage']:
        """
        The target storage of the file after the screenshot at the time point, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @property
    @pulumi.getter(name="timeOffsetSets")
    def time_offset_sets(self) -> Optional[Sequence[float]]:
        """
        Screenshot time point list, the unit is &lt;font color=red&gt;seconds&lt;/font&gt;. This parameter is no longer recommended, it is recommended that you use the ExtTimeOffsetSet parameter.
        """
        return pulumi.get(self, "time_offset_sets")

    @property
    @pulumi.getter(name="watermarkSets")
    def watermark_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet']]:
        """
        Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        return pulumi.get(self, "watermark_sets")


@pulumi.output_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialValue":
            suggest = "initial_value"
        elif key == "minLength":
            suggest = "min_length"
        elif key == "placeHolder":
            suggest = "place_holder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 increment: Optional[int] = None,
                 initial_value: Optional[int] = None,
                 min_length: Optional[int] = None,
                 place_holder: Optional[str] = None):
        """
        :param int increment: The growth step of the `{number}` variable, the default is 1.
        :param int initial_value: The starting value of `{number}` variable, the default is 0.
        :param int min_length: The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        :param str place_holder: When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if initial_value is not None:
            pulumi.set(__self__, "initial_value", initial_value)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if place_holder is not None:
            pulumi.set(__self__, "place_holder", place_holder)

    @property
    @pulumi.getter
    def increment(self) -> Optional[int]:
        """
        The growth step of the `{number}` variable, the default is 1.
        """
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="initialValue")
    def initial_value(self) -> Optional[int]:
        """
        The starting value of `{number}` variable, the default is 0.
        """
        return pulumi.get(self, "initial_value")

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[int]:
        """
        The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        """
        return pulumi.get(self, "min_length")

    @property
    @pulumi.getter(name="placeHolder")
    def place_holder(self) -> Optional[str]:
        """
        When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        return pulumi.get(self, "place_holder")


@pulumi.output_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosOutputStorage":
            suggest = "cos_output_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_output_storage: Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorage'] = None):
        """
        :param str type: The type of media processing output object storage location, now only supports COS.
        :param 'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorageArgs' cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorage']:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")


@pulumi.output_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorage(dict):
    def __init__(__self__, *,
                 bucket: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param str region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "rawParameter":
            suggest = "raw_parameter"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 end_time_offset: Optional[float] = None,
                 raw_parameter: Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter'] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param int definition: Watermark Template ID.
        :param float end_time_offset: End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        :param 'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterArgs' raw_parameter: Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        :param float start_time_offset: The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        :param str svg_content: SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        :param str text_content: Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if raw_parameter is not None:
            pulumi.set(__self__, "raw_parameter", raw_parameter)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Watermark Template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="rawParameter")
    def raw_parameter(self) -> Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter']:
        """
        Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        """
        return pulumi.get(self, "raw_parameter")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coordinateOrigin":
            suggest = "coordinate_origin"
        elif key == "imageTemplate":
            suggest = "image_template"
        elif key == "xPos":
            suggest = "x_pos"
        elif key == "yPos":
            suggest = "y_pos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 coordinate_origin: Optional[str] = None,
                 image_template: Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate'] = None,
                 x_pos: Optional[str] = None,
                 y_pos: Optional[str] = None):
        """
        :param str type: Watermark type, optional value:image: image watermark.
        :param str coordinate_origin: Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        :param 'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateArgs' image_template: Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        :param str x_pos: The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        :param str y_pos: The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        pulumi.set(__self__, "type", type)
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if image_template is not None:
            pulumi.set(__self__, "image_template", image_template)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Watermark type, optional value:image: image watermark.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[str]:
        """
        Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @property
    @pulumi.getter(name="imageTemplate")
    def image_template(self) -> Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate']:
        """
        Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        """
        return pulumi.get(self, "image_template")

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[str]:
        """
        The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "x_pos")

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[str]:
        """
        The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "y_pos")


@pulumi.output_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageContent":
            suggest = "image_content"
        elif key == "repeatType":
            suggest = "repeat_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_content: 'outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent',
                 height: Optional[str] = None,
                 repeat_type: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param 'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs' image_content: The input content of the watermark image. Support jpeg, png image format.
        :param str height: The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        :param str repeat_type: Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        :param str width: The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> 'outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent':
        """
        The input content of the watermark image. Support jpeg, png image format.
        """
        return pulumi.get(self, "image_content")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[str]:
        """
        Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        """
        return pulumi.get(self, "repeat_type")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosInputInfo":
            suggest = "cos_input_info"
        elif key == "urlInputInfo":
            suggest = "url_input_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_input_info: Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo'] = None,
                 url_input_info: Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo'] = None):
        """
        :param str type: Enter the type of source object, which supports COS and URL.
        :param 'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs' cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param 'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs' url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo']:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo']:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")


@pulumi.output_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo(dict):
    def __init__(__self__, *,
                 bucket: str,
                 object: str,
                 region: str):
        """
        :param str bucket: The name of the COS Bucket where the media processing object file is located.
        :param str object: Input path for media processing object files.
        :param str region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Video URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "headTailParameter":
            suggest = "head_tail_parameter"
        elif key == "mosaicSets":
            suggest = "mosaic_sets"
        elif key == "objectNumberFormat":
            suggest = "object_number_format"
        elif key == "outputObjectPath":
            suggest = "output_object_path"
        elif key == "outputStorage":
            suggest = "output_storage"
        elif key == "overrideParameter":
            suggest = "override_parameter"
        elif key == "rawParameter":
            suggest = "raw_parameter"
        elif key == "segmentObjectName":
            suggest = "segment_object_name"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "watermarkSets":
            suggest = "watermark_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 end_time_offset: Optional[float] = None,
                 head_tail_parameter: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter'] = None,
                 mosaic_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet']] = None,
                 object_number_format: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat'] = None,
                 output_object_path: Optional[str] = None,
                 output_storage: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage'] = None,
                 override_parameter: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter'] = None,
                 raw_parameter: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetRawParameter'] = None,
                 segment_object_name: Optional[str] = None,
                 start_time_offset: Optional[float] = None,
                 watermark_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet']] = None):
        """
        :param int definition: Video Transcoding Template ID.
        :param float end_time_offset: End time offset of video after transcoding, unit: second.Do not fill in or fill in 0, indicating that the transcoded video continues until the end of the original video.When the value is greater than 0 (assumed to be n), it means that the transcoded video lasts until the nth second of the original video and terminates.When the value is less than 0 (assumed to be -n), it means that the transcoded video lasts until n seconds before the end of the original video.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterArgs' head_tail_parameter: Opening and ending parameters.Note: This field may return null, indicating that no valid value can be obtained.
        :param Sequence['WorkflowMediaProcessTaskTranscodeTaskSetMosaicSetArgs'] mosaic_sets: Mosaic list, up to 10 sheets can be supported.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormatArgs' object_number_format: Rules for the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid value can be obtained.
        :param str output_object_path: The output path of the main file after transcoding can be a relative path or an absolute path. If not filled, the default is a relative path: {inputName}_transcode_{definition}.{format}.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageArgs' output_storage: The target storage of the transcoded file, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterArgs' override_parameter: Video transcoding custom parameters, valid when Definition is not filled with 0.When some transcoding parameters in this structure are filled in, the parameters in the transcoding template will be overwritten with the filled parameters.This parameter is used in highly customized scenarios, it is recommended that you only use Definition to specify transcoding parameters.Note: This field may return null, indicating that no valid value can be obtained.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterArgs' raw_parameter: Video transcoding custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios. It is recommended that you use Definition to specify transcoding parameters first.Note: This field may return null, indicating that no valid value can be obtained.
        :param str segment_object_name: The output path of the transcoded fragment file (the path of ts when transcoding HLS), can only be a relative path. If not filled, the default is: `{inputName}_transcode_{definition}_{number}.{format}.
        :param float start_time_offset: The start time offset of the transcoded video, unit: second.Do not fill in or fill in 0, indicating that the transcoded video starts from the beginning of the original video.When the value is greater than 0 (assumed to be n), it means that the transcoded video starts from the nth second position of the original video.When the value is less than 0 (assumed to be -n), it means that the transcoded video starts from the position n seconds before the end of the original video.
        :param Sequence['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetArgs'] watermark_sets: Watermark list, support multiple pictures or text watermarks, up to 10.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if head_tail_parameter is not None:
            pulumi.set(__self__, "head_tail_parameter", head_tail_parameter)
        if mosaic_sets is not None:
            pulumi.set(__self__, "mosaic_sets", mosaic_sets)
        if object_number_format is not None:
            pulumi.set(__self__, "object_number_format", object_number_format)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)
        if override_parameter is not None:
            pulumi.set(__self__, "override_parameter", override_parameter)
        if raw_parameter is not None:
            pulumi.set(__self__, "raw_parameter", raw_parameter)
        if segment_object_name is not None:
            pulumi.set(__self__, "segment_object_name", segment_object_name)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if watermark_sets is not None:
            pulumi.set(__self__, "watermark_sets", watermark_sets)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Video Transcoding Template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of video after transcoding, unit: second.Do not fill in or fill in 0, indicating that the transcoded video continues until the end of the original video.When the value is greater than 0 (assumed to be n), it means that the transcoded video lasts until the nth second of the original video and terminates.When the value is less than 0 (assumed to be -n), it means that the transcoded video lasts until n seconds before the end of the original video.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="headTailParameter")
    def head_tail_parameter(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter']:
        """
        Opening and ending parameters.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "head_tail_parameter")

    @property
    @pulumi.getter(name="mosaicSets")
    def mosaic_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet']]:
        """
        Mosaic list, up to 10 sheets can be supported.
        """
        return pulumi.get(self, "mosaic_sets")

    @property
    @pulumi.getter(name="objectNumberFormat")
    def object_number_format(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat']:
        """
        Rules for the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "object_number_format")

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[str]:
        """
        The output path of the main file after transcoding can be a relative path or an absolute path. If not filled, the default is a relative path: {inputName}_transcode_{definition}.{format}.
        """
        return pulumi.get(self, "output_object_path")

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage']:
        """
        The target storage of the transcoded file, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @property
    @pulumi.getter(name="overrideParameter")
    def override_parameter(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter']:
        """
        Video transcoding custom parameters, valid when Definition is not filled with 0.When some transcoding parameters in this structure are filled in, the parameters in the transcoding template will be overwritten with the filled parameters.This parameter is used in highly customized scenarios, it is recommended that you only use Definition to specify transcoding parameters.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "override_parameter")

    @property
    @pulumi.getter(name="rawParameter")
    def raw_parameter(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetRawParameter']:
        """
        Video transcoding custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios. It is recommended that you use Definition to specify transcoding parameters first.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "raw_parameter")

    @property
    @pulumi.getter(name="segmentObjectName")
    def segment_object_name(self) -> Optional[str]:
        """
        The output path of the transcoded fragment file (the path of ts when transcoding HLS), can only be a relative path. If not filled, the default is: `{inputName}_transcode_{definition}_{number}.{format}.
        """
        return pulumi.get(self, "segment_object_name")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        The start time offset of the transcoded video, unit: second.Do not fill in or fill in 0, indicating that the transcoded video starts from the beginning of the original video.When the value is greater than 0 (assumed to be n), it means that the transcoded video starts from the nth second position of the original video.When the value is less than 0 (assumed to be -n), it means that the transcoded video starts from the position n seconds before the end of the original video.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="watermarkSets")
    def watermark_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet']]:
        """
        Watermark list, support multiple pictures or text watermarks, up to 10.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "watermark_sets")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headSets":
            suggest = "head_sets"
        elif key == "tailSets":
            suggest = "tail_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 head_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet']] = None,
                 tail_sets: Optional[Sequence['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet']] = None):
        """
        :param Sequence['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetArgs'] head_sets: Title list.
        :param Sequence['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetArgs'] tail_sets: Ending List.
        """
        if head_sets is not None:
            pulumi.set(__self__, "head_sets", head_sets)
        if tail_sets is not None:
            pulumi.set(__self__, "tail_sets", tail_sets)

    @property
    @pulumi.getter(name="headSets")
    def head_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet']]:
        """
        Title list.
        """
        return pulumi.get(self, "head_sets")

    @property
    @pulumi.getter(name="tailSets")
    def tail_sets(self) -> Optional[Sequence['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet']]:
        """
        Ending List.
        """
        return pulumi.get(self, "tail_sets")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosInputInfo":
            suggest = "cos_input_info"
        elif key == "urlInputInfo":
            suggest = "url_input_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_input_info: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfo'] = None,
                 url_input_info: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfo'] = None):
        """
        :param str type: Enter the type of source object, which supports COS and URL.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfoArgs' cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfoArgs' url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfo']:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfo']:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfo(dict):
    def __init__(__self__, *,
                 bucket: str,
                 object: str,
                 region: str):
        """
        :param str bucket: The name of the COS Bucket where the media processing object file is located.
        :param str object: Input path for media processing object files.
        :param str region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfo(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Video URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosInputInfo":
            suggest = "cos_input_info"
        elif key == "urlInputInfo":
            suggest = "url_input_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_input_info: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfo'] = None,
                 url_input_info: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfo'] = None):
        """
        :param str type: Enter the type of source object, which supports COS and URL.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfoArgs' cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfoArgs' url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfo']:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfo']:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfo(dict):
    def __init__(__self__, *,
                 bucket: str,
                 object: str,
                 region: str):
        """
        :param str bucket: The name of the COS Bucket where the media processing object file is located.
        :param str object: Input path for media processing object files.
        :param str region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfo(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Video URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coordinateOrigin":
            suggest = "coordinate_origin"
        elif key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "xPos":
            suggest = "x_pos"
        elif key == "yPos":
            suggest = "y_pos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 coordinate_origin: Optional[str] = None,
                 end_time_offset: Optional[float] = None,
                 height: Optional[str] = None,
                 start_time_offset: Optional[float] = None,
                 width: Optional[str] = None,
                 x_pos: Optional[str] = None,
                 y_pos: Optional[str] = None):
        """
        :param str coordinate_origin: Origin position, currently only supports:TopLeft: Indicates that the coordinate origin is located in the upper left corner of the video image, and the origin of the mosaic is the upper left corner of the picture or textDefault: TopLeft.
        :param float end_time_offset: The end time offset of the mosaic, unit: second.Fill in or fill in 0, indicating that the mosaic continues until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the mosaic lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the mosaic lasts until it disappears n seconds before the end of the screen.
        :param str height: The height of the mosaic. Support %, px two formats.When the string ends with %, it means that the mosaic Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the mosaic Height unit is pixel, such as 100px means that the Height is 100 pixels.Default: 10%.
        :param float start_time_offset: The start time offset of the mosaic, unit: second. Do not fill or fill in 0, which means that the mosaic will start to appear when the screen appears.Fill in or fill in 0, which means that the mosaic will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the mosaic appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the mosaic starts to appear n seconds before the end of the screen.
        :param str width: The width of the mosaic. Support %, px two formats:When the string ends with %, it means that the mosaic Width is the percentage size of the video width, such as 10% means that the Width is 10% of the video width.The string ends with px, indicating that the mosaic Width unit is pixels, such as 100px indicates that the Width is 100 pixels.Default: 10%.
        :param str x_pos: The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        :param str y_pos: The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[str]:
        """
        Origin position, currently only supports:TopLeft: Indicates that the coordinate origin is located in the upper left corner of the video image, and the origin of the mosaic is the upper left corner of the picture or textDefault: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        The end time offset of the mosaic, unit: second.Fill in or fill in 0, indicating that the mosaic continues until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the mosaic lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the mosaic lasts until it disappears n seconds before the end of the screen.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        The height of the mosaic. Support %, px two formats.When the string ends with %, it means that the mosaic Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the mosaic Height unit is pixel, such as 100px means that the Height is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        The start time offset of the mosaic, unit: second. Do not fill or fill in 0, which means that the mosaic will start to appear when the screen appears.Fill in or fill in 0, which means that the mosaic will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the mosaic appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the mosaic starts to appear n seconds before the end of the screen.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        The width of the mosaic. Support %, px two formats:When the string ends with %, it means that the mosaic Width is the percentage size of the video width, such as 10% means that the Width is 10% of the video width.The string ends with px, indicating that the mosaic Width unit is pixels, such as 100px indicates that the Width is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[str]:
        """
        The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "x_pos")

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[str]:
        """
        The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "y_pos")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialValue":
            suggest = "initial_value"
        elif key == "minLength":
            suggest = "min_length"
        elif key == "placeHolder":
            suggest = "place_holder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 increment: Optional[int] = None,
                 initial_value: Optional[int] = None,
                 min_length: Optional[int] = None,
                 place_holder: Optional[str] = None):
        """
        :param int increment: The growth step of the `{number}` variable, the default is 1.
        :param int initial_value: The starting value of `{number}` variable, the default is 0.
        :param int min_length: The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        :param str place_holder: When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if initial_value is not None:
            pulumi.set(__self__, "initial_value", initial_value)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if place_holder is not None:
            pulumi.set(__self__, "place_holder", place_holder)

    @property
    @pulumi.getter
    def increment(self) -> Optional[int]:
        """
        The growth step of the `{number}` variable, the default is 1.
        """
        return pulumi.get(self, "increment")

    @property
    @pulumi.getter(name="initialValue")
    def initial_value(self) -> Optional[int]:
        """
        The starting value of `{number}` variable, the default is 0.
        """
        return pulumi.get(self, "initial_value")

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[int]:
        """
        The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        """
        return pulumi.get(self, "min_length")

    @property
    @pulumi.getter(name="placeHolder")
    def place_holder(self) -> Optional[str]:
        """
        When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        return pulumi.get(self, "place_holder")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosOutputStorage":
            suggest = "cos_output_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_output_storage: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorage'] = None):
        """
        :param str type: The type of media processing output object storage location, now only supports COS.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorageArgs' cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorage']:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorage(dict):
    def __init__(__self__, *,
                 bucket: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param str region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioTemplate":
            suggest = "audio_template"
        elif key == "removeAudio":
            suggest = "remove_audio"
        elif key == "removeVideo":
            suggest = "remove_video"
        elif key == "subtitleTemplate":
            suggest = "subtitle_template"
        elif key == "tehdConfig":
            suggest = "tehd_config"
        elif key == "videoTemplate":
            suggest = "video_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_template: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate'] = None,
                 container: Optional[str] = None,
                 remove_audio: Optional[int] = None,
                 remove_video: Optional[int] = None,
                 subtitle_template: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate'] = None,
                 tehd_config: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig'] = None,
                 video_template: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate'] = None):
        """
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplateArgs' audio_template: Audio stream configuration parameters.
        :param str container: Encapsulation format, optional values: mp4, flv, hls, mp3, flac, ogg, m4a. Among them, mp3, flac, ogg, m4a are pure audio files.
        :param int remove_audio: Whether to remove audio data, value:0: reserved.1: remove.
        :param int remove_video: Whether to remove video data, value:0: reserved.1: remove.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplateArgs' subtitle_template: Subtitle Stream Configuration Parameters.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfigArgs' tehd_config: Ultra-fast HD transcoding parameters.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplateArgs' video_template: Video streaming configuration parameters.
        """
        if audio_template is not None:
            pulumi.set(__self__, "audio_template", audio_template)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if remove_audio is not None:
            pulumi.set(__self__, "remove_audio", remove_audio)
        if remove_video is not None:
            pulumi.set(__self__, "remove_video", remove_video)
        if subtitle_template is not None:
            pulumi.set(__self__, "subtitle_template", subtitle_template)
        if tehd_config is not None:
            pulumi.set(__self__, "tehd_config", tehd_config)
        if video_template is not None:
            pulumi.set(__self__, "video_template", video_template)

    @property
    @pulumi.getter(name="audioTemplate")
    def audio_template(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate']:
        """
        Audio stream configuration parameters.
        """
        return pulumi.get(self, "audio_template")

    @property
    @pulumi.getter
    def container(self) -> Optional[str]:
        """
        Encapsulation format, optional values: mp4, flv, hls, mp3, flac, ogg, m4a. Among them, mp3, flac, ogg, m4a are pure audio files.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> Optional[int]:
        """
        Whether to remove audio data, value:0: reserved.1: remove.
        """
        return pulumi.get(self, "remove_audio")

    @property
    @pulumi.getter(name="removeVideo")
    def remove_video(self) -> Optional[int]:
        """
        Whether to remove video data, value:0: reserved.1: remove.
        """
        return pulumi.get(self, "remove_video")

    @property
    @pulumi.getter(name="subtitleTemplate")
    def subtitle_template(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate']:
        """
        Subtitle Stream Configuration Parameters.
        """
        return pulumi.get(self, "subtitle_template")

    @property
    @pulumi.getter(name="tehdConfig")
    def tehd_config(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig']:
        """
        Ultra-fast HD transcoding parameters.
        """
        return pulumi.get(self, "tehd_config")

    @property
    @pulumi.getter(name="videoTemplate")
    def video_template(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate']:
        """
        Video streaming configuration parameters.
        """
        return pulumi.get(self, "video_template")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioChannel":
            suggest = "audio_channel"
        elif key == "sampleRate":
            suggest = "sample_rate"
        elif key == "streamSelects":
            suggest = "stream_selects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_channel: Optional[int] = None,
                 bitrate: Optional[int] = None,
                 codec: Optional[str] = None,
                 sample_rate: Optional[int] = None,
                 stream_selects: Optional[Sequence[int]] = None):
        """
        :param int audio_channel: Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        :param int bitrate: Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        :param str codec: Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        :param int sample_rate: Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        :param Sequence[int] stream_selects: Specifies the audio track to preserve for the output. The default is to keep all sources.
        """
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)
        if stream_selects is not None:
            pulumi.set(__self__, "stream_selects", stream_selects)

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[int]:
        """
        Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        return pulumi.get(self, "audio_channel")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[int]:
        """
        Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[int]:
        """
        Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="streamSelects")
    def stream_selects(self) -> Optional[Sequence[int]]:
        """
        Specifies the audio track to preserve for the output. The default is to keep all sources.
        """
        return pulumi.get(self, "stream_selects")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontAlpha":
            suggest = "font_alpha"
        elif key == "fontColor":
            suggest = "font_color"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "fontType":
            suggest = "font_type"
        elif key == "streamIndex":
            suggest = "stream_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_alpha: Optional[float] = None,
                 font_color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 font_type: Optional[str] = None,
                 path: Optional[str] = None,
                 stream_index: Optional[int] = None):
        """
        :param float font_alpha: Text transparency, value range: (0, 1].0: fully transparent.1: fully opaque.Default: 1.
        :param str font_color: Font color, format: 0xRRGGBB, default value: 0xFFFFFF (white).
        :param str font_size: Font size, format: Npx, N is a value, if not specified, the subtitle file shall prevail.
        :param str font_type: Font type.hei.ttf, song.ttf, simkai.ttf, arial.ttf.Default: hei.ttf.
        :param str path: The address of the subtitle file to be compressed into the video.
        :param int stream_index: Specifies the subtitle track to be compressed into the video. If there is a specified Path, the Path has a higher priority. Path and StreamIndex specify at least one.
        """
        if font_alpha is not None:
            pulumi.set(__self__, "font_alpha", font_alpha)
        if font_color is not None:
            pulumi.set(__self__, "font_color", font_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if font_type is not None:
            pulumi.set(__self__, "font_type", font_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if stream_index is not None:
            pulumi.set(__self__, "stream_index", stream_index)

    @property
    @pulumi.getter(name="fontAlpha")
    def font_alpha(self) -> Optional[float]:
        """
        Text transparency, value range: (0, 1].0: fully transparent.1: fully opaque.Default: 1.
        """
        return pulumi.get(self, "font_alpha")

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        """
        Font color, format: 0xRRGGBB, default value: 0xFFFFFF (white).
        """
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        Font size, format: Npx, N is a value, if not specified, the subtitle file shall prevail.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="fontType")
    def font_type(self) -> Optional[str]:
        """
        Font type.hei.ttf, song.ttf, simkai.ttf, arial.ttf.Default: hei.ttf.
        """
        return pulumi.get(self, "font_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The address of the subtitle file to be compressed into the video.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="streamIndex")
    def stream_index(self) -> Optional[int]:
        """
        Specifies the subtitle track to be compressed into the video. If there is a specified Path, the Path has a higher priority. Path and StreamIndex specify at least one.
        """
        return pulumi.get(self, "stream_index")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVideoBitrate":
            suggest = "max_video_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_video_bitrate: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param int max_video_bitrate: The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        :param str type: Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        """
        if max_video_bitrate is not None:
            pulumi.set(__self__, "max_video_bitrate", max_video_bitrate)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="maxVideoBitrate")
    def max_video_bitrate(self) -> Optional[int]:
        """
        The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        """
        return pulumi.get(self, "max_video_bitrate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentAdaptStream":
            suggest = "content_adapt_stream"
        elif key == "fillType":
            suggest = "fill_type"
        elif key == "resolutionAdaptive":
            suggest = "resolution_adaptive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: Optional[int] = None,
                 codec: Optional[str] = None,
                 content_adapt_stream: Optional[int] = None,
                 fill_type: Optional[str] = None,
                 fps: Optional[int] = None,
                 gop: Optional[int] = None,
                 height: Optional[int] = None,
                 resolution_adaptive: Optional[str] = None,
                 vcrf: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param int bitrate: Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        :param str codec: Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        :param int content_adapt_stream: Content Adaptive Encoding. optional value:0: not open.1: open.Default: 0.When this parameter is turned on, multiple code streams with different resolutions and different bit rates will be adaptively generated. The width and height of the VideoTemplate are the maximum resolutions among the multiple code streams, and the bit rates in the VideoTemplate are multiple code rates. The highest bit rate in the stream, the vcrf in VideoTemplate is the highest quality among multiple bit streams. When the resolution, bit rate and vcrf are not set, the highest resolution generated by the ContentAdaptStream parameter is the resolution of the video source, and the video quality is close to vmaf95. To enable this parameter or learn about billing details, please contact your Tencent Cloud Business.
        :param str fill_type: Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched;.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        :param int fps: Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        :param int gop: The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        :param int height: The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        :param str resolution_adaptive: Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        :param int vcrf: Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        :param int width: The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if content_adapt_stream is not None:
            pulumi.set(__self__, "content_adapt_stream", content_adapt_stream)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[int]:
        """
        Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="contentAdaptStream")
    def content_adapt_stream(self) -> Optional[int]:
        """
        Content Adaptive Encoding. optional value:0: not open.1: open.Default: 0.When this parameter is turned on, multiple code streams with different resolutions and different bit rates will be adaptively generated. The width and height of the VideoTemplate are the maximum resolutions among the multiple code streams, and the bit rates in the VideoTemplate are multiple code rates. The highest bit rate in the stream, the vcrf in VideoTemplate is the highest quality among multiple bit streams. When the resolution, bit rate and vcrf are not set, the highest resolution generated by the ContentAdaptStream parameter is the resolution of the video source, and the video quality is close to vmaf95. To enable this parameter or learn about billing details, please contact your Tencent Cloud Business.
        """
        return pulumi.get(self, "content_adapt_stream")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[str]:
        """
        Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched;.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        """
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def fps(self) -> Optional[int]:
        """
        Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter
    def gop(self) -> Optional[int]:
        """
        The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        """
        return pulumi.get(self, "gop")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[str]:
        """
        Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        """
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[int]:
        """
        Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        """
        return pulumi.get(self, "vcrf")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetRawParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioTemplate":
            suggest = "audio_template"
        elif key == "removeAudio":
            suggest = "remove_audio"
        elif key == "removeVideo":
            suggest = "remove_video"
        elif key == "tehdConfig":
            suggest = "tehd_config"
        elif key == "videoTemplate":
            suggest = "video_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetRawParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetRawParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetRawParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: str,
                 audio_template: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate'] = None,
                 remove_audio: Optional[int] = None,
                 remove_video: Optional[int] = None,
                 tehd_config: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig'] = None,
                 video_template: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate'] = None):
        """
        :param str container: Encapsulation format, optional values: mp4, flv, hls, mp3, flac, ogg, m4a. Among them, mp3, flac, ogg, m4a are pure audio files.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplateArgs' audio_template: Audio stream configuration parameters, when RemoveAudio is 0, this field is required.
        :param int remove_audio: Whether to remove audio data, value:0: reserved.1: remove.Default: 0.
        :param int remove_video: Whether to remove video data, value:0: reserved.1: remove.Default: 0.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfigArgs' tehd_config: Ultra-fast HD transcoding parameters.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplateArgs' video_template: Video stream configuration parameters, when RemoveVideo is 0, this field is required.
        """
        pulumi.set(__self__, "container", container)
        if audio_template is not None:
            pulumi.set(__self__, "audio_template", audio_template)
        if remove_audio is not None:
            pulumi.set(__self__, "remove_audio", remove_audio)
        if remove_video is not None:
            pulumi.set(__self__, "remove_video", remove_video)
        if tehd_config is not None:
            pulumi.set(__self__, "tehd_config", tehd_config)
        if video_template is not None:
            pulumi.set(__self__, "video_template", video_template)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        Encapsulation format, optional values: mp4, flv, hls, mp3, flac, ogg, m4a. Among them, mp3, flac, ogg, m4a are pure audio files.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="audioTemplate")
    def audio_template(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate']:
        """
        Audio stream configuration parameters, when RemoveAudio is 0, this field is required.
        """
        return pulumi.get(self, "audio_template")

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> Optional[int]:
        """
        Whether to remove audio data, value:0: reserved.1: remove.Default: 0.
        """
        return pulumi.get(self, "remove_audio")

    @property
    @pulumi.getter(name="removeVideo")
    def remove_video(self) -> Optional[int]:
        """
        Whether to remove video data, value:0: reserved.1: remove.Default: 0.
        """
        return pulumi.get(self, "remove_video")

    @property
    @pulumi.getter(name="tehdConfig")
    def tehd_config(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig']:
        """
        Ultra-fast HD transcoding parameters.
        """
        return pulumi.get(self, "tehd_config")

    @property
    @pulumi.getter(name="videoTemplate")
    def video_template(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate']:
        """
        Video stream configuration parameters, when RemoveVideo is 0, this field is required.
        """
        return pulumi.get(self, "video_template")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"
        elif key == "audioChannel":
            suggest = "audio_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 sample_rate: int,
                 audio_channel: Optional[int] = None):
        """
        :param int bitrate: Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        :param str codec: Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        :param int sample_rate: Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        :param int audio_channel: Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> int:
        """
        Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[int]:
        """
        Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        return pulumi.get(self, "audio_channel")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVideoBitrate":
            suggest = "max_video_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 max_video_bitrate: Optional[int] = None):
        """
        :param str type: Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        :param int max_video_bitrate: The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        """
        pulumi.set(__self__, "type", type)
        if max_video_bitrate is not None:
            pulumi.set(__self__, "max_video_bitrate", max_video_bitrate)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="maxVideoBitrate")
    def max_video_bitrate(self) -> Optional[int]:
        """
        The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        """
        return pulumi.get(self, "max_video_bitrate")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillType":
            suggest = "fill_type"
        elif key == "resolutionAdaptive":
            suggest = "resolution_adaptive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 fps: int,
                 fill_type: Optional[str] = None,
                 gop: Optional[int] = None,
                 height: Optional[int] = None,
                 resolution_adaptive: Optional[str] = None,
                 vcrf: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param int bitrate: Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        :param str codec: Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        :param int fps: Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        :param str fill_type: Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched;.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        :param int gop: The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        :param int height: The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        :param str resolution_adaptive: Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        :param int vcrf: Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        :param int width: The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def fps(self) -> int:
        """
        Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[str]:
        """
        Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched;.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        """
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def gop(self) -> Optional[int]:
        """
        The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        """
        return pulumi.get(self, "gop")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[str]:
        """
        Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        """
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[int]:
        """
        Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        """
        return pulumi.get(self, "vcrf")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "rawParameter":
            suggest = "raw_parameter"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: int,
                 end_time_offset: Optional[float] = None,
                 raw_parameter: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter'] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param int definition: Watermark Template ID.
        :param float end_time_offset: End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterArgs' raw_parameter: Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        :param float start_time_offset: The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        :param str svg_content: SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        :param str text_content: Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if raw_parameter is not None:
            pulumi.set(__self__, "raw_parameter", raw_parameter)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> int:
        """
        Watermark Template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="rawParameter")
    def raw_parameter(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter']:
        """
        Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        """
        return pulumi.get(self, "raw_parameter")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coordinateOrigin":
            suggest = "coordinate_origin"
        elif key == "imageTemplate":
            suggest = "image_template"
        elif key == "xPos":
            suggest = "x_pos"
        elif key == "yPos":
            suggest = "y_pos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 coordinate_origin: Optional[str] = None,
                 image_template: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate'] = None,
                 x_pos: Optional[str] = None,
                 y_pos: Optional[str] = None):
        """
        :param str type: Watermark type, optional value:image: image watermark.
        :param str coordinate_origin: Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateArgs' image_template: Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        :param str x_pos: The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        :param str y_pos: The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        pulumi.set(__self__, "type", type)
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if image_template is not None:
            pulumi.set(__self__, "image_template", image_template)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Watermark type, optional value:image: image watermark.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[str]:
        """
        Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @property
    @pulumi.getter(name="imageTemplate")
    def image_template(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate']:
        """
        Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        """
        return pulumi.get(self, "image_template")

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[str]:
        """
        The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "x_pos")

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[str]:
        """
        The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "y_pos")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageContent":
            suggest = "image_content"
        elif key == "repeatType":
            suggest = "repeat_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_content: 'outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent',
                 height: Optional[str] = None,
                 repeat_type: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs' image_content: The input content of the watermark image. Support jpeg, png image format.
        :param str height: The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        :param str repeat_type: Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        :param str width: The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> 'outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent':
        """
        The input content of the watermark image. Support jpeg, png image format.
        """
        return pulumi.get(self, "image_content")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[str]:
        """
        Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        """
        return pulumi.get(self, "repeat_type")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosInputInfo":
            suggest = "cos_input_info"
        elif key == "urlInputInfo":
            suggest = "url_input_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_input_info: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo'] = None,
                 url_input_info: Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo'] = None):
        """
        :param str type: Enter the type of source object, which supports COS and URL.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs' cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param 'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs' url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo']:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional['outputs.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo']:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo(dict):
    def __init__(__self__, *,
                 bucket: str,
                 object: str,
                 region: str):
        """
        :param str bucket: The name of the COS Bucket where the media processing object file is located.
        :param str object: Input path for media processing object files.
        :param str region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def object(self) -> str:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Video URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WorkflowOutputStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosOutputStorage":
            suggest = "cos_output_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowOutputStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowOutputStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowOutputStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_output_storage: Optional['outputs.WorkflowOutputStorageCosOutputStorage'] = None):
        """
        :param str type: The type of media processing output object storage location, now only supports COS.
        :param 'WorkflowOutputStorageCosOutputStorageArgs' cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional['outputs.WorkflowOutputStorageCosOutputStorage']:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")


@pulumi.output_type
class WorkflowOutputStorageCosOutputStorage(dict):
    def __init__(__self__, *,
                 bucket: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param str region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkflowTaskNotifyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cmqModel":
            suggest = "cmq_model"
        elif key == "cmqRegion":
            suggest = "cmq_region"
        elif key == "notifyMode":
            suggest = "notify_mode"
        elif key == "notifyType":
            suggest = "notify_type"
        elif key == "notifyUrl":
            suggest = "notify_url"
        elif key == "queueName":
            suggest = "queue_name"
        elif key == "topicName":
            suggest = "topic_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTaskNotifyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTaskNotifyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTaskNotifyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cmq_model: Optional[str] = None,
                 cmq_region: Optional[str] = None,
                 notify_mode: Optional[str] = None,
                 notify_type: Optional[str] = None,
                 notify_url: Optional[str] = None,
                 queue_name: Optional[str] = None,
                 topic_name: Optional[str] = None):
        """
        :param str cmq_model: CMQ or TDMQ-CMQ model, there are two kinds of Queue and Topic.
        :param str cmq_region: Region of CMQ or TDMQ-CMQ, such as sh, bj, etc.
        :param str notify_mode: The mode of the workflow notification, the possible values are Finish and Change, leaving blank means Finish.
        :param str notify_type: Notification type, optional value:CMQ: offline, it is recommended to switch to TDMQ-CMQ.TDMQ-CMQ: message queue.URL: When the URL is specified, the HTTP callback is pushed to the address specified by NotifyUrl, the callback protocol is http+json, and the package body content is the same as the output parameters of the parsing event notification interface.SCF: not recommended, additional configuration of SCF in the console is required.Note: CMQ is the default when not filled or empty, if you need to use other types, you need to fill in the corresponding type value.
        :param str notify_url: HTTP callback address, required when NotifyType is URL.
        :param str queue_name: Valid when the model is Queue, indicating the queue name of the CMQ or TDMQ-CMQ that receives the event notification.
        :param str topic_name: Valid when the model is a Topic, indicating the topic name of the CMQ or TDMQ-CMQ that receives event notifications.
        """
        if cmq_model is not None:
            pulumi.set(__self__, "cmq_model", cmq_model)
        if cmq_region is not None:
            pulumi.set(__self__, "cmq_region", cmq_region)
        if notify_mode is not None:
            pulumi.set(__self__, "notify_mode", notify_mode)
        if notify_type is not None:
            pulumi.set(__self__, "notify_type", notify_type)
        if notify_url is not None:
            pulumi.set(__self__, "notify_url", notify_url)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter(name="cmqModel")
    def cmq_model(self) -> Optional[str]:
        """
        CMQ or TDMQ-CMQ model, there are two kinds of Queue and Topic.
        """
        return pulumi.get(self, "cmq_model")

    @property
    @pulumi.getter(name="cmqRegion")
    def cmq_region(self) -> Optional[str]:
        """
        Region of CMQ or TDMQ-CMQ, such as sh, bj, etc.
        """
        return pulumi.get(self, "cmq_region")

    @property
    @pulumi.getter(name="notifyMode")
    def notify_mode(self) -> Optional[str]:
        """
        The mode of the workflow notification, the possible values are Finish and Change, leaving blank means Finish.
        """
        return pulumi.get(self, "notify_mode")

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> Optional[str]:
        """
        Notification type, optional value:CMQ: offline, it is recommended to switch to TDMQ-CMQ.TDMQ-CMQ: message queue.URL: When the URL is specified, the HTTP callback is pushed to the address specified by NotifyUrl, the callback protocol is http+json, and the package body content is the same as the output parameters of the parsing event notification interface.SCF: not recommended, additional configuration of SCF in the console is required.Note: CMQ is the default when not filled or empty, if you need to use other types, you need to fill in the corresponding type value.
        """
        return pulumi.get(self, "notify_type")

    @property
    @pulumi.getter(name="notifyUrl")
    def notify_url(self) -> Optional[str]:
        """
        HTTP callback address, required when NotifyType is URL.
        """
        return pulumi.get(self, "notify_url")

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[str]:
        """
        Valid when the model is Queue, indicating the queue name of the CMQ or TDMQ-CMQ that receives the event notification.
        """
        return pulumi.get(self, "queue_name")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[str]:
        """
        Valid when the model is a Topic, indicating the topic name of the CMQ or TDMQ-CMQ that receives event notifications.
        """
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class WorkflowTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosFileUploadTrigger":
            suggest = "cos_file_upload_trigger"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 cos_file_upload_trigger: Optional['outputs.WorkflowTriggerCosFileUploadTrigger'] = None):
        """
        :param str type: The type of trigger, currently only supports CosFileUpload.
        :param 'WorkflowTriggerCosFileUploadTriggerArgs' cos_file_upload_trigger: Mandatory and valid when Type is CosFileUpload, the rule is triggered for COS.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_file_upload_trigger is not None:
            pulumi.set(__self__, "cos_file_upload_trigger", cos_file_upload_trigger)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of trigger, currently only supports CosFileUpload.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="cosFileUploadTrigger")
    def cos_file_upload_trigger(self) -> Optional['outputs.WorkflowTriggerCosFileUploadTrigger']:
        """
        Mandatory and valid when Type is CosFileUpload, the rule is triggered for COS.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_file_upload_trigger")


@pulumi.output_type
class WorkflowTriggerCosFileUploadTrigger(dict):
    def __init__(__self__, *,
                 bucket: str,
                 region: str,
                 dir: Optional[str] = None,
                 formats: Optional[Sequence[str]] = None):
        """
        :param str bucket: The name of the COS Bucket bound to the workflow.
        :param str region: The park to which the COS Bucket bound to the workflow belongs.
        :param str dir: The input path directory of the workflow binding must be an absolute path, that is, start and end with `/`.
        :param Sequence[str] formats: A list of file formats that are allowed to be triggered by the workflow, if not filled in, it means that files of all formats can trigger the workflow.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "region", region)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if formats is not None:
            pulumi.set(__self__, "formats", formats)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The name of the COS Bucket bound to the workflow.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The park to which the COS Bucket bound to the workflow belongs.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def dir(self) -> Optional[str]:
        """
        The input path directory of the workflow binding must be an absolute path, that is, start and end with `/`.
        """
        return pulumi.get(self, "dir")

    @property
    @pulumi.getter
    def formats(self) -> Optional[Sequence[str]]:
        """
        A list of file formats that are allowed to be triggered by the workflow, if not filled in, it means that files of all formats can trigger the workflow.
        """
        return pulumi.get(self, "formats")


