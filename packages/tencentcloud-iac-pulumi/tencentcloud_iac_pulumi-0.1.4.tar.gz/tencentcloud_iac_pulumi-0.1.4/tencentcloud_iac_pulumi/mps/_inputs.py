# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'AdaptiveDynamicStreamingTemplateStreamInfoArgs',
    'AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs',
    'AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs',
    'AiAnalysisTemplateClassificationConfigureArgs',
    'AiAnalysisTemplateCoverConfigureArgs',
    'AiAnalysisTemplateFrameTagConfigureArgs',
    'AiAnalysisTemplateTagConfigureArgs',
    'AiRecognitionTemplateAsrFullTextConfigureArgs',
    'AiRecognitionTemplateAsrWordsConfigureArgs',
    'AiRecognitionTemplateFaceConfigureArgs',
    'AiRecognitionTemplateOcrFullTextConfigureArgs',
    'AiRecognitionTemplateOcrWordsConfigureArgs',
    'TranscodeTemplateAudioTemplateArgs',
    'TranscodeTemplateEnhanceConfigArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepairArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhanceArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceDenoiseArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhanceArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceFrameRateArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceHdrArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhanceArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhanceArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepairArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhanceArgs',
    'TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolutionArgs',
    'TranscodeTemplateTehdConfigArgs',
    'TranscodeTemplateVideoTemplateArgs',
    'WatermarkTemplateImageTemplateArgs',
    'WatermarkTemplateSvgTemplateArgs',
    'WatermarkTemplateTextTemplateArgs',
    'WorkflowAiAnalysisTaskArgs',
    'WorkflowAiContentReviewTaskArgs',
    'WorkflowAiRecognitionTaskArgs',
    'WorkflowMediaProcessTaskArgs',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetArgs',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageArgs',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorageArgs',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetArgs',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterArgs',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateArgs',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs',
    'WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs',
    'WorkflowMediaProcessTaskAnimatedGraphicTaskSetArgs',
    'WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageArgs',
    'WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorageArgs',
    'WorkflowMediaProcessTaskImageSpriteTaskSetArgs',
    'WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormatArgs',
    'WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageArgs',
    'WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorageArgs',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetArgs',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormatArgs',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageArgs',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorageArgs',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetArgs',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterArgs',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateArgs',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs',
    'WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetArgs',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormatArgs',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageArgs',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorageArgs',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetArgs',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterArgs',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateArgs',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs',
    'WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfoArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfoArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfoArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfoArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetMosaicSetArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormatArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorageArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplateArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplateArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfigArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplateArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplateArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfigArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplateArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs',
    'WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs',
    'WorkflowOutputStorageArgs',
    'WorkflowOutputStorageCosOutputStorageArgs',
    'WorkflowTaskNotifyConfigArgs',
    'WorkflowTriggerArgs',
    'WorkflowTriggerCosFileUploadTriggerArgs',
]

@pulumi.input_type
class AdaptiveDynamicStreamingTemplateStreamInfoArgs:
    def __init__(__self__, *,
                 audio: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs'],
                 video: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs'],
                 remove_audio: Optional[pulumi.Input[int]] = None,
                 remove_video: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs'] audio: Audio parameter information.
        :param pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs'] video: Video parameter information.
        :param pulumi.Input[int] remove_audio: Whether to remove audio stream, value:0: reserved.1: remove.
        :param pulumi.Input[int] remove_video: Whether to remove video stream, value:0: reserved.1: remove.
        """
        pulumi.set(__self__, "audio", audio)
        pulumi.set(__self__, "video", video)
        if remove_audio is not None:
            pulumi.set(__self__, "remove_audio", remove_audio)
        if remove_video is not None:
            pulumi.set(__self__, "remove_video", remove_video)

    @property
    @pulumi.getter
    def audio(self) -> pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs']:
        """
        Audio parameter information.
        """
        return pulumi.get(self, "audio")

    @audio.setter
    def audio(self, value: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs']):
        pulumi.set(self, "audio", value)

    @property
    @pulumi.getter
    def video(self) -> pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs']:
        """
        Video parameter information.
        """
        return pulumi.get(self, "video")

    @video.setter
    def video(self, value: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs']):
        pulumi.set(self, "video", value)

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to remove audio stream, value:0: reserved.1: remove.
        """
        return pulumi.get(self, "remove_audio")

    @remove_audio.setter
    def remove_audio(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remove_audio", value)

    @property
    @pulumi.getter(name="removeVideo")
    def remove_video(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to remove video stream, value:0: reserved.1: remove.
        """
        return pulumi.get(self, "remove_video")

    @remove_video.setter
    def remove_video(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remove_video", value)


@pulumi.input_type
class AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 sample_rate: pulumi.Input[int],
                 audio_channel: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        :param pulumi.Input[str] codec: Encoding format of audio stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        :param pulumi.Input[int] sample_rate: Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        :param pulumi.Input[int] audio_channel: Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Encoding format of audio stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> pulumi.Input[int]:
        """
        Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: pulumi.Input[int]):
        pulumi.set(self, "sample_rate", value)

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[pulumi.Input[int]]:
        """
        Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        return pulumi.get(self, "audio_channel")

    @audio_channel.setter
    def audio_channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "audio_channel", value)


@pulumi.input_type
class AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 fps: pulumi.Input[int],
                 fill_type: Optional[pulumi.Input[str]] = None,
                 gop: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 resolution_adaptive: Optional[pulumi.Input[str]] = None,
                 vcrf: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        :param pulumi.Input[str] codec: Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        :param pulumi.Input[int] fps: Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        :param pulumi.Input[str] fill_type: Filling type, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling type:stretch: Stretching, stretching each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched.black: Leave black, keep the video aspect ratio unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and use Gaussian blur for the rest of the edge.Default value: black.Note: Adaptive stream only supports stretch, black.
        :param pulumi.Input[int] gop: The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        :param pulumi.Input[int] height: The maximum value of the height (or short side) of the video streaming, value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default value: 0.
        :param pulumi.Input[str] resolution_adaptive: Adaptive resolution, optional value:open: At this time, Width represents the long side of the video, Height represents the short side of the video.close: At this point, Width represents the width of the video, and Height represents the height of the video.Default value: open.Note: In adaptive mode, Width cannot be smaller than Height.
        :param pulumi.Input[int] vcrf: Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        :param pulumi.Input[int] width: The maximum value of the width (or long side) of the video streaming, value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default value: 0.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def fps(self) -> pulumi.Input[int]:
        """
        Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: pulumi.Input[int]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[pulumi.Input[str]]:
        """
        Filling type, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling type:stretch: Stretching, stretching each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched.black: Leave black, keep the video aspect ratio unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and use Gaussian blur for the rest of the edge.Default value: black.Note: Adaptive stream only supports stretch, black.
        """
        return pulumi.get(self, "fill_type")

    @fill_type.setter
    def fill_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_type", value)

    @property
    @pulumi.getter
    def gop(self) -> Optional[pulumi.Input[int]]:
        """
        The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        """
        return pulumi.get(self, "gop")

    @gop.setter
    def gop(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gop", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum value of the height (or short side) of the video streaming, value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default value: 0.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[pulumi.Input[str]]:
        """
        Adaptive resolution, optional value:open: At this time, Width represents the long side of the video, Height represents the short side of the video.close: At this point, Width represents the width of the video, and Height represents the height of the video.Default value: open.Note: In adaptive mode, Width cannot be smaller than Height.
        """
        return pulumi.get(self, "resolution_adaptive")

    @resolution_adaptive.setter
    def resolution_adaptive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution_adaptive", value)

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[pulumi.Input[int]]:
        """
        Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        """
        return pulumi.get(self, "vcrf")

    @vcrf.setter
    def vcrf(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vcrf", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum value of the width (or long side) of the video streaming, value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default value: 0.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class AiAnalysisTemplateClassificationConfigureArgs:
    def __init__(__self__, *,
                 switch: pulumi.Input[str]):
        """
        :param pulumi.Input[str] switch: Ai classification task switch, optional value:ON/OFF.
        """
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> pulumi.Input[str]:
        """
        Ai classification task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: pulumi.Input[str]):
        pulumi.set(self, "switch", value)


@pulumi.input_type
class AiAnalysisTemplateCoverConfigureArgs:
    def __init__(__self__, *,
                 switch: pulumi.Input[str]):
        """
        :param pulumi.Input[str] switch: Ai cover task switch, optional value:ON/OFF.
        """
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> pulumi.Input[str]:
        """
        Ai cover task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: pulumi.Input[str]):
        pulumi.set(self, "switch", value)


@pulumi.input_type
class AiAnalysisTemplateFrameTagConfigureArgs:
    def __init__(__self__, *,
                 switch: pulumi.Input[str]):
        """
        :param pulumi.Input[str] switch: Ai frame tag task switch, optional value:ON/OFF.
        """
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> pulumi.Input[str]:
        """
        Ai frame tag task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: pulumi.Input[str]):
        pulumi.set(self, "switch", value)


@pulumi.input_type
class AiAnalysisTemplateTagConfigureArgs:
    def __init__(__self__, *,
                 switch: pulumi.Input[str]):
        """
        :param pulumi.Input[str] switch: Ai tag task switch, optional value:ON/OFF.
        """
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> pulumi.Input[str]:
        """
        Ai tag task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: pulumi.Input[str]):
        pulumi.set(self, "switch", value)


@pulumi.input_type
class AiRecognitionTemplateAsrFullTextConfigureArgs:
    def __init__(__self__, *,
                 switch: pulumi.Input[str],
                 subtitle_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] switch: Asr full text recognition task switch, optional value:ON/OFF.
        :param pulumi.Input[str] subtitle_format: Generated subtitle file format, if left blank or blank string means no subtitle file will be generated, optional value:vtt: Generate WebVTT subtitle files.
        """
        pulumi.set(__self__, "switch", switch)
        if subtitle_format is not None:
            pulumi.set(__self__, "subtitle_format", subtitle_format)

    @property
    @pulumi.getter
    def switch(self) -> pulumi.Input[str]:
        """
        Asr full text recognition task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: pulumi.Input[str]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter(name="subtitleFormat")
    def subtitle_format(self) -> Optional[pulumi.Input[str]]:
        """
        Generated subtitle file format, if left blank or blank string means no subtitle file will be generated, optional value:vtt: Generate WebVTT subtitle files.
        """
        return pulumi.get(self, "subtitle_format")

    @subtitle_format.setter
    def subtitle_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subtitle_format", value)


@pulumi.input_type
class AiRecognitionTemplateAsrWordsConfigureArgs:
    def __init__(__self__, *,
                 switch: pulumi.Input[str],
                 label_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] switch: Asr word recognition task switch, optional value:ON/OFF.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] label_sets: Keyword filter label, specify the label of the keyword to be returned. If not filled or empty, all results will be returned.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
        """
        pulumi.set(__self__, "switch", switch)
        if label_sets is not None:
            pulumi.set(__self__, "label_sets", label_sets)

    @property
    @pulumi.getter
    def switch(self) -> pulumi.Input[str]:
        """
        Asr word recognition task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: pulumi.Input[str]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter(name="labelSets")
    def label_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Keyword filter label, specify the label of the keyword to be returned. If not filled or empty, all results will be returned.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
        """
        return pulumi.get(self, "label_sets")

    @label_sets.setter
    def label_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "label_sets", value)


@pulumi.input_type
class AiRecognitionTemplateFaceConfigureArgs:
    def __init__(__self__, *,
                 switch: pulumi.Input[str],
                 default_library_label_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 face_library: Optional[pulumi.Input[str]] = None,
                 score: Optional[pulumi.Input[float]] = None,
                 user_define_library_label_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] switch: Ai face recognition task switch, optional value:ON/OFF.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_library_label_sets: Default face filter tag, specify the tag of the default face that needs to be returned. If not filled or empty, all default face results will be returned. Label optional value:entertainment, sport, politician.
        :param pulumi.Input[str] face_library: Face library selection, optional value:Default, UserDefine, AllDefault value: All, use the system default face library and user-defined face library.
        :param pulumi.Input[float] score: Face recognition filter score, when the recognition result reaches the score above, the recognition result will be returned. The default is 95 points. Value range: 0 - 100.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_define_library_label_sets: User-defined face filter tag, specify the tag of the user-defined face that needs to be returned. If not filled or empty, all custom face results will be returned.The maximum number of tags is 100, and the length of each tag is up to 16 characters.
        """
        pulumi.set(__self__, "switch", switch)
        if default_library_label_sets is not None:
            pulumi.set(__self__, "default_library_label_sets", default_library_label_sets)
        if face_library is not None:
            pulumi.set(__self__, "face_library", face_library)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if user_define_library_label_sets is not None:
            pulumi.set(__self__, "user_define_library_label_sets", user_define_library_label_sets)

    @property
    @pulumi.getter
    def switch(self) -> pulumi.Input[str]:
        """
        Ai face recognition task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: pulumi.Input[str]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter(name="defaultLibraryLabelSets")
    def default_library_label_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Default face filter tag, specify the tag of the default face that needs to be returned. If not filled or empty, all default face results will be returned. Label optional value:entertainment, sport, politician.
        """
        return pulumi.get(self, "default_library_label_sets")

    @default_library_label_sets.setter
    def default_library_label_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_library_label_sets", value)

    @property
    @pulumi.getter(name="faceLibrary")
    def face_library(self) -> Optional[pulumi.Input[str]]:
        """
        Face library selection, optional value:Default, UserDefine, AllDefault value: All, use the system default face library and user-defined face library.
        """
        return pulumi.get(self, "face_library")

    @face_library.setter
    def face_library(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "face_library", value)

    @property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[float]]:
        """
        Face recognition filter score, when the recognition result reaches the score above, the recognition result will be returned. The default is 95 points. Value range: 0 - 100.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "score", value)

    @property
    @pulumi.getter(name="userDefineLibraryLabelSets")
    def user_define_library_label_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        User-defined face filter tag, specify the tag of the user-defined face that needs to be returned. If not filled or empty, all custom face results will be returned.The maximum number of tags is 100, and the length of each tag is up to 16 characters.
        """
        return pulumi.get(self, "user_define_library_label_sets")

    @user_define_library_label_sets.setter
    def user_define_library_label_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_define_library_label_sets", value)


@pulumi.input_type
class AiRecognitionTemplateOcrFullTextConfigureArgs:
    def __init__(__self__, *,
                 switch: pulumi.Input[str]):
        """
        :param pulumi.Input[str] switch: Ocr full text recognition task switch, optional value:ON/OFF.
        """
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> pulumi.Input[str]:
        """
        Ocr full text recognition task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: pulumi.Input[str]):
        pulumi.set(self, "switch", value)


@pulumi.input_type
class AiRecognitionTemplateOcrWordsConfigureArgs:
    def __init__(__self__, *,
                 switch: pulumi.Input[str],
                 label_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] switch: Ocr words recognition task switch, optional value:ON/OFF.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] label_sets: Keyword filter label, specify the label of the keyword to be returned. If not filled or empty, all results will be returned.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
        """
        pulumi.set(__self__, "switch", switch)
        if label_sets is not None:
            pulumi.set(__self__, "label_sets", label_sets)

    @property
    @pulumi.getter
    def switch(self) -> pulumi.Input[str]:
        """
        Ocr words recognition task switch, optional value:ON/OFF.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: pulumi.Input[str]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter(name="labelSets")
    def label_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Keyword filter label, specify the label of the keyword to be returned. If not filled or empty, all results will be returned.The maximum number of tags is 10, and the length of each tag is up to 16 characters.
        """
        return pulumi.get(self, "label_sets")

    @label_sets.setter
    def label_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "label_sets", value)


@pulumi.input_type
class TranscodeTemplateAudioTemplateArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 sample_rate: pulumi.Input[int],
                 audio_channel: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        :param pulumi.Input[str] codec: Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        :param pulumi.Input[int] sample_rate: Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        :param pulumi.Input[int] audio_channel: Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> pulumi.Input[int]:
        """
        Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: pulumi.Input[int]):
        pulumi.set(self, "sample_rate", value)

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[pulumi.Input[int]]:
        """
        Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        return pulumi.get(self, "audio_channel")

    @audio_channel.setter
    def audio_channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "audio_channel", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigArgs:
    def __init__(__self__, *,
                 video_enhance: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceArgs']] = None):
        """
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceArgs'] video_enhance: Video Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if video_enhance is not None:
            pulumi.set(__self__, "video_enhance", video_enhance)

    @property
    @pulumi.getter(name="videoEnhance")
    def video_enhance(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceArgs']]:
        """
        Video Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "video_enhance")

    @video_enhance.setter
    def video_enhance(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceArgs']]):
        pulumi.set(self, "video_enhance", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceArgs:
    def __init__(__self__, *,
                 artifact_repair: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepairArgs']] = None,
                 color_enhance: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhanceArgs']] = None,
                 denoise: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceDenoiseArgs']] = None,
                 face_enhance: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhanceArgs']] = None,
                 frame_rate: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceFrameRateArgs']] = None,
                 hdr: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceHdrArgs']] = None,
                 image_quality_enhance: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhanceArgs']] = None,
                 low_light_enhance: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhanceArgs']] = None,
                 scratch_repair: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepairArgs']] = None,
                 sharp_enhance: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhanceArgs']] = None,
                 super_resolution: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolutionArgs']] = None):
        """
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepairArgs'] artifact_repair: De-artifact (glitch) configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhanceArgs'] color_enhance: Color Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceDenoiseArgs'] denoise: Video Noise Reduction Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhanceArgs'] face_enhance: Face Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceFrameRateArgs'] frame_rate: Interpolation frame rate configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceHdrArgs'] hdr: HDR configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhanceArgs'] image_quality_enhance: Comprehensive Enhanced Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhanceArgs'] low_light_enhance: Low Light Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepairArgs'] scratch_repair: De-scratch configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhanceArgs'] sharp_enhance: Detail Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolutionArgs'] super_resolution: Super resolution configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if artifact_repair is not None:
            pulumi.set(__self__, "artifact_repair", artifact_repair)
        if color_enhance is not None:
            pulumi.set(__self__, "color_enhance", color_enhance)
        if denoise is not None:
            pulumi.set(__self__, "denoise", denoise)
        if face_enhance is not None:
            pulumi.set(__self__, "face_enhance", face_enhance)
        if frame_rate is not None:
            pulumi.set(__self__, "frame_rate", frame_rate)
        if hdr is not None:
            pulumi.set(__self__, "hdr", hdr)
        if image_quality_enhance is not None:
            pulumi.set(__self__, "image_quality_enhance", image_quality_enhance)
        if low_light_enhance is not None:
            pulumi.set(__self__, "low_light_enhance", low_light_enhance)
        if scratch_repair is not None:
            pulumi.set(__self__, "scratch_repair", scratch_repair)
        if sharp_enhance is not None:
            pulumi.set(__self__, "sharp_enhance", sharp_enhance)
        if super_resolution is not None:
            pulumi.set(__self__, "super_resolution", super_resolution)

    @property
    @pulumi.getter(name="artifactRepair")
    def artifact_repair(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepairArgs']]:
        """
        De-artifact (glitch) configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "artifact_repair")

    @artifact_repair.setter
    def artifact_repair(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepairArgs']]):
        pulumi.set(self, "artifact_repair", value)

    @property
    @pulumi.getter(name="colorEnhance")
    def color_enhance(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhanceArgs']]:
        """
        Color Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "color_enhance")

    @color_enhance.setter
    def color_enhance(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhanceArgs']]):
        pulumi.set(self, "color_enhance", value)

    @property
    @pulumi.getter
    def denoise(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceDenoiseArgs']]:
        """
        Video Noise Reduction Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "denoise")

    @denoise.setter
    def denoise(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceDenoiseArgs']]):
        pulumi.set(self, "denoise", value)

    @property
    @pulumi.getter(name="faceEnhance")
    def face_enhance(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhanceArgs']]:
        """
        Face Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "face_enhance")

    @face_enhance.setter
    def face_enhance(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhanceArgs']]):
        pulumi.set(self, "face_enhance", value)

    @property
    @pulumi.getter(name="frameRate")
    def frame_rate(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceFrameRateArgs']]:
        """
        Interpolation frame rate configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "frame_rate")

    @frame_rate.setter
    def frame_rate(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceFrameRateArgs']]):
        pulumi.set(self, "frame_rate", value)

    @property
    @pulumi.getter
    def hdr(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceHdrArgs']]:
        """
        HDR configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "hdr")

    @hdr.setter
    def hdr(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceHdrArgs']]):
        pulumi.set(self, "hdr", value)

    @property
    @pulumi.getter(name="imageQualityEnhance")
    def image_quality_enhance(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhanceArgs']]:
        """
        Comprehensive Enhanced Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "image_quality_enhance")

    @image_quality_enhance.setter
    def image_quality_enhance(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhanceArgs']]):
        pulumi.set(self, "image_quality_enhance", value)

    @property
    @pulumi.getter(name="lowLightEnhance")
    def low_light_enhance(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhanceArgs']]:
        """
        Low Light Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "low_light_enhance")

    @low_light_enhance.setter
    def low_light_enhance(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhanceArgs']]):
        pulumi.set(self, "low_light_enhance", value)

    @property
    @pulumi.getter(name="scratchRepair")
    def scratch_repair(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepairArgs']]:
        """
        De-scratch configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "scratch_repair")

    @scratch_repair.setter
    def scratch_repair(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepairArgs']]):
        pulumi.set(self, "scratch_repair", value)

    @property
    @pulumi.getter(name="sharpEnhance")
    def sharp_enhance(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhanceArgs']]:
        """
        Detail Enhancement Configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "sharp_enhance")

    @sharp_enhance.setter
    def sharp_enhance(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhanceArgs']]):
        pulumi.set(self, "sharp_enhance", value)

    @property
    @pulumi.getter(name="superResolution")
    def super_resolution(self) -> Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolutionArgs']]:
        """
        Super resolution configuration.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "super_resolution")

    @super_resolution.setter
    def super_resolution(self, value: Optional[pulumi.Input['TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolutionArgs']]):
        pulumi.set(self, "super_resolution", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepairArgs:
    def __init__(__self__, *,
                 switch: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param pulumi.Input[str] type: Type, optional value: weak/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type, optional value: weak/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhanceArgs:
    def __init__(__self__, *,
                 switch: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param pulumi.Input[str] type: Type, optional value: weak/normal/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type, optional value: weak/normal/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceDenoiseArgs:
    def __init__(__self__, *,
                 switch: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param pulumi.Input[str] type: Type, optional value: weak/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type, optional value: weak/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhanceArgs:
    def __init__(__self__, *,
                 intensity: Optional[pulumi.Input[float]] = None,
                 switch: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] intensity: Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        if intensity is not None:
            pulumi.set(__self__, "intensity", intensity)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def intensity(self) -> Optional[pulumi.Input[float]]:
        """
        Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "intensity")

    @intensity.setter
    def intensity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "intensity", value)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceFrameRateArgs:
    def __init__(__self__, *,
                 fps: Optional[pulumi.Input[int]] = None,
                 switch: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] fps: Frame rate, value range: [0, 100], unit: Hz.Default value: 0.Note: For transcoding, this parameter will override the Fps inside the VideoTemplate.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def fps(self) -> Optional[pulumi.Input[int]]:
        """
        Frame rate, value range: [0, 100], unit: Hz.Default value: 0.Note: For transcoding, this parameter will override the Fps inside the VideoTemplate.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceHdrArgs:
    def __init__(__self__, *,
                 switch: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param pulumi.Input[str] type: Type, optional value: HDR10/HLG.Default value: HDR10.Note: The encoding method of video needs to be libx265.Note: Video encoding bit depth is 10.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type, optional value: HDR10/HLG.Default value: HDR10.Note: The encoding method of video needs to be libx265.Note: Video encoding bit depth is 10.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhanceArgs:
    def __init__(__self__, *,
                 switch: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param pulumi.Input[str] type: Type, optional value: weak/normal/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type, optional value: weak/normal/strong.Default value: weak.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhanceArgs:
    def __init__(__self__, *,
                 switch: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param pulumi.Input[str] type: Type, optional value: normal.Default value: normal.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type, optional value: normal.Default value: normal.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepairArgs:
    def __init__(__self__, *,
                 intensity: Optional[pulumi.Input[float]] = None,
                 switch: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] intensity: Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        if intensity is not None:
            pulumi.set(__self__, "intensity", intensity)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def intensity(self) -> Optional[pulumi.Input[float]]:
        """
        Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "intensity")

    @intensity.setter
    def intensity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "intensity", value)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhanceArgs:
    def __init__(__self__, *,
                 intensity: Optional[pulumi.Input[float]] = None,
                 switch: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] intensity: Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        if intensity is not None:
            pulumi.set(__self__, "intensity", intensity)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def intensity(self) -> Optional[pulumi.Input[float]]:
        """
        Intensity, value range: 0.0~1.0.Default value: 0.0.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "intensity")

    @intensity.setter
    def intensity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "intensity", value)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)


@pulumi.input_type
class TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolutionArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[int]] = None,
                 switch: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] size: Super resolution multiple, optional value:2: currently only supports 2x super resolution.Default value: 2.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] switch: Capability configuration switch, optional value: ON/OFF.Default value: ON.
        :param pulumi.Input[str] type: Type, optional value:lq: super-resolution for low-definition video with more noise.hq: super resolution for high-definition video.Default value: lq.Note: This field may return null, indicating that no valid value can be obtained.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)
        if switch is not None:
            pulumi.set(__self__, "switch", switch)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        Super resolution multiple, optional value:2: currently only supports 2x super resolution.Default value: 2.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Capability configuration switch, optional value: ON/OFF.Default value: ON.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type, optional value:lq: super-resolution for low-definition video with more noise.hq: super resolution for high-definition video.Default value: lq.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TranscodeTemplateTehdConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 max_video_bitrate: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        :param pulumi.Input[int] max_video_bitrate: The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        """
        pulumi.set(__self__, "type", type)
        if max_video_bitrate is not None:
            pulumi.set(__self__, "max_video_bitrate", max_video_bitrate)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="maxVideoBitrate")
    def max_video_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        """
        return pulumi.get(self, "max_video_bitrate")

    @max_video_bitrate.setter
    def max_video_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_video_bitrate", value)


@pulumi.input_type
class TranscodeTemplateVideoTemplateArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 fps: pulumi.Input[int],
                 fill_type: Optional[pulumi.Input[str]] = None,
                 gop: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 resolution_adaptive: Optional[pulumi.Input[str]] = None,
                 vcrf: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        :param pulumi.Input[str] codec: Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        :param pulumi.Input[int] fps: Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        :param pulumi.Input[str] fill_type: Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        :param pulumi.Input[int] gop: The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        :param pulumi.Input[int] height: The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        :param pulumi.Input[str] resolution_adaptive: Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        :param pulumi.Input[int] vcrf: Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        :param pulumi.Input[int] width: The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def fps(self) -> pulumi.Input[int]:
        """
        Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: pulumi.Input[int]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[pulumi.Input[str]]:
        """
        Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        """
        return pulumi.get(self, "fill_type")

    @fill_type.setter
    def fill_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_type", value)

    @property
    @pulumi.getter
    def gop(self) -> Optional[pulumi.Input[int]]:
        """
        The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        """
        return pulumi.get(self, "gop")

    @gop.setter
    def gop(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gop", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[pulumi.Input[str]]:
        """
        Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        """
        return pulumi.get(self, "resolution_adaptive")

    @resolution_adaptive.setter
    def resolution_adaptive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution_adaptive", value)

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[pulumi.Input[int]]:
        """
        Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        """
        return pulumi.get(self, "vcrf")

    @vcrf.setter
    def vcrf(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vcrf", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WatermarkTemplateImageTemplateArgs:
    def __init__(__self__, *,
                 image_content: pulumi.Input[str],
                 height: Optional[pulumi.Input[str]] = None,
                 repeat_type: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_content: Watermark image[Base64](https://tools.ietf.org/html/rfc4648) encoded string. Support jpeg, png image format.
        :param pulumi.Input[str] height: The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels. The value range is 0 or [8, 4096].Default value: 0px. Indicates that Height is scaled according to the aspect ratio of the original watermark image.
        :param pulumi.Input[str] repeat_type: Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges:once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        :param pulumi.Input[str] width: The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixel, such as 100px means that the Width is 100 pixels. The value range is [8, 4096].Default value: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> pulumi.Input[str]:
        """
        Watermark image[Base64](https://tools.ietf.org/html/rfc4648) encoded string. Support jpeg, png image format.
        """
        return pulumi.get(self, "image_content")

    @image_content.setter
    def image_content(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_content", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels. The value range is 0 or [8, 4096].Default value: 0px. Indicates that Height is scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges:once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        """
        return pulumi.get(self, "repeat_type")

    @repeat_type.setter
    def repeat_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_type", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixel, such as 100px means that the Width is 100 pixels. The value range is [8, 4096].Default value: 10%.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WatermarkTemplateSvgTemplateArgs:
    def __init__(__self__, *,
                 height: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] height: The height of the watermark, supports px, W%, H%, S%, L% six formats:When the string ends with px, it means that the watermark Height unit is pixels, such as 100px means that the Height is 100 pixels; when filling 0px and Width is not 0px, it means that the height of the watermark is proportionally scaled according to the original SVG image; when both Width and Height are filled When 0px, it means that the height of the watermark takes the height of the original SVG image.When the string ends with W%, it means that the watermark Height is a percentage of the video width, such as 10W% means that the Height is 10% of the video width.When the string ends with H%, it means that the watermark Height is the percentage size of the video height, such as 10H% means that the Height is 10% of the video height.When the string ends with S%, it means that the watermark Height is the percentage size of the short side of the video, such as 10S% means that the Height is 10% of the short side of the video.When the string ends with L%, it means that the watermark Height is the percentage size of the long side of the video, such as 10L% means that the Height is 10% of the long side of the video.When the string ends with %, the meaning is the same as H%.Default value: 0px.
        :param pulumi.Input[str] width: The width of the watermark, supports px, %, W%, H%, S%, L% six formats.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels; when filling 0px and the Height is not 0px, it means that the width of the watermark is proportionally scaled according to the original SVG image; when both Width and Height are filled When 0px, it means that the width of the watermark takes the width of the original SVG image.When the string ends with W%, it means that the watermark Width is a percentage of the video width, such as 10W% means that the Width is 10% of the video width.When the string ends with H%, it means that the watermark Width is a percentage of the video height, such as 10H% means that the Width is 10% of the video height.When the string ends with S%, it means that the watermark Width is the percentage size of the short side of the video, such as 10S% means that the Width is 10% of the short side of the video.When the string ends with L%, it means that the watermark Width is the percentage size of the long side of the video, such as 10L% means that the Width is 10% of the long side of the video.When the string ends with %, it has the same meaning as W%.Default value: 10W%.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        The height of the watermark, supports px, W%, H%, S%, L% six formats:When the string ends with px, it means that the watermark Height unit is pixels, such as 100px means that the Height is 100 pixels; when filling 0px and Width is not 0px, it means that the height of the watermark is proportionally scaled according to the original SVG image; when both Width and Height are filled When 0px, it means that the height of the watermark takes the height of the original SVG image.When the string ends with W%, it means that the watermark Height is a percentage of the video width, such as 10W% means that the Height is 10% of the video width.When the string ends with H%, it means that the watermark Height is the percentage size of the video height, such as 10H% means that the Height is 10% of the video height.When the string ends with S%, it means that the watermark Height is the percentage size of the short side of the video, such as 10S% means that the Height is 10% of the short side of the video.When the string ends with L%, it means that the watermark Height is the percentage size of the long side of the video, such as 10L% means that the Height is 10% of the long side of the video.When the string ends with %, the meaning is the same as H%.Default value: 0px.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        The width of the watermark, supports px, %, W%, H%, S%, L% six formats.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels; when filling 0px and the Height is not 0px, it means that the width of the watermark is proportionally scaled according to the original SVG image; when both Width and Height are filled When 0px, it means that the width of the watermark takes the width of the original SVG image.When the string ends with W%, it means that the watermark Width is a percentage of the video width, such as 10W% means that the Width is 10% of the video width.When the string ends with H%, it means that the watermark Width is a percentage of the video height, such as 10H% means that the Width is 10% of the video height.When the string ends with S%, it means that the watermark Width is the percentage size of the short side of the video, such as 10S% means that the Width is 10% of the short side of the video.When the string ends with L%, it means that the watermark Width is the percentage size of the long side of the video, such as 10L% means that the Width is 10% of the long side of the video.When the string ends with %, it has the same meaning as W%.Default value: 10W%.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WatermarkTemplateTextTemplateArgs:
    def __init__(__self__, *,
                 font_alpha: pulumi.Input[float],
                 font_color: pulumi.Input[str],
                 font_size: pulumi.Input[str],
                 font_type: pulumi.Input[str]):
        """
        :param pulumi.Input[float] font_alpha: Text transparency, value range: (0, 1].0: fully transparent.1: fully opaque.Default value: 1.
        :param pulumi.Input[str] font_color: Font color, format: 0xRRGGBB, default value: 0xFFFFFF (white).
        :param pulumi.Input[str] font_size: Font size, format: Npx, N is a number.
        :param pulumi.Input[str] font_type: Font type, currently supports two:simkai.ttf: can support Chinese and English.arial.ttf: English only.
        """
        pulumi.set(__self__, "font_alpha", font_alpha)
        pulumi.set(__self__, "font_color", font_color)
        pulumi.set(__self__, "font_size", font_size)
        pulumi.set(__self__, "font_type", font_type)

    @property
    @pulumi.getter(name="fontAlpha")
    def font_alpha(self) -> pulumi.Input[float]:
        """
        Text transparency, value range: (0, 1].0: fully transparent.1: fully opaque.Default value: 1.
        """
        return pulumi.get(self, "font_alpha")

    @font_alpha.setter
    def font_alpha(self, value: pulumi.Input[float]):
        pulumi.set(self, "font_alpha", value)

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> pulumi.Input[str]:
        """
        Font color, format: 0xRRGGBB, default value: 0xFFFFFF (white).
        """
        return pulumi.get(self, "font_color")

    @font_color.setter
    def font_color(self, value: pulumi.Input[str]):
        pulumi.set(self, "font_color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> pulumi.Input[str]:
        """
        Font size, format: Npx, N is a number.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="fontType")
    def font_type(self) -> pulumi.Input[str]:
        """
        Font type, currently supports two:simkai.ttf: can support Chinese and English.arial.ttf: English only.
        """
        return pulumi.get(self, "font_type")

    @font_type.setter
    def font_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "font_type", value)


@pulumi.input_type
class WorkflowAiAnalysisTaskArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 extended_parameter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] definition: Video Content Analysis Template ID.
        :param pulumi.Input[str] extended_parameter: Extension parameter whose value is a serialized json string.Note: This parameter is a customized demand parameter, which requires offline docking.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if extended_parameter is not None:
            pulumi.set(__self__, "extended_parameter", extended_parameter)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Video Content Analysis Template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="extendedParameter")
    def extended_parameter(self) -> Optional[pulumi.Input[str]]:
        """
        Extension parameter whose value is a serialized json string.Note: This parameter is a customized demand parameter, which requires offline docking.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "extended_parameter")

    @extended_parameter.setter
    def extended_parameter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "extended_parameter", value)


@pulumi.input_type
class WorkflowAiContentReviewTaskArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int]):
        """
        :param pulumi.Input[int] definition: Video Content Review Template ID.
        """
        pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Video Content Review Template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class WorkflowAiRecognitionTaskArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int]):
        """
        :param pulumi.Input[int] definition: Video Intelligent Recognition Template ID.
        """
        pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Video Intelligent Recognition Template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class WorkflowMediaProcessTaskArgs:
    def __init__(__self__, *,
                 adaptive_dynamic_streaming_task_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetArgs']]]] = None,
                 animated_graphic_task_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetArgs']]]] = None,
                 image_sprite_task_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetArgs']]]] = None,
                 sample_snapshot_task_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetArgs']]]] = None,
                 snapshot_by_time_offset_task_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetArgs']]]] = None,
                 transcode_task_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetArgs']]] adaptive_dynamic_streaming_task_sets: Transfer Adaptive Code Stream Task List.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetArgs']]] animated_graphic_task_sets: Video Rotation Map Task List.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetArgs']]] image_sprite_task_sets: Sprite image capture task list for video.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetArgs']]] sample_snapshot_task_sets: Screenshot task list for video sampling.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetArgs']]] snapshot_by_time_offset_task_sets: Screenshot the task list of the video according to the time point.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetArgs']]] transcode_task_sets: Video Transcoding Task List.
        """
        if adaptive_dynamic_streaming_task_sets is not None:
            pulumi.set(__self__, "adaptive_dynamic_streaming_task_sets", adaptive_dynamic_streaming_task_sets)
        if animated_graphic_task_sets is not None:
            pulumi.set(__self__, "animated_graphic_task_sets", animated_graphic_task_sets)
        if image_sprite_task_sets is not None:
            pulumi.set(__self__, "image_sprite_task_sets", image_sprite_task_sets)
        if sample_snapshot_task_sets is not None:
            pulumi.set(__self__, "sample_snapshot_task_sets", sample_snapshot_task_sets)
        if snapshot_by_time_offset_task_sets is not None:
            pulumi.set(__self__, "snapshot_by_time_offset_task_sets", snapshot_by_time_offset_task_sets)
        if transcode_task_sets is not None:
            pulumi.set(__self__, "transcode_task_sets", transcode_task_sets)

    @property
    @pulumi.getter(name="adaptiveDynamicStreamingTaskSets")
    def adaptive_dynamic_streaming_task_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetArgs']]]]:
        """
        Transfer Adaptive Code Stream Task List.
        """
        return pulumi.get(self, "adaptive_dynamic_streaming_task_sets")

    @adaptive_dynamic_streaming_task_sets.setter
    def adaptive_dynamic_streaming_task_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetArgs']]]]):
        pulumi.set(self, "adaptive_dynamic_streaming_task_sets", value)

    @property
    @pulumi.getter(name="animatedGraphicTaskSets")
    def animated_graphic_task_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetArgs']]]]:
        """
        Video Rotation Map Task List.
        """
        return pulumi.get(self, "animated_graphic_task_sets")

    @animated_graphic_task_sets.setter
    def animated_graphic_task_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetArgs']]]]):
        pulumi.set(self, "animated_graphic_task_sets", value)

    @property
    @pulumi.getter(name="imageSpriteTaskSets")
    def image_sprite_task_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetArgs']]]]:
        """
        Sprite image capture task list for video.
        """
        return pulumi.get(self, "image_sprite_task_sets")

    @image_sprite_task_sets.setter
    def image_sprite_task_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetArgs']]]]):
        pulumi.set(self, "image_sprite_task_sets", value)

    @property
    @pulumi.getter(name="sampleSnapshotTaskSets")
    def sample_snapshot_task_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetArgs']]]]:
        """
        Screenshot task list for video sampling.
        """
        return pulumi.get(self, "sample_snapshot_task_sets")

    @sample_snapshot_task_sets.setter
    def sample_snapshot_task_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetArgs']]]]):
        pulumi.set(self, "sample_snapshot_task_sets", value)

    @property
    @pulumi.getter(name="snapshotByTimeOffsetTaskSets")
    def snapshot_by_time_offset_task_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetArgs']]]]:
        """
        Screenshot the task list of the video according to the time point.
        """
        return pulumi.get(self, "snapshot_by_time_offset_task_sets")

    @snapshot_by_time_offset_task_sets.setter
    def snapshot_by_time_offset_task_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetArgs']]]]):
        pulumi.set(self, "snapshot_by_time_offset_task_sets", value)

    @property
    @pulumi.getter(name="transcodeTaskSets")
    def transcode_task_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetArgs']]]]:
        """
        Video Transcoding Task List.
        """
        return pulumi.get(self, "transcode_task_sets")

    @transcode_task_sets.setter
    def transcode_task_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetArgs']]]]):
        pulumi.set(self, "transcode_task_sets", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 output_object_path: Optional[pulumi.Input[str]] = None,
                 output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageArgs']] = None,
                 segment_object_name: Optional[pulumi.Input[str]] = None,
                 sub_stream_object_name: Optional[pulumi.Input[str]] = None,
                 watermark_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetArgs']]]] = None):
        """
        :param pulumi.Input[int] definition: Transfer Adaptive Code Stream Template ID.
        :param pulumi.Input[str] output_object_path: After converting to an adaptive stream, the output path of the manifest file can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_adaptiveDynamicStreaming_{definition}.{format}`.
        :param pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageArgs'] output_storage: The target storage of the file after converting to the adaptive code stream, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] segment_object_name: After converting to an adaptive stream (only HLS), the output path of the fragmented file can only be a relative path. If not filled, the default is a relative path: `{inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}_{segmentNumber}.{format}`.
        :param pulumi.Input[str] sub_stream_object_name: After converting to an adaptive stream, the output path of the sub-stream file can only be a relative path. If not filled, the default is a relative path: {inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}.{format}`.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetArgs']]] watermark_sets: Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        pulumi.set(__self__, "definition", definition)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)
        if segment_object_name is not None:
            pulumi.set(__self__, "segment_object_name", segment_object_name)
        if sub_stream_object_name is not None:
            pulumi.set(__self__, "sub_stream_object_name", sub_stream_object_name)
        if watermark_sets is not None:
            pulumi.set(__self__, "watermark_sets", watermark_sets)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Transfer Adaptive Code Stream Template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[pulumi.Input[str]]:
        """
        After converting to an adaptive stream, the output path of the manifest file can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_adaptiveDynamicStreaming_{definition}.{format}`.
        """
        return pulumi.get(self, "output_object_path")

    @output_object_path.setter
    def output_object_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_object_path", value)

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageArgs']]:
        """
        The target storage of the file after converting to the adaptive code stream, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @output_storage.setter
    def output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageArgs']]):
        pulumi.set(self, "output_storage", value)

    @property
    @pulumi.getter(name="segmentObjectName")
    def segment_object_name(self) -> Optional[pulumi.Input[str]]:
        """
        After converting to an adaptive stream (only HLS), the output path of the fragmented file can only be a relative path. If not filled, the default is a relative path: `{inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}_{segmentNumber}.{format}`.
        """
        return pulumi.get(self, "segment_object_name")

    @segment_object_name.setter
    def segment_object_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_object_name", value)

    @property
    @pulumi.getter(name="subStreamObjectName")
    def sub_stream_object_name(self) -> Optional[pulumi.Input[str]]:
        """
        After converting to an adaptive stream, the output path of the sub-stream file can only be a relative path. If not filled, the default is a relative path: {inputName}_adaptiveDynamicStreaming_{definition}_{subStreamNumber}.{format}`.
        """
        return pulumi.get(self, "sub_stream_object_name")

    @sub_stream_object_name.setter
    def sub_stream_object_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sub_stream_object_name", value)

    @property
    @pulumi.getter(name="watermarkSets")
    def watermark_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetArgs']]]]:
        """
        Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        return pulumi.get(self, "watermark_sets")

    @watermark_sets.setter
    def watermark_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetArgs']]]]):
        pulumi.set(self, "watermark_sets", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorageArgs']] = None):
        """
        :param pulumi.Input[str] type: The type of media processing output object storage location, now only supports COS.
        :param pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorageArgs'] cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorageArgs']]:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")

    @cos_output_storage.setter
    def cos_output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorageArgs']]):
        pulumi.set(self, "cos_output_storage", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorageArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param pulumi.Input[str] region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 raw_parameter: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterArgs']] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] definition: Watermark Template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        :param pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterArgs'] raw_parameter: Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        :param pulumi.Input[float] start_time_offset: The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        :param pulumi.Input[str] svg_content: SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        :param pulumi.Input[str] text_content: Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if raw_parameter is not None:
            pulumi.set(__self__, "raw_parameter", raw_parameter)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Watermark Template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="rawParameter")
    def raw_parameter(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterArgs']]:
        """
        Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        """
        return pulumi.get(self, "raw_parameter")

    @raw_parameter.setter
    def raw_parameter(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterArgs']]):
        pulumi.set(self, "raw_parameter", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 coordinate_origin: Optional[pulumi.Input[str]] = None,
                 image_template: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateArgs']] = None,
                 x_pos: Optional[pulumi.Input[str]] = None,
                 y_pos: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Watermark type, optional value:image: image watermark.
        :param pulumi.Input[str] coordinate_origin: Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        :param pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateArgs'] image_template: Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        :param pulumi.Input[str] x_pos: The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        :param pulumi.Input[str] y_pos: The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        pulumi.set(__self__, "type", type)
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if image_template is not None:
            pulumi.set(__self__, "image_template", image_template)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Watermark type, optional value:image: image watermark.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[pulumi.Input[str]]:
        """
        Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @coordinate_origin.setter
    def coordinate_origin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coordinate_origin", value)

    @property
    @pulumi.getter(name="imageTemplate")
    def image_template(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateArgs']]:
        """
        Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        """
        return pulumi.get(self, "image_template")

    @image_template.setter
    def image_template(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateArgs']]):
        pulumi.set(self, "image_template", value)

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "x_pos")

    @x_pos.setter
    def x_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_pos", value)

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "y_pos")

    @y_pos.setter
    def y_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "y_pos", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateArgs:
    def __init__(__self__, *,
                 image_content: pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs'],
                 height: Optional[pulumi.Input[str]] = None,
                 repeat_type: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs'] image_content: The input content of the watermark image. Support jpeg, png image format.
        :param pulumi.Input[str] height: The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        :param pulumi.Input[str] repeat_type: Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        :param pulumi.Input[str] width: The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs']:
        """
        The input content of the watermark image. Support jpeg, png image format.
        """
        return pulumi.get(self, "image_content")

    @image_content.setter
    def image_content(self, value: pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs']):
        pulumi.set(self, "image_content", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        """
        return pulumi.get(self, "repeat_type")

    @repeat_type.setter
    def repeat_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_type", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']] = None,
                 url_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']] = None):
        """
        :param pulumi.Input[str] type: Enter the type of source object, which supports COS and URL.
        :param pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs'] cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs'] url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']]:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @cos_input_info.setter
    def cos_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']]):
        pulumi.set(self, "cos_input_info", value)

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']]:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")

    @url_input_info.setter
    def url_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']]):
        pulumi.set(self, "url_input_info", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 object: pulumi.Input[str],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: The name of the COS Bucket where the media processing object file is located.
        :param pulumi.Input[str] object: Input path for media processing object files.
        :param pulumi.Input[str] region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Video URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAnimatedGraphicTaskSetArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 end_time_offset: pulumi.Input[float],
                 start_time_offset: pulumi.Input[float],
                 output_object_path: Optional[pulumi.Input[str]] = None,
                 output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageArgs']] = None):
        """
        :param pulumi.Input[int] definition: Video turntable template id.
        :param pulumi.Input[float] end_time_offset: The end time of the animation in the video, in seconds.
        :param pulumi.Input[float] start_time_offset: The start time of the animation in the video, in seconds.
        :param pulumi.Input[str] output_object_path: The output path of the file after rotating the image, which can be a relative path or an absolute path. If not filled, the default is a relative path: {inputName}_animatedGraphic_{definition}.{format}.
        :param pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageArgs'] output_storage: The target storage of the transcoded file, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "start_time_offset", start_time_offset)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Video turntable template id.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> pulumi.Input[float]:
        """
        The end time of the animation in the video, in seconds.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: pulumi.Input[float]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> pulumi.Input[float]:
        """
        The start time of the animation in the video, in seconds.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: pulumi.Input[float]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[pulumi.Input[str]]:
        """
        The output path of the file after rotating the image, which can be a relative path or an absolute path. If not filled, the default is a relative path: {inputName}_animatedGraphic_{definition}.{format}.
        """
        return pulumi.get(self, "output_object_path")

    @output_object_path.setter
    def output_object_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_object_path", value)

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageArgs']]:
        """
        The target storage of the transcoded file, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @output_storage.setter
    def output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageArgs']]):
        pulumi.set(self, "output_storage", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorageArgs']] = None):
        """
        :param pulumi.Input[str] type: The type of media processing output object storage location, now only supports COS.
        :param pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorageArgs'] cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorageArgs']]:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")

    @cos_output_storage.setter
    def cos_output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorageArgs']]):
        pulumi.set(self, "cos_output_storage", value)


@pulumi.input_type
class WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorageArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param pulumi.Input[str] region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskImageSpriteTaskSetArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 object_number_format: Optional[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormatArgs']] = None,
                 output_object_path: Optional[pulumi.Input[str]] = None,
                 output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageArgs']] = None,
                 web_vtt_object_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] definition: Sprite Illustration Template ID.
        :param pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormatArgs'] object_number_format: Rules for the `{number}` variable in the output path after intercepting the Sprite image.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] output_object_path: After capturing the sprite image, the output path of the sprite image file can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_imageSprite_{definition}_{number}.{format}`.
        :param pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageArgs'] output_storage: The target storage of the file after the sprite image is intercepted, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] web_vtt_object_name: After capturing the sprite image, the output path of the Web VTT file can only be a relative path. If not filled, the default is a relative path: `{inputName}_imageSprite_{definition}.{format}`.
        """
        pulumi.set(__self__, "definition", definition)
        if object_number_format is not None:
            pulumi.set(__self__, "object_number_format", object_number_format)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)
        if web_vtt_object_name is not None:
            pulumi.set(__self__, "web_vtt_object_name", web_vtt_object_name)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Sprite Illustration Template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="objectNumberFormat")
    def object_number_format(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormatArgs']]:
        """
        Rules for the `{number}` variable in the output path after intercepting the Sprite image.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "object_number_format")

    @object_number_format.setter
    def object_number_format(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormatArgs']]):
        pulumi.set(self, "object_number_format", value)

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[pulumi.Input[str]]:
        """
        After capturing the sprite image, the output path of the sprite image file can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_imageSprite_{definition}_{number}.{format}`.
        """
        return pulumi.get(self, "output_object_path")

    @output_object_path.setter
    def output_object_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_object_path", value)

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageArgs']]:
        """
        The target storage of the file after the sprite image is intercepted, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @output_storage.setter
    def output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageArgs']]):
        pulumi.set(self, "output_storage", value)

    @property
    @pulumi.getter(name="webVttObjectName")
    def web_vtt_object_name(self) -> Optional[pulumi.Input[str]]:
        """
        After capturing the sprite image, the output path of the Web VTT file can only be a relative path. If not filled, the default is a relative path: `{inputName}_imageSprite_{definition}.{format}`.
        """
        return pulumi.get(self, "web_vtt_object_name")

    @web_vtt_object_name.setter
    def web_vtt_object_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_vtt_object_name", value)


@pulumi.input_type
class WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormatArgs:
    def __init__(__self__, *,
                 increment: Optional[pulumi.Input[int]] = None,
                 initial_value: Optional[pulumi.Input[int]] = None,
                 min_length: Optional[pulumi.Input[int]] = None,
                 place_holder: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] increment: The growth step of the `{number}` variable, the default is 1.
        :param pulumi.Input[int] initial_value: The starting value of `{number}` variable, the default is 0.
        :param pulumi.Input[int] min_length: The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        :param pulumi.Input[str] place_holder: When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if initial_value is not None:
            pulumi.set(__self__, "initial_value", initial_value)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if place_holder is not None:
            pulumi.set(__self__, "place_holder", place_holder)

    @property
    @pulumi.getter
    def increment(self) -> Optional[pulumi.Input[int]]:
        """
        The growth step of the `{number}` variable, the default is 1.
        """
        return pulumi.get(self, "increment")

    @increment.setter
    def increment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "increment", value)

    @property
    @pulumi.getter(name="initialValue")
    def initial_value(self) -> Optional[pulumi.Input[int]]:
        """
        The starting value of `{number}` variable, the default is 0.
        """
        return pulumi.get(self, "initial_value")

    @initial_value.setter
    def initial_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_value", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter(name="placeHolder")
    def place_holder(self) -> Optional[pulumi.Input[str]]:
        """
        When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        return pulumi.get(self, "place_holder")

    @place_holder.setter
    def place_holder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "place_holder", value)


@pulumi.input_type
class WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorageArgs']] = None):
        """
        :param pulumi.Input[str] type: The type of media processing output object storage location, now only supports COS.
        :param pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorageArgs'] cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorageArgs']]:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")

    @cos_output_storage.setter
    def cos_output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorageArgs']]):
        pulumi.set(self, "cos_output_storage", value)


@pulumi.input_type
class WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorageArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param pulumi.Input[str] region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 object_number_format: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormatArgs']] = None,
                 output_object_path: Optional[pulumi.Input[str]] = None,
                 output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageArgs']] = None,
                 watermark_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetArgs']]]] = None):
        """
        :param pulumi.Input[int] definition: Sample screenshot template ID.
        :param pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormatArgs'] object_number_format: Rules for the `{number}` variable in the output path after sampling the screenshot.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] output_object_path: The output path of the image file after sampling the screenshot, which can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_sampleSnapshot_{definition}_{number}.{format}`.
        :param pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageArgs'] output_storage: The target storage of the file after the screenshot at the time point, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetArgs']]] watermark_sets: Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        pulumi.set(__self__, "definition", definition)
        if object_number_format is not None:
            pulumi.set(__self__, "object_number_format", object_number_format)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)
        if watermark_sets is not None:
            pulumi.set(__self__, "watermark_sets", watermark_sets)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Sample screenshot template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="objectNumberFormat")
    def object_number_format(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormatArgs']]:
        """
        Rules for the `{number}` variable in the output path after sampling the screenshot.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "object_number_format")

    @object_number_format.setter
    def object_number_format(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormatArgs']]):
        pulumi.set(self, "object_number_format", value)

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[pulumi.Input[str]]:
        """
        The output path of the image file after sampling the screenshot, which can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_sampleSnapshot_{definition}_{number}.{format}`.
        """
        return pulumi.get(self, "output_object_path")

    @output_object_path.setter
    def output_object_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_object_path", value)

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageArgs']]:
        """
        The target storage of the file after the screenshot at the time point, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @output_storage.setter
    def output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageArgs']]):
        pulumi.set(self, "output_storage", value)

    @property
    @pulumi.getter(name="watermarkSets")
    def watermark_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetArgs']]]]:
        """
        Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        return pulumi.get(self, "watermark_sets")

    @watermark_sets.setter
    def watermark_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetArgs']]]]):
        pulumi.set(self, "watermark_sets", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormatArgs:
    def __init__(__self__, *,
                 increment: Optional[pulumi.Input[int]] = None,
                 initial_value: Optional[pulumi.Input[int]] = None,
                 min_length: Optional[pulumi.Input[int]] = None,
                 place_holder: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] increment: The growth step of the `{number}` variable, the default is 1.
        :param pulumi.Input[int] initial_value: The starting value of `{number}` variable, the default is 0.
        :param pulumi.Input[int] min_length: The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        :param pulumi.Input[str] place_holder: When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if initial_value is not None:
            pulumi.set(__self__, "initial_value", initial_value)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if place_holder is not None:
            pulumi.set(__self__, "place_holder", place_holder)

    @property
    @pulumi.getter
    def increment(self) -> Optional[pulumi.Input[int]]:
        """
        The growth step of the `{number}` variable, the default is 1.
        """
        return pulumi.get(self, "increment")

    @increment.setter
    def increment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "increment", value)

    @property
    @pulumi.getter(name="initialValue")
    def initial_value(self) -> Optional[pulumi.Input[int]]:
        """
        The starting value of `{number}` variable, the default is 0.
        """
        return pulumi.get(self, "initial_value")

    @initial_value.setter
    def initial_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_value", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter(name="placeHolder")
    def place_holder(self) -> Optional[pulumi.Input[str]]:
        """
        When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        return pulumi.get(self, "place_holder")

    @place_holder.setter
    def place_holder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "place_holder", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorageArgs']] = None):
        """
        :param pulumi.Input[str] type: The type of media processing output object storage location, now only supports COS.
        :param pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorageArgs'] cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorageArgs']]:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")

    @cos_output_storage.setter
    def cos_output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorageArgs']]):
        pulumi.set(self, "cos_output_storage", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorageArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param pulumi.Input[str] region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 raw_parameter: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterArgs']] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] definition: Watermark Template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        :param pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterArgs'] raw_parameter: Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        :param pulumi.Input[float] start_time_offset: The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        :param pulumi.Input[str] svg_content: SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        :param pulumi.Input[str] text_content: Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if raw_parameter is not None:
            pulumi.set(__self__, "raw_parameter", raw_parameter)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Watermark Template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="rawParameter")
    def raw_parameter(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterArgs']]:
        """
        Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        """
        return pulumi.get(self, "raw_parameter")

    @raw_parameter.setter
    def raw_parameter(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterArgs']]):
        pulumi.set(self, "raw_parameter", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 coordinate_origin: Optional[pulumi.Input[str]] = None,
                 image_template: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateArgs']] = None,
                 x_pos: Optional[pulumi.Input[str]] = None,
                 y_pos: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Watermark type, optional value:image: image watermark.
        :param pulumi.Input[str] coordinate_origin: Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        :param pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateArgs'] image_template: Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        :param pulumi.Input[str] x_pos: The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        :param pulumi.Input[str] y_pos: The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        pulumi.set(__self__, "type", type)
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if image_template is not None:
            pulumi.set(__self__, "image_template", image_template)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Watermark type, optional value:image: image watermark.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[pulumi.Input[str]]:
        """
        Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @coordinate_origin.setter
    def coordinate_origin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coordinate_origin", value)

    @property
    @pulumi.getter(name="imageTemplate")
    def image_template(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateArgs']]:
        """
        Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        """
        return pulumi.get(self, "image_template")

    @image_template.setter
    def image_template(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateArgs']]):
        pulumi.set(self, "image_template", value)

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "x_pos")

    @x_pos.setter
    def x_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_pos", value)

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "y_pos")

    @y_pos.setter
    def y_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "y_pos", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateArgs:
    def __init__(__self__, *,
                 image_content: pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs'],
                 height: Optional[pulumi.Input[str]] = None,
                 repeat_type: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs'] image_content: The input content of the watermark image. Support jpeg, png image format.
        :param pulumi.Input[str] height: The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        :param pulumi.Input[str] repeat_type: Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        :param pulumi.Input[str] width: The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs']:
        """
        The input content of the watermark image. Support jpeg, png image format.
        """
        return pulumi.get(self, "image_content")

    @image_content.setter
    def image_content(self, value: pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs']):
        pulumi.set(self, "image_content", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        """
        return pulumi.get(self, "repeat_type")

    @repeat_type.setter
    def repeat_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_type", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']] = None,
                 url_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']] = None):
        """
        :param pulumi.Input[str] type: Enter the type of source object, which supports COS and URL.
        :param pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs'] cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs'] url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']]:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @cos_input_info.setter
    def cos_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']]):
        pulumi.set(self, "cos_input_info", value)

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']]:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")

    @url_input_info.setter
    def url_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']]):
        pulumi.set(self, "url_input_info", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 object: pulumi.Input[str],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: The name of the COS Bucket where the media processing object file is located.
        :param pulumi.Input[str] object: Input path for media processing object files.
        :param pulumi.Input[str] region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Video URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 ext_time_offset_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 object_number_format: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormatArgs']] = None,
                 output_object_path: Optional[pulumi.Input[str]] = None,
                 output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageArgs']] = None,
                 time_offset_sets: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]] = None,
                 watermark_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetArgs']]]] = None):
        """
        :param pulumi.Input[int] definition: Specified time point screenshot template ID.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ext_time_offset_sets: Screenshot time point list, the time point supports two formats: s and %:;When the string ends with s, it means that the time point is in seconds, such as 3.5s means that the time point is the 3.5th second.When the string ends with %, it means that the time point is the percentage of the video duration, such as 10% means that the time point is the first 10% of the time in the video.
        :param pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormatArgs'] object_number_format: Rules for the `{number}` variable in the output path after the screenshot at the time point.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] output_object_path: The output path of the picture file after the snapshot at the time point can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_snapshotByTimeOffset_{definition}_{number}.{format}`.
        :param pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageArgs'] output_storage: The target storage of the file after the screenshot at the time point, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input[float]]] time_offset_sets: Screenshot time point list, the unit is &lt;font color=red&gt;seconds&lt;/font&gt;. This parameter is no longer recommended, it is recommended that you use the ExtTimeOffsetSet parameter.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetArgs']]] watermark_sets: Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        pulumi.set(__self__, "definition", definition)
        if ext_time_offset_sets is not None:
            pulumi.set(__self__, "ext_time_offset_sets", ext_time_offset_sets)
        if object_number_format is not None:
            pulumi.set(__self__, "object_number_format", object_number_format)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)
        if time_offset_sets is not None:
            pulumi.set(__self__, "time_offset_sets", time_offset_sets)
        if watermark_sets is not None:
            pulumi.set(__self__, "watermark_sets", watermark_sets)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Specified time point screenshot template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="extTimeOffsetSets")
    def ext_time_offset_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Screenshot time point list, the time point supports two formats: s and %:;When the string ends with s, it means that the time point is in seconds, such as 3.5s means that the time point is the 3.5th second.When the string ends with %, it means that the time point is the percentage of the video duration, such as 10% means that the time point is the first 10% of the time in the video.
        """
        return pulumi.get(self, "ext_time_offset_sets")

    @ext_time_offset_sets.setter
    def ext_time_offset_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ext_time_offset_sets", value)

    @property
    @pulumi.getter(name="objectNumberFormat")
    def object_number_format(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormatArgs']]:
        """
        Rules for the `{number}` variable in the output path after the screenshot at the time point.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "object_number_format")

    @object_number_format.setter
    def object_number_format(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormatArgs']]):
        pulumi.set(self, "object_number_format", value)

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[pulumi.Input[str]]:
        """
        The output path of the picture file after the snapshot at the time point can be a relative path or an absolute path. If not filled, the default is a relative path: `{inputName}_snapshotByTimeOffset_{definition}_{number}.{format}`.
        """
        return pulumi.get(self, "output_object_path")

    @output_object_path.setter
    def output_object_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_object_path", value)

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageArgs']]:
        """
        The target storage of the file after the screenshot at the time point, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @output_storage.setter
    def output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageArgs']]):
        pulumi.set(self, "output_storage", value)

    @property
    @pulumi.getter(name="timeOffsetSets")
    def time_offset_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]:
        """
        Screenshot time point list, the unit is &lt;font color=red&gt;seconds&lt;/font&gt;. This parameter is no longer recommended, it is recommended that you use the ExtTimeOffsetSet parameter.
        """
        return pulumi.get(self, "time_offset_sets")

    @time_offset_sets.setter
    def time_offset_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]):
        pulumi.set(self, "time_offset_sets", value)

    @property
    @pulumi.getter(name="watermarkSets")
    def watermark_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetArgs']]]]:
        """
        Watermark list, support multiple pictures or text watermarks, up to 10.
        """
        return pulumi.get(self, "watermark_sets")

    @watermark_sets.setter
    def watermark_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetArgs']]]]):
        pulumi.set(self, "watermark_sets", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormatArgs:
    def __init__(__self__, *,
                 increment: Optional[pulumi.Input[int]] = None,
                 initial_value: Optional[pulumi.Input[int]] = None,
                 min_length: Optional[pulumi.Input[int]] = None,
                 place_holder: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] increment: The growth step of the `{number}` variable, the default is 1.
        :param pulumi.Input[int] initial_value: The starting value of `{number}` variable, the default is 0.
        :param pulumi.Input[int] min_length: The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        :param pulumi.Input[str] place_holder: When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if initial_value is not None:
            pulumi.set(__self__, "initial_value", initial_value)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if place_holder is not None:
            pulumi.set(__self__, "place_holder", place_holder)

    @property
    @pulumi.getter
    def increment(self) -> Optional[pulumi.Input[int]]:
        """
        The growth step of the `{number}` variable, the default is 1.
        """
        return pulumi.get(self, "increment")

    @increment.setter
    def increment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "increment", value)

    @property
    @pulumi.getter(name="initialValue")
    def initial_value(self) -> Optional[pulumi.Input[int]]:
        """
        The starting value of `{number}` variable, the default is 0.
        """
        return pulumi.get(self, "initial_value")

    @initial_value.setter
    def initial_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_value", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter(name="placeHolder")
    def place_holder(self) -> Optional[pulumi.Input[str]]:
        """
        When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        return pulumi.get(self, "place_holder")

    @place_holder.setter
    def place_holder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "place_holder", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorageArgs']] = None):
        """
        :param pulumi.Input[str] type: The type of media processing output object storage location, now only supports COS.
        :param pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorageArgs'] cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorageArgs']]:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")

    @cos_output_storage.setter
    def cos_output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorageArgs']]):
        pulumi.set(self, "cos_output_storage", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorageArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param pulumi.Input[str] region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 raw_parameter: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterArgs']] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] definition: Watermark Template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        :param pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterArgs'] raw_parameter: Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        :param pulumi.Input[float] start_time_offset: The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        :param pulumi.Input[str] svg_content: SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        :param pulumi.Input[str] text_content: Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if raw_parameter is not None:
            pulumi.set(__self__, "raw_parameter", raw_parameter)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Watermark Template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="rawParameter")
    def raw_parameter(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterArgs']]:
        """
        Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        """
        return pulumi.get(self, "raw_parameter")

    @raw_parameter.setter
    def raw_parameter(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterArgs']]):
        pulumi.set(self, "raw_parameter", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 coordinate_origin: Optional[pulumi.Input[str]] = None,
                 image_template: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateArgs']] = None,
                 x_pos: Optional[pulumi.Input[str]] = None,
                 y_pos: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Watermark type, optional value:image: image watermark.
        :param pulumi.Input[str] coordinate_origin: Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        :param pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateArgs'] image_template: Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        :param pulumi.Input[str] x_pos: The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        :param pulumi.Input[str] y_pos: The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        pulumi.set(__self__, "type", type)
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if image_template is not None:
            pulumi.set(__self__, "image_template", image_template)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Watermark type, optional value:image: image watermark.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[pulumi.Input[str]]:
        """
        Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @coordinate_origin.setter
    def coordinate_origin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coordinate_origin", value)

    @property
    @pulumi.getter(name="imageTemplate")
    def image_template(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateArgs']]:
        """
        Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        """
        return pulumi.get(self, "image_template")

    @image_template.setter
    def image_template(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateArgs']]):
        pulumi.set(self, "image_template", value)

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "x_pos")

    @x_pos.setter
    def x_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_pos", value)

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "y_pos")

    @y_pos.setter
    def y_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "y_pos", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateArgs:
    def __init__(__self__, *,
                 image_content: pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs'],
                 height: Optional[pulumi.Input[str]] = None,
                 repeat_type: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs'] image_content: The input content of the watermark image. Support jpeg, png image format.
        :param pulumi.Input[str] height: The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        :param pulumi.Input[str] repeat_type: Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        :param pulumi.Input[str] width: The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs']:
        """
        The input content of the watermark image. Support jpeg, png image format.
        """
        return pulumi.get(self, "image_content")

    @image_content.setter
    def image_content(self, value: pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs']):
        pulumi.set(self, "image_content", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        """
        return pulumi.get(self, "repeat_type")

    @repeat_type.setter
    def repeat_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_type", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']] = None,
                 url_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']] = None):
        """
        :param pulumi.Input[str] type: Enter the type of source object, which supports COS and URL.
        :param pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs'] cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs'] url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']]:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @cos_input_info.setter
    def cos_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']]):
        pulumi.set(self, "cos_input_info", value)

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']]:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")

    @url_input_info.setter
    def url_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']]):
        pulumi.set(self, "url_input_info", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 object: pulumi.Input[str],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: The name of the COS Bucket where the media processing object file is located.
        :param pulumi.Input[str] object: Input path for media processing object files.
        :param pulumi.Input[str] region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Video URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 head_tail_parameter: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterArgs']] = None,
                 mosaic_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetMosaicSetArgs']]]] = None,
                 object_number_format: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormatArgs']] = None,
                 output_object_path: Optional[pulumi.Input[str]] = None,
                 output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageArgs']] = None,
                 override_parameter: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterArgs']] = None,
                 raw_parameter: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterArgs']] = None,
                 segment_object_name: Optional[pulumi.Input[str]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 watermark_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetArgs']]]] = None):
        """
        :param pulumi.Input[int] definition: Video Transcoding Template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of video after transcoding, unit: second.Do not fill in or fill in 0, indicating that the transcoded video continues until the end of the original video.When the value is greater than 0 (assumed to be n), it means that the transcoded video lasts until the nth second of the original video and terminates.When the value is less than 0 (assumed to be -n), it means that the transcoded video lasts until n seconds before the end of the original video.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterArgs'] head_tail_parameter: Opening and ending parameters.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetMosaicSetArgs']]] mosaic_sets: Mosaic list, up to 10 sheets can be supported.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormatArgs'] object_number_format: Rules for the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] output_object_path: The output path of the main file after transcoding can be a relative path or an absolute path. If not filled, the default is a relative path: {inputName}_transcode_{definition}.{format}.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageArgs'] output_storage: The target storage of the transcoded file, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterArgs'] override_parameter: Video transcoding custom parameters, valid when Definition is not filled with 0.When some transcoding parameters in this structure are filled in, the parameters in the transcoding template will be overwritten with the filled parameters.This parameter is used in highly customized scenarios, it is recommended that you only use Definition to specify transcoding parameters.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterArgs'] raw_parameter: Video transcoding custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios. It is recommended that you use Definition to specify transcoding parameters first.Note: This field may return null, indicating that no valid value can be obtained.
        :param pulumi.Input[str] segment_object_name: The output path of the transcoded fragment file (the path of ts when transcoding HLS), can only be a relative path. If not filled, the default is: `{inputName}_transcode_{definition}_{number}.{format}.
        :param pulumi.Input[float] start_time_offset: The start time offset of the transcoded video, unit: second.Do not fill in or fill in 0, indicating that the transcoded video starts from the beginning of the original video.When the value is greater than 0 (assumed to be n), it means that the transcoded video starts from the nth second position of the original video.When the value is less than 0 (assumed to be -n), it means that the transcoded video starts from the position n seconds before the end of the original video.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetArgs']]] watermark_sets: Watermark list, support multiple pictures or text watermarks, up to 10.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if head_tail_parameter is not None:
            pulumi.set(__self__, "head_tail_parameter", head_tail_parameter)
        if mosaic_sets is not None:
            pulumi.set(__self__, "mosaic_sets", mosaic_sets)
        if object_number_format is not None:
            pulumi.set(__self__, "object_number_format", object_number_format)
        if output_object_path is not None:
            pulumi.set(__self__, "output_object_path", output_object_path)
        if output_storage is not None:
            pulumi.set(__self__, "output_storage", output_storage)
        if override_parameter is not None:
            pulumi.set(__self__, "override_parameter", override_parameter)
        if raw_parameter is not None:
            pulumi.set(__self__, "raw_parameter", raw_parameter)
        if segment_object_name is not None:
            pulumi.set(__self__, "segment_object_name", segment_object_name)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if watermark_sets is not None:
            pulumi.set(__self__, "watermark_sets", watermark_sets)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Video Transcoding Template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of video after transcoding, unit: second.Do not fill in or fill in 0, indicating that the transcoded video continues until the end of the original video.When the value is greater than 0 (assumed to be n), it means that the transcoded video lasts until the nth second of the original video and terminates.When the value is less than 0 (assumed to be -n), it means that the transcoded video lasts until n seconds before the end of the original video.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="headTailParameter")
    def head_tail_parameter(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterArgs']]:
        """
        Opening and ending parameters.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "head_tail_parameter")

    @head_tail_parameter.setter
    def head_tail_parameter(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterArgs']]):
        pulumi.set(self, "head_tail_parameter", value)

    @property
    @pulumi.getter(name="mosaicSets")
    def mosaic_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetMosaicSetArgs']]]]:
        """
        Mosaic list, up to 10 sheets can be supported.
        """
        return pulumi.get(self, "mosaic_sets")

    @mosaic_sets.setter
    def mosaic_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetMosaicSetArgs']]]]):
        pulumi.set(self, "mosaic_sets", value)

    @property
    @pulumi.getter(name="objectNumberFormat")
    def object_number_format(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormatArgs']]:
        """
        Rules for the `{number}` variable in the output path after transcoding.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "object_number_format")

    @object_number_format.setter
    def object_number_format(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormatArgs']]):
        pulumi.set(self, "object_number_format", value)

    @property
    @pulumi.getter(name="outputObjectPath")
    def output_object_path(self) -> Optional[pulumi.Input[str]]:
        """
        The output path of the main file after transcoding can be a relative path or an absolute path. If not filled, the default is a relative path: {inputName}_transcode_{definition}.{format}.
        """
        return pulumi.get(self, "output_object_path")

    @output_object_path.setter
    def output_object_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_object_path", value)

    @property
    @pulumi.getter(name="outputStorage")
    def output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageArgs']]:
        """
        The target storage of the transcoded file, if not filled, it will inherit the OutputStorage value of the upper layer.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "output_storage")

    @output_storage.setter
    def output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageArgs']]):
        pulumi.set(self, "output_storage", value)

    @property
    @pulumi.getter(name="overrideParameter")
    def override_parameter(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterArgs']]:
        """
        Video transcoding custom parameters, valid when Definition is not filled with 0.When some transcoding parameters in this structure are filled in, the parameters in the transcoding template will be overwritten with the filled parameters.This parameter is used in highly customized scenarios, it is recommended that you only use Definition to specify transcoding parameters.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "override_parameter")

    @override_parameter.setter
    def override_parameter(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterArgs']]):
        pulumi.set(self, "override_parameter", value)

    @property
    @pulumi.getter(name="rawParameter")
    def raw_parameter(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterArgs']]:
        """
        Video transcoding custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios. It is recommended that you use Definition to specify transcoding parameters first.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "raw_parameter")

    @raw_parameter.setter
    def raw_parameter(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterArgs']]):
        pulumi.set(self, "raw_parameter", value)

    @property
    @pulumi.getter(name="segmentObjectName")
    def segment_object_name(self) -> Optional[pulumi.Input[str]]:
        """
        The output path of the transcoded fragment file (the path of ts when transcoding HLS), can only be a relative path. If not filled, the default is: `{inputName}_transcode_{definition}_{number}.{format}.
        """
        return pulumi.get(self, "segment_object_name")

    @segment_object_name.setter
    def segment_object_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_object_name", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        The start time offset of the transcoded video, unit: second.Do not fill in or fill in 0, indicating that the transcoded video starts from the beginning of the original video.When the value is greater than 0 (assumed to be n), it means that the transcoded video starts from the nth second position of the original video.When the value is less than 0 (assumed to be -n), it means that the transcoded video starts from the position n seconds before the end of the original video.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="watermarkSets")
    def watermark_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetArgs']]]]:
        """
        Watermark list, support multiple pictures or text watermarks, up to 10.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "watermark_sets")

    @watermark_sets.setter
    def watermark_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetArgs']]]]):
        pulumi.set(self, "watermark_sets", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterArgs:
    def __init__(__self__, *,
                 head_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetArgs']]]] = None,
                 tail_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetArgs']]] head_sets: Title list.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetArgs']]] tail_sets: Ending List.
        """
        if head_sets is not None:
            pulumi.set(__self__, "head_sets", head_sets)
        if tail_sets is not None:
            pulumi.set(__self__, "tail_sets", tail_sets)

    @property
    @pulumi.getter(name="headSets")
    def head_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetArgs']]]]:
        """
        Title list.
        """
        return pulumi.get(self, "head_sets")

    @head_sets.setter
    def head_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetArgs']]]]):
        pulumi.set(self, "head_sets", value)

    @property
    @pulumi.getter(name="tailSets")
    def tail_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetArgs']]]]:
        """
        Ending List.
        """
        return pulumi.get(self, "tail_sets")

    @tail_sets.setter
    def tail_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetArgs']]]]):
        pulumi.set(self, "tail_sets", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfoArgs']] = None,
                 url_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfoArgs']] = None):
        """
        :param pulumi.Input[str] type: Enter the type of source object, which supports COS and URL.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfoArgs'] cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfoArgs'] url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfoArgs']]:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @cos_input_info.setter
    def cos_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfoArgs']]):
        pulumi.set(self, "cos_input_info", value)

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfoArgs']]:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")

    @url_input_info.setter
    def url_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfoArgs']]):
        pulumi.set(self, "url_input_info", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfoArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 object: pulumi.Input[str],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: The name of the COS Bucket where the media processing object file is located.
        :param pulumi.Input[str] object: Input path for media processing object files.
        :param pulumi.Input[str] region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfoArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Video URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfoArgs']] = None,
                 url_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfoArgs']] = None):
        """
        :param pulumi.Input[str] type: Enter the type of source object, which supports COS and URL.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfoArgs'] cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfoArgs'] url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfoArgs']]:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @cos_input_info.setter
    def cos_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfoArgs']]):
        pulumi.set(self, "cos_input_info", value)

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfoArgs']]:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")

    @url_input_info.setter
    def url_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfoArgs']]):
        pulumi.set(self, "url_input_info", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfoArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 object: pulumi.Input[str],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: The name of the COS Bucket where the media processing object file is located.
        :param pulumi.Input[str] object: Input path for media processing object files.
        :param pulumi.Input[str] region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfoArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Video URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetMosaicSetArgs:
    def __init__(__self__, *,
                 coordinate_origin: Optional[pulumi.Input[str]] = None,
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 height: Optional[pulumi.Input[str]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 width: Optional[pulumi.Input[str]] = None,
                 x_pos: Optional[pulumi.Input[str]] = None,
                 y_pos: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] coordinate_origin: Origin position, currently only supports:TopLeft: Indicates that the coordinate origin is located in the upper left corner of the video image, and the origin of the mosaic is the upper left corner of the picture or textDefault: TopLeft.
        :param pulumi.Input[float] end_time_offset: The end time offset of the mosaic, unit: second.Fill in or fill in 0, indicating that the mosaic continues until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the mosaic lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the mosaic lasts until it disappears n seconds before the end of the screen.
        :param pulumi.Input[str] height: The height of the mosaic. Support %, px two formats.When the string ends with %, it means that the mosaic Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the mosaic Height unit is pixel, such as 100px means that the Height is 100 pixels.Default: 10%.
        :param pulumi.Input[float] start_time_offset: The start time offset of the mosaic, unit: second. Do not fill or fill in 0, which means that the mosaic will start to appear when the screen appears.Fill in or fill in 0, which means that the mosaic will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the mosaic appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the mosaic starts to appear n seconds before the end of the screen.
        :param pulumi.Input[str] width: The width of the mosaic. Support %, px two formats:When the string ends with %, it means that the mosaic Width is the percentage size of the video width, such as 10% means that the Width is 10% of the video width.The string ends with px, indicating that the mosaic Width unit is pixels, such as 100px indicates that the Width is 100 pixels.Default: 10%.
        :param pulumi.Input[str] x_pos: The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        :param pulumi.Input[str] y_pos: The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[pulumi.Input[str]]:
        """
        Origin position, currently only supports:TopLeft: Indicates that the coordinate origin is located in the upper left corner of the video image, and the origin of the mosaic is the upper left corner of the picture or textDefault: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @coordinate_origin.setter
    def coordinate_origin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coordinate_origin", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        The end time offset of the mosaic, unit: second.Fill in or fill in 0, indicating that the mosaic continues until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the mosaic lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the mosaic lasts until it disappears n seconds before the end of the screen.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        The height of the mosaic. Support %, px two formats.When the string ends with %, it means that the mosaic Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the mosaic Height unit is pixel, such as 100px means that the Height is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        The start time offset of the mosaic, unit: second. Do not fill or fill in 0, which means that the mosaic will start to appear when the screen appears.Fill in or fill in 0, which means that the mosaic will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the mosaic appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the mosaic starts to appear n seconds before the end of the screen.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        The width of the mosaic. Support %, px two formats:When the string ends with %, it means that the mosaic Width is the percentage size of the video width, such as 10% means that the Width is 10% of the video width.The string ends with px, indicating that the mosaic Width unit is pixels, such as 100px indicates that the Width is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "x_pos")

    @x_pos.setter
    def x_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_pos", value)

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "y_pos")

    @y_pos.setter
    def y_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "y_pos", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormatArgs:
    def __init__(__self__, *,
                 increment: Optional[pulumi.Input[int]] = None,
                 initial_value: Optional[pulumi.Input[int]] = None,
                 min_length: Optional[pulumi.Input[int]] = None,
                 place_holder: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] increment: The growth step of the `{number}` variable, the default is 1.
        :param pulumi.Input[int] initial_value: The starting value of `{number}` variable, the default is 0.
        :param pulumi.Input[int] min_length: The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        :param pulumi.Input[str] place_holder: When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if initial_value is not None:
            pulumi.set(__self__, "initial_value", initial_value)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if place_holder is not None:
            pulumi.set(__self__, "place_holder", place_holder)

    @property
    @pulumi.getter
    def increment(self) -> Optional[pulumi.Input[int]]:
        """
        The growth step of the `{number}` variable, the default is 1.
        """
        return pulumi.get(self, "increment")

    @increment.setter
    def increment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "increment", value)

    @property
    @pulumi.getter(name="initialValue")
    def initial_value(self) -> Optional[pulumi.Input[int]]:
        """
        The starting value of `{number}` variable, the default is 0.
        """
        return pulumi.get(self, "initial_value")

    @initial_value.setter
    def initial_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_value", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum length of the `{number}` variable, if insufficient, placeholders will be filled. Default is 1.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter(name="placeHolder")
    def place_holder(self) -> Optional[pulumi.Input[str]]:
        """
        When the length of the `{number}` variable is insufficient, a placeholder is added. Default is 0.
        """
        return pulumi.get(self, "place_holder")

    @place_holder.setter
    def place_holder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "place_holder", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_output_storage: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorageArgs']] = None):
        """
        :param pulumi.Input[str] type: The type of media processing output object storage location, now only supports COS.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorageArgs'] cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorageArgs']]:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")

    @cos_output_storage.setter
    def cos_output_storage(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorageArgs']]):
        pulumi.set(self, "cos_output_storage", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorageArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param pulumi.Input[str] region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterArgs:
    def __init__(__self__, *,
                 audio_template: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplateArgs']] = None,
                 container: Optional[pulumi.Input[str]] = None,
                 remove_audio: Optional[pulumi.Input[int]] = None,
                 remove_video: Optional[pulumi.Input[int]] = None,
                 subtitle_template: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplateArgs']] = None,
                 tehd_config: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfigArgs']] = None,
                 video_template: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplateArgs']] = None):
        """
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplateArgs'] audio_template: Audio stream configuration parameters.
        :param pulumi.Input[str] container: Encapsulation format, optional values: mp4, flv, hls, mp3, flac, ogg, m4a. Among them, mp3, flac, ogg, m4a are pure audio files.
        :param pulumi.Input[int] remove_audio: Whether to remove audio data, value:0: reserved.1: remove.
        :param pulumi.Input[int] remove_video: Whether to remove video data, value:0: reserved.1: remove.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplateArgs'] subtitle_template: Subtitle Stream Configuration Parameters.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfigArgs'] tehd_config: Ultra-fast HD transcoding parameters.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplateArgs'] video_template: Video streaming configuration parameters.
        """
        if audio_template is not None:
            pulumi.set(__self__, "audio_template", audio_template)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if remove_audio is not None:
            pulumi.set(__self__, "remove_audio", remove_audio)
        if remove_video is not None:
            pulumi.set(__self__, "remove_video", remove_video)
        if subtitle_template is not None:
            pulumi.set(__self__, "subtitle_template", subtitle_template)
        if tehd_config is not None:
            pulumi.set(__self__, "tehd_config", tehd_config)
        if video_template is not None:
            pulumi.set(__self__, "video_template", video_template)

    @property
    @pulumi.getter(name="audioTemplate")
    def audio_template(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplateArgs']]:
        """
        Audio stream configuration parameters.
        """
        return pulumi.get(self, "audio_template")

    @audio_template.setter
    def audio_template(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplateArgs']]):
        pulumi.set(self, "audio_template", value)

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[str]]:
        """
        Encapsulation format, optional values: mp4, flv, hls, mp3, flac, ogg, m4a. Among them, mp3, flac, ogg, m4a are pure audio files.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to remove audio data, value:0: reserved.1: remove.
        """
        return pulumi.get(self, "remove_audio")

    @remove_audio.setter
    def remove_audio(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remove_audio", value)

    @property
    @pulumi.getter(name="removeVideo")
    def remove_video(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to remove video data, value:0: reserved.1: remove.
        """
        return pulumi.get(self, "remove_video")

    @remove_video.setter
    def remove_video(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remove_video", value)

    @property
    @pulumi.getter(name="subtitleTemplate")
    def subtitle_template(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplateArgs']]:
        """
        Subtitle Stream Configuration Parameters.
        """
        return pulumi.get(self, "subtitle_template")

    @subtitle_template.setter
    def subtitle_template(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplateArgs']]):
        pulumi.set(self, "subtitle_template", value)

    @property
    @pulumi.getter(name="tehdConfig")
    def tehd_config(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfigArgs']]:
        """
        Ultra-fast HD transcoding parameters.
        """
        return pulumi.get(self, "tehd_config")

    @tehd_config.setter
    def tehd_config(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfigArgs']]):
        pulumi.set(self, "tehd_config", value)

    @property
    @pulumi.getter(name="videoTemplate")
    def video_template(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplateArgs']]:
        """
        Video streaming configuration parameters.
        """
        return pulumi.get(self, "video_template")

    @video_template.setter
    def video_template(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplateArgs']]):
        pulumi.set(self, "video_template", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplateArgs:
    def __init__(__self__, *,
                 audio_channel: Optional[pulumi.Input[int]] = None,
                 bitrate: Optional[pulumi.Input[int]] = None,
                 codec: Optional[pulumi.Input[str]] = None,
                 sample_rate: Optional[pulumi.Input[int]] = None,
                 stream_selects: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] audio_channel: Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        :param pulumi.Input[int] bitrate: Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        :param pulumi.Input[str] codec: Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        :param pulumi.Input[int] sample_rate: Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] stream_selects: Specifies the audio track to preserve for the output. The default is to keep all sources.
        """
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)
        if stream_selects is not None:
            pulumi.set(__self__, "stream_selects", stream_selects)

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[pulumi.Input[int]]:
        """
        Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        return pulumi.get(self, "audio_channel")

    @audio_channel.setter
    def audio_channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "audio_channel", value)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[pulumi.Input[int]]:
        """
        Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_rate", value)

    @property
    @pulumi.getter(name="streamSelects")
    def stream_selects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Specifies the audio track to preserve for the output. The default is to keep all sources.
        """
        return pulumi.get(self, "stream_selects")

    @stream_selects.setter
    def stream_selects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "stream_selects", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplateArgs:
    def __init__(__self__, *,
                 font_alpha: Optional[pulumi.Input[float]] = None,
                 font_color: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 font_type: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 stream_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[float] font_alpha: Text transparency, value range: (0, 1].0: fully transparent.1: fully opaque.Default: 1.
        :param pulumi.Input[str] font_color: Font color, format: 0xRRGGBB, default value: 0xFFFFFF (white).
        :param pulumi.Input[str] font_size: Font size, format: Npx, N is a value, if not specified, the subtitle file shall prevail.
        :param pulumi.Input[str] font_type: Font type.hei.ttf, song.ttf, simkai.ttf, arial.ttf.Default: hei.ttf.
        :param pulumi.Input[str] path: The address of the subtitle file to be compressed into the video.
        :param pulumi.Input[int] stream_index: Specifies the subtitle track to be compressed into the video. If there is a specified Path, the Path has a higher priority. Path and StreamIndex specify at least one.
        """
        if font_alpha is not None:
            pulumi.set(__self__, "font_alpha", font_alpha)
        if font_color is not None:
            pulumi.set(__self__, "font_color", font_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if font_type is not None:
            pulumi.set(__self__, "font_type", font_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if stream_index is not None:
            pulumi.set(__self__, "stream_index", stream_index)

    @property
    @pulumi.getter(name="fontAlpha")
    def font_alpha(self) -> Optional[pulumi.Input[float]]:
        """
        Text transparency, value range: (0, 1].0: fully transparent.1: fully opaque.Default: 1.
        """
        return pulumi.get(self, "font_alpha")

    @font_alpha.setter
    def font_alpha(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "font_alpha", value)

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[pulumi.Input[str]]:
        """
        Font color, format: 0xRRGGBB, default value: 0xFFFFFF (white).
        """
        return pulumi.get(self, "font_color")

    @font_color.setter
    def font_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        Font size, format: Npx, N is a value, if not specified, the subtitle file shall prevail.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="fontType")
    def font_type(self) -> Optional[pulumi.Input[str]]:
        """
        Font type.hei.ttf, song.ttf, simkai.ttf, arial.ttf.Default: hei.ttf.
        """
        return pulumi.get(self, "font_type")

    @font_type.setter
    def font_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_type", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The address of the subtitle file to be compressed into the video.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="streamIndex")
    def stream_index(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the subtitle track to be compressed into the video. If there is a specified Path, the Path has a higher priority. Path and StreamIndex specify at least one.
        """
        return pulumi.get(self, "stream_index")

    @stream_index.setter
    def stream_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stream_index", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfigArgs:
    def __init__(__self__, *,
                 max_video_bitrate: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] max_video_bitrate: The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        :param pulumi.Input[str] type: Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        """
        if max_video_bitrate is not None:
            pulumi.set(__self__, "max_video_bitrate", max_video_bitrate)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="maxVideoBitrate")
    def max_video_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        """
        return pulumi.get(self, "max_video_bitrate")

    @max_video_bitrate.setter
    def max_video_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_video_bitrate", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplateArgs:
    def __init__(__self__, *,
                 bitrate: Optional[pulumi.Input[int]] = None,
                 codec: Optional[pulumi.Input[str]] = None,
                 content_adapt_stream: Optional[pulumi.Input[int]] = None,
                 fill_type: Optional[pulumi.Input[str]] = None,
                 fps: Optional[pulumi.Input[int]] = None,
                 gop: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 resolution_adaptive: Optional[pulumi.Input[str]] = None,
                 vcrf: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        :param pulumi.Input[str] codec: Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        :param pulumi.Input[int] content_adapt_stream: Content Adaptive Encoding. optional value:0: not open.1: open.Default: 0.When this parameter is turned on, multiple code streams with different resolutions and different bit rates will be adaptively generated. The width and height of the VideoTemplate are the maximum resolutions among the multiple code streams, and the bit rates in the VideoTemplate are multiple code rates. The highest bit rate in the stream, the vcrf in VideoTemplate is the highest quality among multiple bit streams. When the resolution, bit rate and vcrf are not set, the highest resolution generated by the ContentAdaptStream parameter is the resolution of the video source, and the video quality is close to vmaf95. To enable this parameter or learn about billing details, please contact your Tencent Cloud Business.
        :param pulumi.Input[str] fill_type: Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched;.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        :param pulumi.Input[int] fps: Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        :param pulumi.Input[int] gop: The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        :param pulumi.Input[int] height: The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        :param pulumi.Input[str] resolution_adaptive: Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        :param pulumi.Input[int] vcrf: Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        :param pulumi.Input[int] width: The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if content_adapt_stream is not None:
            pulumi.set(__self__, "content_adapt_stream", content_adapt_stream)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="contentAdaptStream")
    def content_adapt_stream(self) -> Optional[pulumi.Input[int]]:
        """
        Content Adaptive Encoding. optional value:0: not open.1: open.Default: 0.When this parameter is turned on, multiple code streams with different resolutions and different bit rates will be adaptively generated. The width and height of the VideoTemplate are the maximum resolutions among the multiple code streams, and the bit rates in the VideoTemplate are multiple code rates. The highest bit rate in the stream, the vcrf in VideoTemplate is the highest quality among multiple bit streams. When the resolution, bit rate and vcrf are not set, the highest resolution generated by the ContentAdaptStream parameter is the resolution of the video source, and the video quality is close to vmaf95. To enable this parameter or learn about billing details, please contact your Tencent Cloud Business.
        """
        return pulumi.get(self, "content_adapt_stream")

    @content_adapt_stream.setter
    def content_adapt_stream(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "content_adapt_stream", value)

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[pulumi.Input[str]]:
        """
        Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched;.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        """
        return pulumi.get(self, "fill_type")

    @fill_type.setter
    def fill_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_type", value)

    @property
    @pulumi.getter
    def fps(self) -> Optional[pulumi.Input[int]]:
        """
        Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter
    def gop(self) -> Optional[pulumi.Input[int]]:
        """
        The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        """
        return pulumi.get(self, "gop")

    @gop.setter
    def gop(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gop", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[pulumi.Input[str]]:
        """
        Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        """
        return pulumi.get(self, "resolution_adaptive")

    @resolution_adaptive.setter
    def resolution_adaptive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution_adaptive", value)

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[pulumi.Input[int]]:
        """
        Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        """
        return pulumi.get(self, "vcrf")

    @vcrf.setter
    def vcrf(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vcrf", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetRawParameterArgs:
    def __init__(__self__, *,
                 container: pulumi.Input[str],
                 audio_template: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplateArgs']] = None,
                 remove_audio: Optional[pulumi.Input[int]] = None,
                 remove_video: Optional[pulumi.Input[int]] = None,
                 tehd_config: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfigArgs']] = None,
                 video_template: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplateArgs']] = None):
        """
        :param pulumi.Input[str] container: Encapsulation format, optional values: mp4, flv, hls, mp3, flac, ogg, m4a. Among them, mp3, flac, ogg, m4a are pure audio files.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplateArgs'] audio_template: Audio stream configuration parameters, when RemoveAudio is 0, this field is required.
        :param pulumi.Input[int] remove_audio: Whether to remove audio data, value:0: reserved.1: remove.Default: 0.
        :param pulumi.Input[int] remove_video: Whether to remove video data, value:0: reserved.1: remove.Default: 0.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfigArgs'] tehd_config: Ultra-fast HD transcoding parameters.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplateArgs'] video_template: Video stream configuration parameters, when RemoveVideo is 0, this field is required.
        """
        pulumi.set(__self__, "container", container)
        if audio_template is not None:
            pulumi.set(__self__, "audio_template", audio_template)
        if remove_audio is not None:
            pulumi.set(__self__, "remove_audio", remove_audio)
        if remove_video is not None:
            pulumi.set(__self__, "remove_video", remove_video)
        if tehd_config is not None:
            pulumi.set(__self__, "tehd_config", tehd_config)
        if video_template is not None:
            pulumi.set(__self__, "video_template", video_template)

    @property
    @pulumi.getter
    def container(self) -> pulumi.Input[str]:
        """
        Encapsulation format, optional values: mp4, flv, hls, mp3, flac, ogg, m4a. Among them, mp3, flac, ogg, m4a are pure audio files.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[str]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="audioTemplate")
    def audio_template(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplateArgs']]:
        """
        Audio stream configuration parameters, when RemoveAudio is 0, this field is required.
        """
        return pulumi.get(self, "audio_template")

    @audio_template.setter
    def audio_template(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplateArgs']]):
        pulumi.set(self, "audio_template", value)

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to remove audio data, value:0: reserved.1: remove.Default: 0.
        """
        return pulumi.get(self, "remove_audio")

    @remove_audio.setter
    def remove_audio(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remove_audio", value)

    @property
    @pulumi.getter(name="removeVideo")
    def remove_video(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to remove video data, value:0: reserved.1: remove.Default: 0.
        """
        return pulumi.get(self, "remove_video")

    @remove_video.setter
    def remove_video(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remove_video", value)

    @property
    @pulumi.getter(name="tehdConfig")
    def tehd_config(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfigArgs']]:
        """
        Ultra-fast HD transcoding parameters.
        """
        return pulumi.get(self, "tehd_config")

    @tehd_config.setter
    def tehd_config(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfigArgs']]):
        pulumi.set(self, "tehd_config", value)

    @property
    @pulumi.getter(name="videoTemplate")
    def video_template(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplateArgs']]:
        """
        Video stream configuration parameters, when RemoveVideo is 0, this field is required.
        """
        return pulumi.get(self, "video_template")

    @video_template.setter
    def video_template(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplateArgs']]):
        pulumi.set(self, "video_template", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplateArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 sample_rate: pulumi.Input[int],
                 audio_channel: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        :param pulumi.Input[str] codec: Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        :param pulumi.Input[int] sample_rate: Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        :param pulumi.Input[int] audio_channel: Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Bit rate of the audio stream, value range: 0 and [26, 256], unit: kbps.When the value is 0, it means that the audio bit rate is consistent with the original audio.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Encoding format of frequency stream.When the outer parameter Container is mp3, the optional value is:libmp3lame.When the outer parameter Container is ogg or flac, the optional value is:flac.When the outer parameter Container is m4a, the optional value is:libfdk_aac.libmp3lame.ac3.When the outer parameter Container is mp4 or flv, the optional value is:libfdk_aac: more suitable for mp4.libmp3lame: more suitable for flv.When the outer parameter Container is hls, the optional value is:libfdk_aac.libmp3lame.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> pulumi.Input[int]:
        """
        Sampling rate of audio stream, optional value.32000.44100.48000.Unit: Hz.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: pulumi.Input[int]):
        pulumi.set(self, "sample_rate", value)

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[pulumi.Input[int]]:
        """
        Audio channel mode, optional values:`1: single channel.2: Dual channel.6: Stereo.When the package format of the media is an audio format (flac, ogg, mp3, m4a), the number of channels is not allowed to be set to stereo.Default: 2.
        """
        return pulumi.get(self, "audio_channel")

    @audio_channel.setter
    def audio_channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "audio_channel", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 max_video_bitrate: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        :param pulumi.Input[int] max_video_bitrate: The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        """
        pulumi.set(__self__, "type", type)
        if max_video_bitrate is not None:
            pulumi.set(__self__, "max_video_bitrate", max_video_bitrate)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Extremely high-definition type, optional value:TEHD-100: Extreme HD-100.Not filling means that the ultra-fast high-definition is not enabled.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="maxVideoBitrate")
    def max_video_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        The upper limit of the video bit rate, which is valid when the Type specifies the ultra-fast HD type.Do not fill in or fill in 0 means that there is no upper limit on the video bit rate.
        """
        return pulumi.get(self, "max_video_bitrate")

    @max_video_bitrate.setter
    def max_video_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_video_bitrate", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplateArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 fps: pulumi.Input[int],
                 fill_type: Optional[pulumi.Input[str]] = None,
                 gop: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 resolution_adaptive: Optional[pulumi.Input[str]] = None,
                 vcrf: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        :param pulumi.Input[str] codec: Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        :param pulumi.Input[int] fps: Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        :param pulumi.Input[str] fill_type: Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched;.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        :param pulumi.Input[int] gop: The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        :param pulumi.Input[int] height: The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        :param pulumi.Input[str] resolution_adaptive: Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        :param pulumi.Input[int] vcrf: Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        :param pulumi.Input[int] width: The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Bit rate of the video stream, value range: 0 and [128, 35000], unit: kbps.When the value is 0, it means that the video bit rate is consistent with the original video.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Encoding format of the video stream, optional value:libx264: H.264 encoding.libx265: H.265 encoding.av1: AOMedia Video 1 encoding.Note: Currently H.265 encoding must specify a resolution, and it needs to be within 640*480.Note: av1 encoded containers currently only support mp4.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def fps(self) -> pulumi.Input[int]:
        """
        Video frame rate, value range: [0, 100], unit: Hz.When the value is 0, it means that the frame rate is consistent with the original video.Note: The value range for adaptive code rate is [0, 60].
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: pulumi.Input[int]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[pulumi.Input[str]]:
        """
        Filling method, when the aspect ratio of the video stream configuration is inconsistent with the aspect ratio of the original video, the processing method for transcoding is filling. Optional filling method:stretch: Stretch, stretch each frame to fill the entire screen, which may cause the transcoded video to be squashed or stretched;.black: Leave black, keep the aspect ratio of the video unchanged, and fill the rest of the edge with black.white: Leave blank, keep the aspect ratio of the video unchanged, and fill the rest of the edge with white.gauss: Gaussian blur, keep the aspect ratio of the video unchanged, and fill the rest of the edge with Gaussian blur.Default: black.Note: Adaptive stream only supports stretch, black.
        """
        return pulumi.get(self, "fill_type")

    @fill_type.setter
    def fill_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_type", value)

    @property
    @pulumi.getter
    def gop(self) -> Optional[pulumi.Input[int]]:
        """
        The interval between keyframe I frames, value range: 0 and [1, 100000], unit: number of frames.When filling 0 or not filling, the system will automatically set the gop length.
        """
        return pulumi.get(self, "gop")

    @gop.setter
    def gop(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gop", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum value of video stream height (or short side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[pulumi.Input[str]]:
        """
        Adaptive resolution, optional values:```open: open, at this time, Width represents the long side of the video, Height represents the short side of the video.close: close, at this time, Width represents the width of the video, and Height represents the height of the video.Default: open.Note: In adaptive mode, Width cannot be smaller than Height.
        """
        return pulumi.get(self, "resolution_adaptive")

    @resolution_adaptive.setter
    def resolution_adaptive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution_adaptive", value)

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[pulumi.Input[int]]:
        """
        Video constant bit rate control factor, the value range is [1, 51].If this parameter is specified, the code rate control method of CRF will be used for transcoding (the video code rate will no longer take effect).If there is no special requirement, it is not recommended to specify this parameter.
        """
        return pulumi.get(self, "vcrf")

    @vcrf.setter
    def vcrf(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vcrf", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum value of video stream width (or long side), value range: 0 and [128, 4096], unit: px.When Width and Height are both 0, the resolution is the same.When Width is 0 and Height is not 0, Width is scaled proportionally.When Width is not 0 and Height is 0, Height is scaled proportionally.When both Width and Height are not 0, the resolution is specified by the user.Default: 0.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[int],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 raw_parameter: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterArgs']] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] definition: Watermark Template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterArgs'] raw_parameter: Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        :param pulumi.Input[float] start_time_offset: The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        :param pulumi.Input[str] svg_content: SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        :param pulumi.Input[str] text_content: Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if raw_parameter is not None:
            pulumi.set(__self__, "raw_parameter", raw_parameter)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[int]:
        """
        Watermark Template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[int]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of watermark, unit: second.Do not fill in or fill in 0, indicating that the watermark lasts until the end of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark lasts until the nth second and disappears.When the value is less than 0 (assumed to be -n), it means that the watermark lasts until it disappears n seconds before the end of the screen.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="rawParameter")
    def raw_parameter(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterArgs']]:
        """
        Watermark custom parameters, valid when Definition is filled with 0.This parameter is used in highly customized scenarios, it is recommended that you use Definition to specify watermark parameters first.Watermark custom parameters do not support screenshot watermarking.
        """
        return pulumi.get(self, "raw_parameter")

    @raw_parameter.setter
    def raw_parameter(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterArgs']]):
        pulumi.set(self, "raw_parameter", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        The start time offset of the watermark, unit: second. Do not fill in or fill in 0, which means that the watermark will start to appear when the screen appears.Do not fill in or fill in 0, which means the watermark will appear from the beginning of the screen.When the value is greater than 0 (assumed to be n), it means that the watermark appears from the nth second of the screen.When the value is less than 0 (assumed to be -n), it means that the watermark starts to appear n seconds before the end of the screen.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content. The length cannot exceed 2000000 characters. Fill in only if the watermark type is SVG watermark.SVG watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content, the length does not exceed 100 characters. Fill in only when the watermark type is text watermark.Text watermark does not support screenshot watermarking.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 coordinate_origin: Optional[pulumi.Input[str]] = None,
                 image_template: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateArgs']] = None,
                 x_pos: Optional[pulumi.Input[str]] = None,
                 y_pos: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Watermark type, optional value:image: image watermark.
        :param pulumi.Input[str] coordinate_origin: Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateArgs'] image_template: Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        :param pulumi.Input[str] x_pos: The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        :param pulumi.Input[str] y_pos: The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        pulumi.set(__self__, "type", type)
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if image_template is not None:
            pulumi.set(__self__, "image_template", image_template)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Watermark type, optional value:image: image watermark.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[pulumi.Input[str]]:
        """
        Origin position, currently only supports:TopLeft: Indicates that the origin of the coordinates is at the upper left corner of the video image, and the origin of the watermark is the upper left corner of the picture or text.Default: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @coordinate_origin.setter
    def coordinate_origin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coordinate_origin", value)

    @property
    @pulumi.getter(name="imageTemplate")
    def image_template(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateArgs']]:
        """
        Image watermark template, when Type is image, this field is required. When Type is text, this field is invalid.
        """
        return pulumi.get(self, "image_template")

    @image_template.setter
    def image_template(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateArgs']]):
        pulumi.set(self, "image_template", value)

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The horizontal position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark XPos specifies a percentage for the video width, such as 10% means that XPos is 10% of the video width.When the string ends with px, it means that the watermark XPos is the specified pixel, such as 100px means that the XPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "x_pos")

    @x_pos.setter
    def x_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_pos", value)

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The vertical position of the origin of the watermark from the origin of the coordinates of the video image. Support %, px two formats:When the string ends with %, it means that the watermark YPos specifies a percentage for the video height, such as 10% means that YPos is 10% of the video height.When the string ends with px, it means that the watermark YPos is the specified pixel, such as 100px means that the YPos is 100 pixels.Default: 0px.
        """
        return pulumi.get(self, "y_pos")

    @y_pos.setter
    def y_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "y_pos", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateArgs:
    def __init__(__self__, *,
                 image_content: pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs'],
                 height: Optional[pulumi.Input[str]] = None,
                 repeat_type: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs'] image_content: The input content of the watermark image. Support jpeg, png image format.
        :param pulumi.Input[str] height: The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        :param pulumi.Input[str] repeat_type: Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        :param pulumi.Input[str] width: The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs']:
        """
        The input content of the watermark image. Support jpeg, png image format.
        """
        return pulumi.get(self, "image_content")

    @image_content.setter
    def image_content(self, value: pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs']):
        pulumi.set(self, "image_content", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        The height of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Height is the percentage size of the video height, such as 10% means that the Height is 10% of the video height.When the string ends with px, it means that the watermark Height unit is pixel, such as 100px means that the Height is 100 pixels.Default value: 0px, indicating that Height is scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark repeat type. Usage scenario: The watermark is a dynamic image. Ranges.once: After the dynamic watermark is played, it will no longer appear.repeat_last_frame: After the watermark is played, stay on the last frame.repeat: the watermark loops until the end of the video (default).
        """
        return pulumi.get(self, "repeat_type")

    @repeat_type.setter
    def repeat_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_type", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        The width of the watermark. Support %, px two formats:When the string ends with %, it means that the watermark Width is a percentage of the video width, such as 10% means that the Width is 10% of the video width.When the string ends with px, it means that the watermark Width unit is pixels, such as 100px means that the Width is 100 pixels.Default: 10%.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']] = None,
                 url_input_info: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']] = None):
        """
        :param pulumi.Input[str] type: Enter the type of source object, which supports COS and URL.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs'] cos_input_info: Valid when Type is COS, this item is required, indicating media processing COS object information.
        :param pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs'] url_input_info: Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_input_info is not None:
            pulumi.set(__self__, "cos_input_info", cos_input_info)
        if url_input_info is not None:
            pulumi.set(__self__, "url_input_info", url_input_info)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Enter the type of source object, which supports COS and URL.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosInputInfo")
    def cos_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']]:
        """
        Valid when Type is COS, this item is required, indicating media processing COS object information.
        """
        return pulumi.get(self, "cos_input_info")

    @cos_input_info.setter
    def cos_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs']]):
        pulumi.set(self, "cos_input_info", value)

    @property
    @pulumi.getter(name="urlInputInfo")
    def url_input_info(self) -> Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']]:
        """
        Valid when Type is URL, this item is required, indicating media processing URL object information.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "url_input_info")

    @url_input_info.setter
    def url_input_info(self, value: Optional[pulumi.Input['WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs']]):
        pulumi.set(self, "url_input_info", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfoArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 object: pulumi.Input[str],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: The name of the COS Bucket where the media processing object file is located.
        :param pulumi.Input[str] object: Input path for media processing object files.
        :param pulumi.Input[str] region: The park to which the COS Bucket where the media processing target file resides belongs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the COS Bucket where the media processing object file is located.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        Input path for media processing object files.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The park to which the COS Bucket where the media processing target file resides belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfoArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: Video URL.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Video URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WorkflowOutputStorageArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_output_storage: Optional[pulumi.Input['WorkflowOutputStorageCosOutputStorageArgs']] = None):
        """
        :param pulumi.Input[str] type: The type of media processing output object storage location, now only supports COS.
        :param pulumi.Input['WorkflowOutputStorageCosOutputStorageArgs'] cos_output_storage: Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_output_storage is not None:
            pulumi.set(__self__, "cos_output_storage", cos_output_storage)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of media processing output object storage location, now only supports COS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosOutputStorage")
    def cos_output_storage(self) -> Optional[pulumi.Input['WorkflowOutputStorageCosOutputStorageArgs']]:
        """
        Valid when Type is COS, this item is required, indicating the media processing COS output location.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_output_storage")

    @cos_output_storage.setter
    def cos_output_storage(self, value: Optional[pulumi.Input['WorkflowOutputStorageCosOutputStorageArgs']]):
        pulumi.set(self, "cos_output_storage", value)


@pulumi.input_type
class WorkflowOutputStorageCosOutputStorageArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        :param pulumi.Input[str] region: The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The target Bucket name of the file output generated by media processing, if not filled, it means the upper layer.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The park of the target Bucket for the output of the file generated by media processing. If not filled, it means inheriting from the upper layer.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class WorkflowTaskNotifyConfigArgs:
    def __init__(__self__, *,
                 cmq_model: Optional[pulumi.Input[str]] = None,
                 cmq_region: Optional[pulumi.Input[str]] = None,
                 notify_mode: Optional[pulumi.Input[str]] = None,
                 notify_type: Optional[pulumi.Input[str]] = None,
                 notify_url: Optional[pulumi.Input[str]] = None,
                 queue_name: Optional[pulumi.Input[str]] = None,
                 topic_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cmq_model: CMQ or TDMQ-CMQ model, there are two kinds of Queue and Topic.
        :param pulumi.Input[str] cmq_region: Region of CMQ or TDMQ-CMQ, such as sh, bj, etc.
        :param pulumi.Input[str] notify_mode: The mode of the workflow notification, the possible values are Finish and Change, leaving blank means Finish.
        :param pulumi.Input[str] notify_type: Notification type, optional value:CMQ: offline, it is recommended to switch to TDMQ-CMQ.TDMQ-CMQ: message queue.URL: When the URL is specified, the HTTP callback is pushed to the address specified by NotifyUrl, the callback protocol is http+json, and the package body content is the same as the output parameters of the parsing event notification interface.SCF: not recommended, additional configuration of SCF in the console is required.Note: CMQ is the default when not filled or empty, if you need to use other types, you need to fill in the corresponding type value.
        :param pulumi.Input[str] notify_url: HTTP callback address, required when NotifyType is URL.
        :param pulumi.Input[str] queue_name: Valid when the model is Queue, indicating the queue name of the CMQ or TDMQ-CMQ that receives the event notification.
        :param pulumi.Input[str] topic_name: Valid when the model is a Topic, indicating the topic name of the CMQ or TDMQ-CMQ that receives event notifications.
        """
        if cmq_model is not None:
            pulumi.set(__self__, "cmq_model", cmq_model)
        if cmq_region is not None:
            pulumi.set(__self__, "cmq_region", cmq_region)
        if notify_mode is not None:
            pulumi.set(__self__, "notify_mode", notify_mode)
        if notify_type is not None:
            pulumi.set(__self__, "notify_type", notify_type)
        if notify_url is not None:
            pulumi.set(__self__, "notify_url", notify_url)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter(name="cmqModel")
    def cmq_model(self) -> Optional[pulumi.Input[str]]:
        """
        CMQ or TDMQ-CMQ model, there are two kinds of Queue and Topic.
        """
        return pulumi.get(self, "cmq_model")

    @cmq_model.setter
    def cmq_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cmq_model", value)

    @property
    @pulumi.getter(name="cmqRegion")
    def cmq_region(self) -> Optional[pulumi.Input[str]]:
        """
        Region of CMQ or TDMQ-CMQ, such as sh, bj, etc.
        """
        return pulumi.get(self, "cmq_region")

    @cmq_region.setter
    def cmq_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cmq_region", value)

    @property
    @pulumi.getter(name="notifyMode")
    def notify_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode of the workflow notification, the possible values are Finish and Change, leaving blank means Finish.
        """
        return pulumi.get(self, "notify_mode")

    @notify_mode.setter
    def notify_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notify_mode", value)

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> Optional[pulumi.Input[str]]:
        """
        Notification type, optional value:CMQ: offline, it is recommended to switch to TDMQ-CMQ.TDMQ-CMQ: message queue.URL: When the URL is specified, the HTTP callback is pushed to the address specified by NotifyUrl, the callback protocol is http+json, and the package body content is the same as the output parameters of the parsing event notification interface.SCF: not recommended, additional configuration of SCF in the console is required.Note: CMQ is the default when not filled or empty, if you need to use other types, you need to fill in the corresponding type value.
        """
        return pulumi.get(self, "notify_type")

    @notify_type.setter
    def notify_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notify_type", value)

    @property
    @pulumi.getter(name="notifyUrl")
    def notify_url(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP callback address, required when NotifyType is URL.
        """
        return pulumi.get(self, "notify_url")

    @notify_url.setter
    def notify_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notify_url", value)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[str]]:
        """
        Valid when the model is Queue, indicating the queue name of the CMQ or TDMQ-CMQ that receives the event notification.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "queue_name", value)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[pulumi.Input[str]]:
        """
        Valid when the model is a Topic, indicating the topic name of the CMQ or TDMQ-CMQ that receives event notifications.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic_name", value)


@pulumi.input_type
class WorkflowTriggerArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cos_file_upload_trigger: Optional[pulumi.Input['WorkflowTriggerCosFileUploadTriggerArgs']] = None):
        """
        :param pulumi.Input[str] type: The type of trigger, currently only supports CosFileUpload.
        :param pulumi.Input['WorkflowTriggerCosFileUploadTriggerArgs'] cos_file_upload_trigger: Mandatory and valid when Type is CosFileUpload, the rule is triggered for COS.Note: This field may return null, indicating that no valid value can be obtained.
        """
        pulumi.set(__self__, "type", type)
        if cos_file_upload_trigger is not None:
            pulumi.set(__self__, "cos_file_upload_trigger", cos_file_upload_trigger)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of trigger, currently only supports CosFileUpload.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cosFileUploadTrigger")
    def cos_file_upload_trigger(self) -> Optional[pulumi.Input['WorkflowTriggerCosFileUploadTriggerArgs']]:
        """
        Mandatory and valid when Type is CosFileUpload, the rule is triggered for COS.Note: This field may return null, indicating that no valid value can be obtained.
        """
        return pulumi.get(self, "cos_file_upload_trigger")

    @cos_file_upload_trigger.setter
    def cos_file_upload_trigger(self, value: Optional[pulumi.Input['WorkflowTriggerCosFileUploadTriggerArgs']]):
        pulumi.set(self, "cos_file_upload_trigger", value)


@pulumi.input_type
class WorkflowTriggerCosFileUploadTriggerArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 region: pulumi.Input[str],
                 dir: Optional[pulumi.Input[str]] = None,
                 formats: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] bucket: The name of the COS Bucket bound to the workflow.
        :param pulumi.Input[str] region: The park to which the COS Bucket bound to the workflow belongs.
        :param pulumi.Input[str] dir: The input path directory of the workflow binding must be an absolute path, that is, start and end with `/`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] formats: A list of file formats that are allowed to be triggered by the workflow, if not filled in, it means that files of all formats can trigger the workflow.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "region", region)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if formats is not None:
            pulumi.set(__self__, "formats", formats)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the COS Bucket bound to the workflow.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The park to which the COS Bucket bound to the workflow belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def dir(self) -> Optional[pulumi.Input[str]]:
        """
        The input path directory of the workflow binding must be an absolute path, that is, start and end with `/`.
        """
        return pulumi.get(self, "dir")

    @dir.setter
    def dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dir", value)

    @property
    @pulumi.getter
    def formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of file formats that are allowed to be triggered by the workflow, if not filled in, it means that files of all formats can trigger the workflow.
        """
        return pulumi.get(self, "formats")

    @formats.setter
    def formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "formats", value)


